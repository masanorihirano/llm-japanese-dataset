[
  {
    "index": "F1000",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "なのでマージソートから始めることには理由がある。",
    "output": "So those are the reasons to start out with Merge Sort."
  },
  {
    "index": "F1001",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さて、マージソートが解くべき計算的問題とはどんなものだろうか?",
    "output": "So what is the computational problem that Merge Sort is meant to solve?"
  },
  {
    "index": "F1002",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "君らは全員ソート問題を知ってると思うけど、念のためみんながついてこれるように、少しばかり説明するよ。",
    "output": "But let me tell you a little bit about it anyways, just so that we're all on the same page."
  },
  {
    "index": "F1003",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まず入力として、ランダムな順序のN個の数字の配列を入力として受け取る。それを数字の順序(例えば小さい順に)に整列させて出力するのがゴールだ。",
    "output": "An array of N numbers in arbitrary order, and the goal of course is to produce output array where the numbers are in sorted order, let's say, from smallest to largest."
  },
  {
    "index": "F1004",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "例えば、この入力配列を、こっちの出力配列のようにするのがゴールってことだ。",
    "output": "Okay so, for example, we could consider the following input array, and then the goal would be to produce the following output array."
  },
  {
    "index": "F1005",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "一つコメントすると、ここには8つの要素があり、それらは全てお互いに異なる1~8の整数値である。",
    "output": "Now one quick comment. You'll notice that here in input array, it had eight elements, all of them were distinct, it was the different integers, between 1 and 8."
  },
  {
    "index": "F1006",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ソート問題は、重複する値があっても別に難しくなるわけではない。それどころか易しくなると言える。",
    "output": "Now the sorting problem really isn't any harder if you have duplicates, in fact it can even be easier, ..."
  },
  {
    "index": "F1007",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だが、ここでは議論をシンプルにするために、このレクチャーにおいては、全ての値は異なるという仮定を置こう。",
    "output": "... but to keep the discussion as simple as possible let's just, among friends, go ahead and assume that they're distinct, for the purpose of this lecture."
  },
  {
    "index": "F1008",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "同じ値がある場合にソートアルゴリズムとその分析が異なるかどうか、異なるとしたらどうなるか、それについては君への宿題としよう。",
    "output": "And I'll leave it as an exercise which I encourage you to do, which is to think about how the Merge Sort algorithm implementation and analysis would be different, if at all, if there were ties, okay?"
  },
  {
    "index": "F1009",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "というわけで、シンプルにするために値が異なるとの仮定で進めるよ。",
    "output": "Go ahead and make the distinct assumption for simplicity from here on out."
  },
  {
    "index": "F1010",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "よし、まずは擬似コードを書く前に、アルゴリズムがどのように動くかを図で示そう。",
    "output": "Okay, so before I write down any pseudo code for Merge Sort, let me just show you how the algorithm works using a picture, ..."
  },
  {
    "index": "F1011",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "どういうコードになるのはかなり明らかだと思うよ。たった一つの例を見るだけでも十分だ。",
    "output": "and I think it'll be pretty clear what the code would be, even just given a single example."
  },
  {
    "index": "F1012",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だからどんとん進めて行こう。前のスライドのソートされてない配列の入力を考えよう。",
    "output": "So let's go ahead and consider the same unsorted input array that we had on the previous slide."
  },
  {
    "index": "F1013",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "MergeSortは再帰的なアルゴリズムだ。それが意味するのはプログラムが自分自身を同じ形で、でも少し小さな問題に分けて呼び出すって事だ。",
    "output": "So the Merge Sort algorithm is a recursive algorithm, and again, that means that a program which calls itself and it calls itself on smaller sub problems of the same form, okay?"
  },
  {
    "index": "F1014",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "MergeSortの場合、その人生の目的は入力の配列をソートする事だ。",
    "output": "So the Merge Sort is its purpose in life is to sort the given input array."
  },
  {
    "index": "F1015",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "その為に、より小さな配列に対して、自分自身をまた生み出す、または呼び出す。",
    "output": "So it's going to spawn, or call itself on smaller arrays."
  },
  {
    "index": "F1016",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "入力の配列を単純に半分に分けて、左半分を再帰的に解き、右半分を再帰的に解き、そして両方の結果を結合する。",
    "output": "And this is gonna be a canonical Divide-and-Conquer application, where we simply take the input array, we split it in half, we solve the left half recursively, we solve the right half recursively, and then we combine the results."
  },
  {
    "index": "F1017",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それを絵で見てみましょう。",
    "output": "So let's look at that in the picture."
  },
  {
    "index": "F1018",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最初の再帰呼び出しは配列の左半分として最初の4つの要素、5,4,1,8を取る。",
    "output": "So the first recursive call gets the first four elements, the left half of the array, namely 5, 4, 1, 8."
  },
  {
    "index": "F1019",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もちろんもう一つの再帰は残りの7,2,6,3を取る。",
    "output": "And, of course, the other recursive call is gonna get the rest of the elements, 7, 2, 6, 3."
  },
  {
    "index": "F1020",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "再帰呼び出しに渡される前にこれらの値は新しい配列にコピーされることは想像がつくと思う。",
    "output": "You can imagine these has been copied into new arrays before they're given to the recursive calls."
  },
  {
    "index": "F1021",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そうしたら、再帰の魔法により、もしくは帰納でも何でもいいが、再帰呼び出しが自分の仕事をしてくれる。",
    "output": "Now, by the magic of recursion, or by induction if you like, the recursive calls will do their task."
  },
  {
    "index": "F1022",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり4要素の配列を正しくソートしてくれる。ソート済みバージョンで戻ってくる。",
    "output": "They will correctly sort each of these arrays of four elements, and we'll get back sorted versions of them."
  },
  {
    "index": "F1023",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最初の再帰呼び出しからは1,4,5,8が、次のからは2,3,6,7が。",
    "output": "So from our first recursive call, we receive the output, 1, 4, 5, 8, and from the second recursive call, we received the sorted output, 2, 3, 6, 7."
  },
  {
    "index": "F1024",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "するとマージソートを終わらせるために残っているのは、2つの再帰呼び出しの結果であるソート済み配列を受け取って、最終結果、つまりはじめの8個の要素をソートした配列を作ることだ。",
    "output": "So now, all the remains to complete the Merge Sort is to take the two results of our recursive calls, these two sorted elements of length-4, and combine them to produce the final output, namely the sorted array of all eight of the input numbers."
  },
  {
    "index": "F1025",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これがマージと呼ばれるステップだきっと皆さんも、自分ならどうすれば計算機科学的に効率的にこのマージが実装できるか考え始めていることと思う詳細についてはみなさんにお任せします。",
    "output": "And hopefully you are already are thinking about how you might actually implement this merge in a computationally efficient way."
  },
  {
    "index": "F1026",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでは正確にはどうマージが行われるかを話します。",
    "output": "And I will tell you exactly how the merge is done."
  },
  {
    "index": "F1027",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実際には、2つのソート済み部分配列それぞれでポインタを動かし、コピーして、ソートされた順序で出力配列に書き出します。",
    "output": "In effect, you just walk pointers down each of the two sort of sub-arrays, copying over, populating the output array in the sorted order."
  },
  {
    "index": "F1028",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もう少し詳細を、スライド1、2枚で説明しましょう。",
    "output": "But I will give you some more details in just a slide or two."
  },
  {
    "index": "F1029",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "半分に分け再帰的に解き、素晴らしいマージの手続きによって2つの結果を一つのソート済みの出力にします。",
    "output": "Split it in half, solve recursively, and then have some slick merging procedure to combine the two results into a sorted output."
  },
  {
    "index": "F1030",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "どんどん行きましょう。そして実際にMergeSortの擬似コードを議論していきましょう。",
    "output": "Okay, so let's move on, and actually discuss the pseudo-code for the merge sort algorithm."
  },
  {
    "index": "F1031",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最初に擬似コードの話をします、マージのサブルーチンがどう実装されてるのかは脇においといて。",
    "output": "First, let me just tell you the pseudo-code, leaving aside exactly how the merging subroutine is implemented."
  },
  {
    "index": "F1032",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "なので、上のレベルではこの点はとてもシンプルで明確なはずです。",
    "output": "And thus, high levels should be very simple and clear at this point."
  },
  {
    "index": "F1033",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "2つの再帰呼び出しがあり、そしてマージのステップがある。ここでちょっとコメントがあります。",
    "output": "So there's gonna be two recursive calls, and then there's gonna be a merging step."
  },
  {
    "index": "F1034",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私はちょっとだらしないので、お約束したように、これは直接コードに翻訳するような何かではありません。",
    "output": "Again, as I promised, this isn't something you would directly translate into code, although it's pretty close."
  },
  {
    "index": "F1035",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "結構それに近いですけどね。でもどこで手抜きをしてるんでしょうか?",
    "output": "But so what are the couple of the ways that I'm being sloppy?"
  },
  {
    "index": "F1036",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まずはじめに、基底のケースが無い。ご存知のように、全ての再帰のアルゴリズムは基底の場合の処理があります。",
    "output": "Well, first of all, there's, , you know, in any recursive algorithm, you gotta have some base cases."
  },
  {
    "index": "F1037",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そこに至るのは入力が十分小さくなってそれ以上再帰がいらなくなった所でです。",
    "output": "You gotta have this idea that when the input's sufficient."
  },
  {
    "index": "F1038",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ただトリビアルな答えを返すだけ。",
    "output": "Really small you don't do any recursion, you just return some trivial answer."
  },
  {
    "index": "F1039",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ソートのアルゴリズムなら基底のケースは長さゼロの配列か要素が一つだけ入った配列、って所でしょう。それは既にソートされてるので、特にやる事は無い。",
    "output": "So in the sorting problem the base case would be if your handed an array that has either zero or an elements, well it's already sorted, there's nothing to do, so you just return it without any recursion."
  },
  {
    "index": "F1040",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "OK。分かりやすくするために、基底のケースは書きません。",
    "output": "Okay, so to be clear, I haven't written down the base cases."
  },
  {
    "index": "F1041",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もちろんあなたが実際にマージソートを実装する時は書かないとダメですが。その事は気に留めておいた方がいいかも。",
    "output": "Although of course you would if you were actually implementing, a merge short."
  },
  {
    "index": "F1042",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "どっちでも好きな方にしてよろしい。",
    "output": "Some of you, make a note of that."
  },
  {
    "index": "F1043",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "二番目に、私は詳細、または再帰的なソートという時に実際には何を意味しているか、を無視している。",
    "output": "A couple of other things I'm ignoring. I'm ignoring what the, what to do if the array has odd lengths, so if it has say nine elements, obviously you have to somehow break that into five and four or four and five, so you would do that just in either way and that would fine."
  },
  {
    "index": "F1044",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "例えば、これらの部分配列をどう再帰呼び出しに渡すかを正確に議論したりはしない。",
    "output": "And then secondly, I'm ignoring the details or what it really means to sort of recursively sort, so for example, I'm not discussing exactly how you would pass these subarrays onto the recursive calls."
  },
  {
    "index": "F1045",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それは何のプログラミング言語で作業してるか、とかに凄く依存する所ですからね。それがまさに私の避けたい事でもあるので。",
    "output": "That's something that would really depend somewhat on what, on the programming language, so that's exactly what I want to avoid."
  },
  {
    "index": "F1046",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私は言語の実装を超えた、コンセプト的な所をお話したい。",
    "output": "I really want to talk about the concepts which transcend any particular programming language implementation."
  },
  {
    "index": "F1047",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そんな訳でアルゴリズムをこのレベルで記述していきます。オーケー。",
    "output": "So that's why I'm going to describe algorithms at this level okay."
  },
  {
    "index": "F1048",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では相対的に難しい部分はマージの底の部分をどう実装するか?",
    "output": "Alright, so the hard part relatively speaking, that is. How do you implement the merge depth?"
  },
  {
    "index": "F1049",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "再帰呼び出しは彼ら自身の仕事をする。",
    "output": "The recursive calls have done their work."
  },
  {
    "index": "F1050",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これら半分づつソートされた数たちを得る。",
    "output": "We have these two sort of separated half the numbers."
  },
  {
    "index": "F1051",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "左半分と右半分。",
    "output": "The left half and the right half."
  },
  {
    "index": "F1052",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これらをどう一つにまとめるか?",
    "output": "How do we combine them into one?"
  },
  {
    "index": "F1053",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "英語ではすでに直前のスライドに書いた。",
    "output": "And in English, I already told you on the last slide."
  },
  {
    "index": "F1054",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ポインタをたどるか、ソートされた部分配列を並行にたどるかして、出力配列をソートされた形にして埋めてゆくというアイデアだ。",
    "output": "The idea is you just populate the output array in a sorted order, by traversing pointers or just traversing through the two, sorted sub-arrays in parallel."
  },
  {
    "index": "F1055",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もっとくわしく見てみよう。",
    "output": "So let's look at that in some more detail."
  },
  {
    "index": "F1056",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "オッケー、ここにマージのステップの擬似コードがある。",
    "output": "Okay, so here is the pseudo-code for the merge step."
  },
  {
    "index": "F1057",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "(音)まずは対象の名前を決めよう。ここでは出力配列をCで表すことにする。",
    "output": "So let me begin by, introducing some names for the, characters in the, what we're about to discuss."
  },
  {
    "index": "F1058",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これに数値をソートされた順に出力することを考える。",
    "output": "To denote the output array. So this is what we're suppose to spit out with the numbers in sorted order."
  },
  {
    "index": "F1059",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして、二つの再帰呼び出しの結果をaとbと呼ぶことにする。",
    "output": "And then, I'm gonna use a and b to denote the results of the two recursive calls, okay?"
  },
  {
    "index": "F1060",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり、最初の再帰呼び出しがaで、入力配列の左半分がソートされた順で入っている。",
    "output": "So, the first recursive call has given us array a, which contains the left half of the input array in sorted order."
  },
  {
    "index": "F1061",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "同じくbには入力配列の右半分がまたソートされた順で入っている。",
    "output": "Similarly, b contains the right half of the input array, again, in sorted order."
  },
  {
    "index": "F1062",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さっき言ったように、ソートされた二つの部分配列aとbを並行にたどる必要がある。",
    "output": "So, as I said, we're gonna need to traverse the two, sorted sub-arrays, a and b, in parallel."
  },
  {
    "index": "F1063",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ではカウンタiをAを辿るのに、カウンタjをBを辿るのに導入する。",
    "output": "So, I'm gonna introduce a counter, i, to traverse through a, j to traverse through b."
  },
  {
    "index": "F1064",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "i,jは両方とも1に初期化。それぞれの配列の最初指すように。",
    "output": "I and j will both be initialized to one, to be at the beginning of their respective arrays."
  },
  {
    "index": "F1065",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして実行する、出力配列に昇順に一パスでコピーしていく。",
    "output": "We're going to do a single pass of the output array copying it in an increasing order."
  },
  {
    "index": "F1066",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "いつも2つのソートされた配列の両方から一番小さい物を取る。",
    "output": "Always taking the smallest from the union of the two sorted sub arrays."
  },
  {
    "index": "F1067",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここで一計。このマージの段階では、まだ見てない中で一番小さい要素は2つのリストのどちらかの先頭にある。",
    "output": "And if you, if there's one idea in this merge step it's just the realization that."
  },
  {
    "index": "F1068",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "例えばアルゴリズムの最初の段階では、最小の値は一体どこにあるか?",
    "output": "The minimum element that you haven't yet looked at in A and B has to be at the front of one or the two lists right so for example at the very beginning of the algorithm where is the minimum element over all."
  },
  {
    "index": "F1069",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "2つの配列、AかB、のどちらかだろう。最小の要素はどちらかにある。",
    "output": "Well, which ever of the two arrays it lands in -- A or B -- it has to be the smallest one there okay."
  },
  {
    "index": "F1070",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だから全体の中で最小の要素は、Aの最小の要素か、Bの最小の要素。",
    "output": "So the smallest element over all is either the smallest element A or it's the smallest element B."
  },
  {
    "index": "F1071",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だから両方チェックして、より小さい方が最小の物だ。",
    "output": "So you just check both places, the smaller one is the smallest you copy it over and you repeat."
  },
  {
    "index": "F1072",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "以上。",
    "output": "That's it."
  },
  {
    "index": "F1073",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "Kの目的は出力の配列をただ左から右に辿るだけ。",
    "output": "So the purpose of K is just to traverse the output array from left to right."
  },
  {
    "index": "F1074",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今、最初の配列のi番目と二番目の配列のj番目を見ているとする。",
    "output": "That's the order we're gonna populate it. Currently looking at position I, and the first array of position J and the second array."
  },
  {
    "index": "F1075",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "どっちが最小か見る。そしてその最小の方をコピー。",
    "output": "We look at which one has the current smallest, and we copy the smallest one over."
  },
  {
    "index": "F1076",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "配列Aのi番目が小さければ、そっちをコピーする。",
    "output": "So if the, if, the entry in the i position of A is smaller, we copy that one over."
  },
  {
    "index": "F1077",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もちろんiをインクリメントもする。",
    "output": "Of course, we have to increment i."
  },
  {
    "index": "F1078",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "Aのリストをもう1段潜る。Bの現在地の方が小さい要素なら、対称的にやる。",
    "output": "We probe one deeper into the list A, and symmeterically for the case where the current position in B has the smaller element."
  },
  {
    "index": "F1079",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでもちょっとさぼって森を見る事に集中していて、木々の中には立ち入らない。終条件を無視してる。",
    "output": "Now again, I'm being a little bit sloppy, so that we can focus on the forest, and not sort of, And not get bogged down with the trees."
  },
  {
    "index": "F1080",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だから本当に実装したければ、もうちょっと足さないとダメ。AかBからはみ出ないように。",
    "output": "I'm ignoring some end cases, so if you really wanted to implement this, you'd have to add a little bit, to keep track of when you fall off, either, either A or B."
  },
  {
    "index": "F1081",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "その為にiとjは終端に来ているか、のチェックをして、そこまで行ったら残った要素を全部Cにコピーする。",
    "output": "Because you have additional checks for when i or j reaches the end of the array, at which point you copy over all the remaining elements into C."
  },
  {
    "index": "F1082",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "オーライ、擬似コードの清書版をお見せする。もはやどうしても必要な時以外は私の怪しい手書きに耐える必要はない。",
    "output": "Alright, so I'm gonna give you a cleaned up version, of, that pseudo-code so that you don't have to tolerate my questionable handwriting any longer than is absolutely necessary."
  },
  {
    "index": "F1083",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは直前のスライドに書いたものと全く同じものだ。オーケー?",
    "output": "This again, is just the same thing that we wrote on the last slide, okay?"
  },
  {
    "index": "F1084",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "マージステップの擬似コード。",
    "output": "The pseudo-code for the merge step."
  },
  {
    "index": "F1085",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "すなわちマージソートのアルゴリズムだ。",
    "output": "Now, so that's the Merge Sort algorithm."
  },
  {
    "index": "F1086",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この講義の素晴らしい部分、マージソートがソートされた配列を出力するところを見よう。",
    "output": "Now let's get to the meaty part of this lecture, which is, okay, so merge sort produces a sorted array."
  },
  {
    "index": "F1087",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "なぜもっと単純な分割統治ではないアルゴリズム、例えば挿入ソートよりむしろ良いといえるのか?",
    "output": "What makes it, if anything, better than much simpler non divide and conquer algorithms, like say, insertion sort?"
  },
  {
    "index": "F1088",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "別の言い方をするとマージソートの実行時間はどうなのか?",
    "output": "Other words, what is the running time of the merge sort algorithm?"
  },
  {
    "index": "F1089",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "完全で正確な定義はしないが、少しだけ話そう。",
    "output": "Now I'm not gonna give you a completely precise definition, definition of what I mean by running time and there's good reason for that, as we'll discuss shortly."
  },
  {
    "index": "F1090",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし直観的にはアルゴリズムの実行時間は、アルゴリズムをデバッガで動かすことを思えばよい。",
    "output": "But intuitively, you should think of the running time of an algorithm, you should imagine that you're just running the algorithm in a debugger."
  },
  {
    "index": "F1091",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり、デバッガで毎回エンターキーを押してプログラムを一行ずつ進める。",
    "output": "Then, every time you press enter, you advance with one line of the program through the debugger."
  },
  {
    "index": "F1092",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして基本的には、実行時間はちょうど実行された操作の数、実行されたコードの行数になる。",
    "output": "And then basically, the running time is just a number of operations executed, the number of lines of code executed."
  },
  {
    "index": "F1093",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そこで問題になるのが、プログラムが最終的に停止するまでに何回エンターキーを押す必要があるのかということだ。",
    "output": "So the question is, how many times you have to hit enter on the debugger before the, program finally terminates."
  },
  {
    "index": "F1094",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "知りたいのは、いったい何行のコードが入力配列の長さがNのとき、マージソートで実行されるかそれはかなり、込み入った質問だ。",
    "output": "So we're interested in how many such, lines of code get executed for Merge Short when an input array has n numbers."
  },
  {
    "index": "F1095",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だからもっと穏健な学派から始めよう。",
    "output": "So let's start with a more modest school."
  },
  {
    "index": "F1096",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "MergeSort、このクレージーに再帰的なアルゴリズム、自分自身を呼んで呼んでよびまくる物の、実行されるオペレーションの数を考えるのではなく、2つのソートされたサブ配列を一回マージするのにかかるオペレーションの数だけを数えてみよう。",
    "output": "Rather than thinking about the number of operations executed by Merge Sort, which is this crazy recursive algorithm, which is calling itself over and over and over again."
  },
  {
    "index": "F1097",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "開始の場所としてはこっちの方が簡単そう。",
    "output": "That seems like it should be an easier place to start."
  },
  {
    "index": "F1098",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "思い出す為に、偽コードのマージのサブルーチンをここに示す。",
    "output": "So let me remind you, the pseudo code of the merge subroutine, here it is."
  },
  {
    "index": "F1099",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ではいくつのオペレーションが使われているか数えて行こう。",
    "output": "So let's just go and count up how many operations that are gonna get used."
  },
  {
    "index": "F1100",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "2つの初期化に1オペレーションずつかかるとしよう。",
    "output": "So let's say that I'm gonna charge us one operation for each of these two initializations."
  },
  {
    "index": "F1101",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ではこのforループの各繰り返しの中で幾つの命令が実行されるか?ここに一つ、A(i)とB(j)を比較して、比較の結果がどちらであれ、もう2つの命令、代入をする。",
    "output": "So let's call this two operations, just set i equal to one and j equal to one then we have this four loop executes a total number of end times so each of these in iterations of this four loop how many instructions get executed, well we have one here we have a comparison so we compare A(i) to B(j) and either way the comparison comes up we then do two more operations, we do an assignment."
  },
  {
    "index": "F1102",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここかここ。",
    "output": "Here or here."
  },
  {
    "index": "F1103",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして関連する方の変数をインクリメント。ここかここ。",
    "output": "And then we do an increment of the relevent variable either here or here."
  },
  {
    "index": "F1104",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だからこれらN回のforループの繰り返しで毎回4オペレーションする事になる。",
    "output": "So for each of these N iterations of the four loop we're gonna do four operations."
  },
  {
    "index": "F1105",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "全部まとめて、マージにかかる時間が分かる。",
    "output": "So putting it all together, what do we have is the running time for merge."
  },
  {
    "index": "F1106",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では上限を見てみよう。マージのサブルーチンの実行時間の条件は、M個の数の配列が与えられた時には、たかだか4M+2。",
    "output": "So the upshot is that the running time of the merge subroutine, given an array of M numbers, is at most four M plus two."
  },
  {
    "index": "F1107",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "コメントを少々。",
    "output": "So a couple of comments."
  },
  {
    "index": "F1108",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まず、文字を変えました。混乱しないように注意。",
    "output": "First of all, I've changed a letter on you so don't get confused."
  },
  {
    "index": "F1109",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "前のスライドでは入力の大きさをNとした。",
    "output": "In the previous slide we were thinking about an input size of N."
  },
  {
    "index": "F1110",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでは見ての通り名前を変えてMにした。",
    "output": "See I've changed the name of the variable to M."
  },
  {
    "index": "F1111",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "MergeSortについて考えるならそっちの方が便利だから。それはより小さなサブルーチンに再帰するからね。",
    "output": "That's gonna be convenient once we think about merge sort, which is recursing on smaller sub-problems."
  },
  {
    "index": "F1112",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし全く前と同じ事だから。",
    "output": "But it's exactly the same thing and, and whatever."
  },
  {
    "index": "F1113",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だからM要素の配列はせいぜい4M+2行のコードでやる。",
    "output": "So an array of M entries does as most four M plus two. Lines of code."
  },
  {
    "index": "F1114",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "2つ目、前のスライドで正確に、どうコードの行数を数えたかにはある程度の曖昧さがある。",
    "output": "The second thing is, there's some ambiguity in exactly how we counted lines of code on the previous slide."
  },
  {
    "index": "F1115",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "たとえばループの繰り返しは一つじゃなくて2つのオペレーションと数えるべきだ、と言いたいかもしれない。",
    "output": "So maybe you might argue that, you know, really, each loop iteration should count as two operations, not just one.'Cause you don't just have to increment K, but you also have to compare it to the, upper bound of N."
  },
  {
    "index": "F1116",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "何故ならkをインクリメントするだけじゃなくて、Nという上限と比較しないといかないから。",
    "output": "Would have been 5M+2 instead of 4M+2. So it turns out these small differences in how you count up."
  },
  {
    "index": "F1117",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これらの、どう実行されるコードを数えるかによる小さな違いは大して問題にならない、というのがすぐに分かる。",
    "output": "The number of lines of code executed are not gonna matter, and we'll see why shortly."
  },
  {
    "index": "F1118",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここではとりあえず納得しといてくれ。マージには4M+2命令かかる、ちょうどM要素の配列に実行するのに。",
    "output": "So, amongst friends, let's just agree, let's call it 4M plus two operations from merge, to execute on array on exactly M entries."
  },
  {
    "index": "F1119",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここで諸兄の親愛の想いをもうちょっと乱用して、正しいんだかひどかやる気の無い不等式を適用しよう。",
    "output": "So, let me abuse our friendship now a little bit further with an, an inequality which is true, but extremely sloppy."
  },
  {
    "index": "F1120",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "でも我々の将来の生活がこれで楽になる、と約束する。",
    "output": "But I promise it'll make our lives just easier in some future calculations."
  },
  {
    "index": "F1121",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "何故ならMは少なくとも1だから、認めざるをえなかろう。",
    "output": "Because m is at least one. Okay, you have to admit it's true, 6MO is at least 4M plus two."
  },
  {
    "index": "F1122",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これらの数はちっとも大きなMと近く無い。でも先に進む。",
    "output": "It's very sloppy, these numbers are not anything closer to each other for M large but, let's just go ahead and be sloppy in the interest of future simplicity."
  },
  {
    "index": "F1123",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "オーケー。",
    "output": "Okay."
  },
  {
    "index": "F1124",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "マージのサブルーチンが実行し終わるのに必要なコード行の総数なんて物には。",
    "output": "Now I don't expect anyone to be impressed with this rather crude upper bound, the number of lines of code that the merge subroutine needs to finish, to execute."
  },
  {
    "index": "F1125",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "キーとなる質問を思い出すと、入力の配列をソートし終えるのに、マージソートは何行のコードが必要なのか、だ。このサブルーチンだけのじゃない。",
    "output": "The key question you recall was how many lines of code does merge sort require to correctly sort the input array, not just this subroutine."
  },
  {
    "index": "F1126",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実際、MergeSortの分析はもっと怖い感じ。何故ならこの再帰バージョンの自分自身を生み出し続けるから。",
    "output": "And in fact, analyzing Merge Sort seems a lot more intimidating, because if it keeps spawning off these recursive versions of itself."
  },
  {
    "index": "F1127",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "再帰の総数、分析しなくてはならない全ての事の総数は、再帰のいろいろなレベルを考えると吹き上がってしまうから。",
    "output": "So the number of recursive calls, the number of things we have to analyze, is blowing up exponentially as we think about various levels of the recursion."
  },
  {
    "index": "F1128",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今、一つの我々に有利な事としては、再帰呼び出しをする都度、それを呼んでる所よりも入力はかなり小さくなってる、という事。",
    "output": "Now, if there's one thing we have going for us, it's that every time we make a recursive call."
  },
  {
    "index": "F1129",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "入力の配列はたった半分になってる。",
    "output": "It's on a quite a bit smaller input then what we started with, it's on an array only half the size of the input array."
  },
  {
    "index": "F1130",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だからある種の緊張関係がある。",
    "output": "So there's some kind of tension between on the one hand explosion of sub problems, a proliferation of sub problems and the fact that successive subproblems only have to solve smaller and smaller subproblems."
  },
  {
    "index": "F1131",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "一方ではサブの問題が発散、増殖していて、後続のサブ問題はどんどんより小さなサブ問題だけを解けば良くなる。",
    "output": "And resolute resolving these two forces is what's going to drive our analysis of Merge Short."
  },
  {
    "index": "F1132",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これらの2つの力に断固として立ち向かうのが、我らのMergeSortの分析を進める。",
    "output": "So, the good news is, is I'll be able to show you a complete analysis of exactly how many lines of code Merge Sort takes."
  },
  {
    "index": "F1133",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "いいニュースは、MergeSortが正確に何行かかるか、という完全な分析を私はお見せ出来る、という事。",
    "output": "And I'll be able to give you, and, in fact, a very precise upper bound."
  },
  {
    "index": "F1134",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そしてとても詳細な上限をあなたにお届け出来る。ここに、このレクチャーの残り使って証明する主張(クレーム)がある。",
    "output": "And so here's gonna be the claim that we're gonna prove in the remainder of this lecture."
  },
  {
    "index": "F1135",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "その主張とは、MergeSortは決して6N掛けるlog2底のNに追加で6Nのオペレーション以上はかからない、N要素の配列をソートするのに。",
    "output": "So the claim is that Merge Short never needs than more than six times N."
  },
  {
    "index": "F1136",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このマージは最大でもその程度の行数のコードしかかからないという知識の元で。",
    "output": "Times the logarithm of N log base two if you're keeping track plus an extra six N operations to correctly sort an input array of N numbers, okay so lets discuss for a second is this good is this a win, knowing that this is an upper bound of the number of lines of code the merger takes well yes it is and it shows the benefits of the divide and conquer paradigm."
  },
  {
    "index": "F1137",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "軽く議論したよりシンプルなソート、挿入ソートとか、選択ソートとかバブルソートとか、そこでは私はそれらのパフォーマンスは入力サイズの二次関数で支配されている、と主張したのを思い出してくれ。",
    "output": "In the simpler sorting methods that we briefly discussed like insertion sort, selection sort, and bubble sort, I claimed that their performance was governed by the quadratic function of the input size."
  },
  {
    "index": "F1138",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまりそれらは定数掛ける入力サイズの二乗のオペレーションが長さNの入力配列をソートするのにかかる。",
    "output": "That is they need a constant times in the squared number of operations to sort an input array of length N."
  },
  {
    "index": "F1139",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "一方MergeSortはせいぜい定数掛けるN掛けるlogN程度。Nの二乗じゃなくてNlogN行のコードで入力の配列を正しくソート出来る。",
    "output": "Merge sort by contrast needs at most a constant times N times log N, not N squared but N times log N lines of code to correctly sort an input array."
  },
  {
    "index": "F1140",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "どのくらい勝ちかを感覚でつかむ為、さびついてるか何らかの理由で対数に恐れて暮らしている人の為、対数とは一体どんな物だったかを思い出させよう。",
    "output": "So to get a feel for what kind of win this is let me just remind you for those of you who are rusty, or for whatever reason have lived in fear of a logarithm, just exactly what the logarithm is."
  },
  {
    "index": "F1141",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "対数の考え方はこうだ。",
    "output": "So. The way to think about the logarithm is as follows."
  },
  {
    "index": "F1142",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "X軸があるとする。",
    "output": "So you have the X axis, where you have N, which is going from one up to infinity."
  },
  {
    "index": "F1143",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そしてNがあるとして、1から無限大までいくとする。",
    "output": "And for comparison let's think about just the identity function, okay?"
  },
  {
    "index": "F1144",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "比較の為、アイデンティティ関数を考える、つまりF(n)=n。",
    "output": "So, the function which is just. F(n)=n."
  },
  {
    "index": "F1145",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "で、これを対数と比較する。",
    "output": "Okay, and let's contrast this with a logarithm. So what is the logorithm?"
  },
  {
    "index": "F1146",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "logN、つまりlog2底のNは、Nを電卓に打って、割る2を打つ。",
    "output": "So the log of n, log base 2 of n is, you type the number N into your calculator, okay? Then you hit divide by two."
  },
  {
    "index": "F1147",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そしてその2で割るのを繰り返し、何回2で割ったかを数えるその数字が1になるまで。",
    "output": "And then you keep repeating dividing by two and you count how many times you divide by two until you get a number that drops below one okay."
  },
  {
    "index": "F1148",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もし32なら5回割ると1になる。",
    "output": "So if you plug in 32 you got to divide five times by two to get down to one."
  },
  {
    "index": "F1149",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もし1024なら10回割らないと1にならない。",
    "output": "You put in 1024 you have to divide by two, ten times till you get down to one."
  },
  {
    "index": "F1150",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり2を底とした1024の対数は10となるいいかな、ここで肝心なのは、約1000の対数が10といったあたりで、入力に対して対数はとてもとても小さいってことだなので図に描くと対数はこんな感じになる曲線はNが大きくなるにつれ、急速に水平になる。",
    "output": "So log base two of 1024 is ten and so on, okay. So the point is you already see this if a log of a 1000 roughly is something like ten then the logarithm is much, much smaller than the input."
  },
  {
    "index": "F1151",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それがF(n)がlog2底のnって事。",
    "output": "So F(n) being log base 2 of n."
  },
  {
    "index": "F1152",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "家で、今やった事やもうちょっと詳細にコンピュータやグラフつき電卓でやってみる事を勧める。",
    "output": "And I encourage you to do this, perhaps a little bit more precisely on the computer or a graphing calculator, at home."
  },
  {
    "index": "F1153",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "とにかく、logはアイデンティティ関数よりずっとずっと遅く進む。",
    "output": "But log is running much, much, much slower than the identity function."
  },
  {
    "index": "F1154",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "結果として、NlogNと比例した進み方のソートアルゴリズムはずっと速い。特にNが大きくなると。",
    "output": "And as a result, sorting algorithm which runs in time proportional to n times log n is much, much faster, especially as n grows large, than a sorting algorithm with a running time that's a constant times n squared."
  },
  {
    "index": "F1155",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このビデオでは、ただの二分探索は既にお話しので、次のお話に進みたいと思います。それはバランスされた二分木探索です。",
    "output": "So, in this video, we'll graduate beyond the domain of just vanilla binary search trees, like we've been talking about before, and we'll start talking about balanced binary search trees."
  },
  {
    "index": "F1156",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これらがリアルタイム性を行たい操作に保証したい時にあなたが実際に必要とする探索木です。",
    "output": "These are the search trees you'd really want to use when you want to have real time guarantees on your operation time."
  },
  {
    "index": "F1157",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それは高さが対数的であることが保証されているということです。つまり、二分探索木において私たちが学び、愛した全ての操作について保持するキーの数に対して対数的に処理されるということです。",
    "output": "Cuz they're search trees which are guaranteed to stay balanced, which means the height is guaranteed to stay logarithmic, which means all of the operations search trees support that we know and love, will also be a logarithmic in the number of keys that they're storing."
  },
  {
    "index": "F1158",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "じゃあ、簡単に振り返りましょう。",
    "output": "So, let's just quickly recap."
  },
  {
    "index": "F1159",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ツリー構造の基本的な性質ってなんだったでしょうか?",
    "output": "What is the basic structure tree property?"
  },
  {
    "index": "F1160",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "探索木の全てのノードについて、もし左にいくとしたら、その先のツリーのデータには元のデータよりも小さいものしかありません。右に行けば、大きなものしかありません。",
    "output": "It should be the case that at every single node of your search tree, if you go to the left, you'll only see keys that are smaller than where you started and if you go to the right you only see keys that are bigger than where you started."
  },
  {
    "index": "F1161",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "また本当に大事なポイントは、あるキーの集合があるときそのキーについての正当な探索木はたくさんあることです。",
    "output": "And a really important observation, which is that, given a set of keys, there's going to be lot and lots of legitimate, valid, binary search trees with those keys."
  },
  {
    "index": "F1162",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この例として1,2,3,4,5というキーがあるとします。",
    "output": "So, we've been having these running examples where the keys one, two, three, four, five."
  },
  {
    "index": "F1163",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "一方では、ちゃんとバランスされた探索木があります。高さは2で、1から5までのキーがあります。",
    "output": "On the one hand, you can have a nice and balanced search tree that has height only two, with the keys one through five."
  },
  {
    "index": "F1164",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "一方では、無茶苦茶な連鎖を持ち、連結リストに退化してしまい、高さも要素数N-1と同じになってしまいます。",
    "output": "On the other hand, you can also have these crazy chains, basically devolved to link lists where the heights for, and elements could be as high as N - 1."
  },
  {
    "index": "F1165",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "一般論として、高さについて指数的な差が生まれます。",
    "output": "So, in general, you could have an exponential difference in the height."
  },
  {
    "index": "F1166",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "コストは最良の場合には対数的と小さいですが、最悪な場合は線形なほど大きくなります。",
    "output": "It can be as small, in the best case, as logarithmic and as big, in the worst case, as linear."
  },
  {
    "index": "F1167",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "というわけで、高さについては何にも心配しなくてもよくなるような性質を持つ探索木が望まれます。",
    "output": "So, this obviously motivates search trees that have the additional property that you never have to worry about their height."
  },
  {
    "index": "F1168",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そういう木はうまくバランスされることがわかっています。",
    "output": "You know they're going to be well balanced."
  },
  {
    "index": "F1169",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "高さがアルゴリズム的に決まることもわかります皆さんはもう、うんざりするような線形の高さになるのかと心配することもなくなります。",
    "output": "You're never worried about them having this really lousy linear height."
  },
  {
    "index": "F1170",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "繰り返しですが、高さが低いことがなぜそれほど重要なんでしょうか?",
    "output": "Remember, why it's so important to have a small height?"
  },
  {
    "index": "F1171",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "なぜなら探索木の操作の実行時間はすべて、木の高さに依存するからです。",
    "output": "It's because the running time of all of the operations of search trees depends on the height."
  },
  {
    "index": "F1172",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして、探索木についての一番大事なアイデアは皆さんがすでにお考えの通りのものです。つまり、高さは保持するものの数の対数よりは決して良くならないということです。",
    "output": "You want to do search, you want to insertions, you want to find predecessors or whatever, the height is going to be what governs the running time of all those properties."
  },
  {
    "index": "F1173",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "なぜなら、木は二分されるので、どのレベルでも倍にしかならず、保持しているすべての数に到達するには対数量が必要になるからです。",
    "output": "So, the high level idea behind balanced search trees is really exactly what you think, which is that, you know, because the height can't be any better than logarithmic in the number of things you're storing, that's because the trees are binary so the number of nodes can only double each level so you need a logarithmic number of levels to accommodate everything that you are storing."
  },
  {
    "index": "F1174",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さらに、対数的になったとしたら、どんな場合でも対数的に留まるということも仮定しましょう。挿入や削除をしてもです。",
    "output": "But it's got to be logarithmic, lets make sure it stays logarithmic all the time, even as we do insertions and deletions."
  },
  {
    "index": "F1175",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そうしたらすべて対数時間で行える豊かな操作群を利用できます。",
    "output": "If we can do that, then we get a very rich collection of supported operations all running in logarithmic time."
  },
  {
    "index": "F1176",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "同じように、保持されるキーの数に対して平衡探索木には物凄くたくさんの種類があります。",
    "output": "As usual, n denotes, the number of keys being stored in the tree. There are many, many, many different balanced search trees."
  },
  {
    "index": "F1177",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それらは、ほとんどの場合、それほど互いには大きくは違いません。",
    "output": "They're not super, most of them are not super different from each other."
  },
  {
    "index": "F1178",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでは、その中で一番有名な、赤黒木についてお話します。",
    "output": "I'm going to talk about one of the more popular ones which are called Red Black Trees."
  },
  {
    "index": "F1179",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それはAVL木です。赤黒木とそれほど大きな違いがあるわけではありませんが、満たす性質が少しことなります。",
    "output": "These were not the first balanced binary search tree data structures, that honor belongs to AVL trees, which again are not very different from red black trees, though the invariants are slightly different."
  },
  {
    "index": "F1180",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もう一つ知っておくとよいこととしては、スプレー木という面白いアイディアがSleatorとTarjanによって考え出されました。赤黒木やAVL木では、挿入や削除のときにしか変化しません。",
    "output": "Another thing you might want to look up and read about is a very cool data structure called splay trees, due to Sleator and Tarjan, These, unlike red black trees and AVL trees, which only are modified on insertions and deletions, which, if you think about it, is sort of what you'd expect."
  },
  {
    "index": "F1181",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "スプレー木では、自分自身を変更します。探索の場合でも、検索だけをしているときでもです。",
    "output": "Splay trees modify themselves, even when you're doing look ups, even when you're doing searches."
  },
  {
    "index": "F1182",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このため、自己調節木と呼ばれることもあります。",
    "output": "So, they're sometimes called self-adjusting trees for that reason."
  },
  {
    "index": "F1183",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それにとてもシンプルで、驚くような性質を保証します。",
    "output": "And it's super simple, but they still have kind of amazing guarantees."
  },
  {
    "index": "F1184",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "また最後には、二分木の枠組みを越えて、B木とB+木も見ておいたほうがよいでしょう。",
    "output": "And then finally, going beyond the, just the binary tree paradigm many of you might want to look up examples of B trees or also B+ trees."
  },
  {
    "index": "F1185",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでのアイディアは、あるノードについて唯一のキーではなく多くのキーを持ち、ノードからは持っているキーの数に応じて多数の枝が出ます。",
    "output": "Here what the idea is, in a given node you're going to have not just one key but many keys and from a node, you have multiple branches that you can take depending where you're searching for falls with respect to the multiple keys that are at that node."
  },
  {
    "index": "F1186",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "二分木の枠組みを超えたデータベースにおける動機はメモリの階層構造にうまくあった構造を持つことです。",
    "output": "The motivation in a database context for going beyond the binary paradigm, is to have a better match up with the memory hierarchy."
  },
  {
    "index": "F1187",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは非常に重要なことですが、この講義の範囲を越えます。",
    "output": "So, that's also very important, although a little bit out of the scope here."
  },
  {
    "index": "F1188",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり、ここでお話するのは赤黒木についてで、もっと学ぶ必要があり、学ぶべき場所がわかればここで得られた洞察の多くはほかの平衡木構造に置き換えて考えられるでしょう。",
    "output": "That said, what we discuss about red-black trees, much of the intuition will translate to all of these other balance tree data structures, if you ever find yourself in a position where you need to learn more about them."
  },
  {
    "index": "F1189",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "赤黒木はただの二分探索木と同じです。ただし、新しく幾つかの不変条件を維持しています。",
    "output": "So, red black trees are just the same as binary search trees, except they also always maintain a number of additional invariants."
  },
  {
    "index": "F1190",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このビデオではじめに説明するのは、どんな不変条件があるかということ、またどのようにしてその不変条件から、高さが対数的になることを保証するかです。",
    "output": "And so, what I'm going to focus on in this video is, first of all, what the invariants are, and then how the invariants guarantee that the height will be logarithmic."
  },
  {
    "index": "F1191",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "時間が許せば、どこかの時点で、補助的なビデオで核心となる赤黒木の実装がどのようにして、挿入や削除のもとでこうした不変条件を維持するのか説明するかもしれません。",
    "output": "Time permitting, at some point, there will be optional videos more about the guts, more about the implementations of red black trees namely how do you maintain these invariants under insertions and deletions."
  },
  {
    "index": "F1192",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この話はとても込み入っているので、オプショナルな資料にするほうがよいと思います。",
    "output": "That's quite a bit more complicated, so that's appropriate for, for optional material."
  },
  {
    "index": "F1193",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ただし、不変条件とはなにか、不変条件が高さの制御にどのような役割を持つかということは、あらゆるプログラマが知っておくべきことだと私は思います。",
    "output": "But understanding what the invariants are and what role they play in controlling the height is very accessible, and it's something I think every programmer should know."
  },
  {
    "index": "F1194",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では4つの不変条件を書き出します。そのうち重要なものは後半ふたつ、つまり3つめと4つめによります。",
    "output": "So, there, I'm going to write down four invariants and really, the bite comes from the second two, okay, from the third and the fourth invariant."
  },
  {
    "index": "F1195",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最初のものとして、各ノードに、キーに加えて余計に1ビットの情報を保存します。このビットによって、あるノードが赤か黒かを決めます。",
    "output": "So, the first one we're going to store one bit of information additionally at each node, beyond just the key and we're going call this bit as indicating whether it's a red or a black node."
  },
  {
    "index": "F1196",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "たぶん、なぜ赤と黒なのか、疑問に思うでしょう。",
    "output": "You might be wondering, you know, why red black?"
  },
  {
    "index": "F1197",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "いや、私も数年前、同じことを同僚のLeoGuibasに聞きました。",
    "output": "Well, I asked my colleague, Leo Guibas about that a few years ago."
  },
  {
    "index": "F1198",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "教えてくれたところによると、彼とSedgewick教授がその論文を書き上げたとき、論文誌では限られた印刷技術しか使うことができず、出版するには限られた種類の色しか使えませんでした。",
    "output": "And he told me that when he and Professor Sedgewick were writing up this article the journals were, just had access to a certain kind of new printing technology that allowed very limited color in the printed copies of the journals."
  },
  {
    "index": "F1199",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だから単にその色を使い、データ構造に赤黒木と名付け、論文でもちゃんと赤と黒の絵を使えたというわけです。",
    "output": "And so, they were eager to use it, and so they named the data structure red black, so they could have these nice red and black pictures in the journal article."
  },
  {
    "index": "F1200",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "残念ながらその後混乱があり、そうした印刷技術は結局使えませんでした。なので論文は彼らが思い描いていた通りには印刷されませんでしたが、名前は残ったというわけです。",
    "output": "Unfortunately, there was then some snafu, and at the end of the day, that technology wasn't actually available, so it wasn't actually printed the way they were envisioning it but the name has stuck."
  },
  {
    "index": "F1201",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これが、このデータ構造がどうしてこのような名前になったかという面白い理由です。",
    "output": "So, that's the rather idiosyncratic reason why these data structures got the name that they did, red black trees."
  },
  {
    "index": "F1202",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "次に二番目の不変条件ですが、探索木のルートノードは常に黒です。赤にはなりません。",
    "output": "So, secondly we're going to maintain the invariant that the roots of the search tree is always black, it can never be red."
  },
  {
    "index": "F1203",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では、表面的な不変条件がわかったところで、残りの2つの主要な条件について見てみましょう。",
    "output": "So, with the superficial pair of invariants out of the way, let's go to the two main ones."
  },
  {
    "index": "F1204",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まずはじめに、赤ノードが並ぶことはありません。つまり、赤ノードがツリーにあれば、その子ノードは必ず黒です。",
    "output": "By which, I mean, if you have a red node in the search tree, then its children must be black."
  },
  {
    "index": "F1205",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もうちょっと考えてみればおわかりでしょうが、つまり赤ノードがあれば、それは必ず親を持ち、また親は必ず黒ノードになります。",
    "output": "If you think about for a second, you realize this also implies that if a notice red, and it has a parent, then that parent has to be a black node."
  },
  {
    "index": "F1206",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そういう意味で、ツリーのどこででも赤ノードが並ぶことはありません。",
    "output": "So, in that sense, there are no two red nodes in a row anywhere in the tree."
  },
  {
    "index": "F1207",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最後の不変条件も厳しく、ルートノードから先端まで取ることのできるどんな経路を取っても正確に同じ数の黒ノードがなければいけません。",
    "output": "And the final invariant which is also rather severe is that every path you might take from a root to a null pointer, passes through exactly the same number of black nodes."
  },
  {
    "index": "F1208",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ルートからの経路という意味を明確にしましょう。考えるべきは失敗した探索ですよね?",
    "output": "So, to be clear on what I mean by a root null path, what you should think about is an unsuccessful search, right?"
  },
  {
    "index": "F1209",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "失敗した探索では、ルートからはじめて、大きいか小さいかに応じて右か左かに行きます。",
    "output": "So, what happens in an unsuccessful search, you start at the root depending on whether you need to go smaller or bigger, you go left or right respectably."
  },
  {
    "index": "F1210",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "右か左かにたどっていって、nullポインタに到達します。",
    "output": "You keep going left right as appropriate until eventually you hit a null pointer."
  },
  {
    "index": "F1211",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり皆さんに考えてみてほしいのは、ルートからはじめて、最後にはツリーの末端まで行き着く処理です。",
    "output": "So, I want you to think about the process that which you start at the root and then, eventually, fall off the end of the tree."
  },
  {
    "index": "F1212",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そうするなかで、ある数のノードを調べることになります。",
    "output": "In doing so, you traverse some number of nodes."
  },
  {
    "index": "F1213",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そのうち一部は黒ノードで、一部は赤ノードでしょう。",
    "output": "Some of those nodes will be black some of those nodes will be red."
  },
  {
    "index": "F1214",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして黒ノードの数を考えてみましょう。赤黒木の条件では、定義上、どんな経路をたどってルートからnullポインタまでたどっても、たどる黒ノードの数は全く同じになる、という条件を満たさないといけません。",
    "output": "And I want you to keep track of the number of black nodes and the constraints that a red black tree, by definition, must satisfy, is that no matter what path you take through the tree starting from the root terminating at a null pointer, the number of black nodes traversed, has to be exactly the same."
  },
  {
    "index": "F1215",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "経路によって変わってはいけません。同じルートからは完全に同じです。",
    "output": "It cannot depend on the path, it has to be exactly the same on every single root null path."
  },
  {
    "index": "F1216",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "いくつか例を見てみましょう。",
    "output": "Let's move on to some examples."
  },
  {
    "index": "F1217",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "こういうことです。",
    "output": "So, here's a claim."
  },
  {
    "index": "F1218",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "赤黒木がうまくバランスしなければならないという考え方を示します。",
    "output": "And this is meant to, kind of, whet your appetite for the idea that red black trees must be pretty balanced."
  },
  {
    "index": "F1219",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "高さは、基本的には対数的でなければなりません。",
    "output": "They have to have height, basically logarithmic."
  },
  {
    "index": "F1220",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "考えてみましょう。一番バランスしてないツリーは何でしょう?",
    "output": "So, remember, what's the most unbalanced search tree?"
  },
  {
    "index": "F1221",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり、言いたいのは3ノードのチェインであっても赤黒木ではないということです。",
    "output": "So, the claim is, even a chain with three nodes can not be a red black tree."
  },
  {
    "index": "F1222",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "その証明は?",
    "output": "So, what's the proof?"
  },
  {
    "index": "F1223",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "仮に、キーを1,2,3とします。",
    "output": "So, maybe, with the key values one, two and three."
  },
  {
    "index": "F1224",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "すると問題は、この3つのノードを赤か黒に色をつけ4つの不変条件を満たすような方法はあるだろうか、ということです。",
    "output": "So, the question that we're asking is, is there a way to color the node, these three nodes, red and black so that all four of the invariants are satisfied."
  },
  {
    "index": "F1225",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ノードを赤か黒にわけます。",
    "output": "So, we need to color each red or black."
  },
  {
    "index": "F1226",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "2と3の色分けについては、4通りの可能性があります。",
    "output": "So, we have four possibilities for how to use the color two and three."
  },
  {
    "index": "F1227",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ですが条件3により、3つの可能性しかありません。",
    "output": "But really, because of the third invariant, we only have three possibilities."
  },
  {
    "index": "F1228",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "2と3をどちらも赤にしてはいけません。",
    "output": "We can't color two and three both red, cuz then we'd have two reds in a row."
  },
  {
    "index": "F1229",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そこで2が赤で3が黒、2が黒で3が赤、両方とも黒、という可能性があります。",
    "output": "So, we can either make two red, three black, two black, three red, or both two and three black."
  },
  {
    "index": "F1230",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このどれも同じです。",
    "output": "And all of the cases are the same."
  },
  {
    "index": "F1231",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "一例として、2が赤で3が黒としましょう。",
    "output": "Just to give one example, suppose that we colored the node two, red, and one and three are black."
  },
  {
    "index": "F1232",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでは条件4が破られています。実は条件4は2と3をどのように色分けしても破られます。",
    "output": "The claim is invariant four has been broken and invariant four is going to be broken no matter how we try to color two and three red and black."
  },
  {
    "index": "F1233",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "どんな失敗する探索でも、全く同じ数の黒ノードを通るということです。",
    "output": "It says, really on any unsuccessful search, you pass through the same number of black nodes."
  },
  {
    "index": "F1234",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "失敗する探索のひとつは、たとえば0です。",
    "output": "And so, one unsuccessful search would be, you search for zero."
  },
  {
    "index": "F1235",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "0を探索すると、ルートを見て左に行き、nullポインタに到達します。",
    "output": "And if you search for a zero, you go to the root, you immediately go left to hit a null pointer."
  },
  {
    "index": "F1236",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり1つの黒ノードに到達します。",
    "output": "So, you see exactly one black node."
  },
  {
    "index": "F1237",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "一方、4を探索したとしましょう。ルートからはじめて右へ行き、2に行き、さらに右へ、3に行き、さらに右へ、そしてnullポインタに到達します。",
    "output": "On the other hand, suppose you searched for four, then you'd start at the root, and you'd go right, and you go to two, you'd go right, and you go to three, you'd go right again, and only then will you get a null pointer."
  },
  {
    "index": "F1238",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この場合、失敗した探索で2つの黒ノードにぶつかります。1と3です。",
    "output": "And on that, unsuccessful search, you'd encounter two black nodes, both the one and the three."
  },
  {
    "index": "F1239",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり不変条件4が破られています。したがって、これは赤黒木ではありません。",
    "output": "So, it's a violation of the fourth invariant, therefore, this would not be a red black tree."
  },
  {
    "index": "F1240",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "どのように2と3を塗り分けてもどれかの不変条件が破られるという確認は自分で確認してみてください。",
    "output": "I'll leave that for you to check, that no matter how you try to code two and three red or black, you're going to break one of the invariants."
  },
  {
    "index": "F1241",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "少なくとも1つが赤なら、条件4は破られます。",
    "output": "If they're both red, you'd break the third invariant. If at most one is red, you'd break the fourth invariant."
  },
  {
    "index": "F1242",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまりこれは赤黒木ではないという例です。",
    "output": "So, that's a non-example of a red-black tree."
  },
  {
    "index": "F1243",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では赤黒木の例も見てみましょう。",
    "output": "So, let's look at an example of a red-black tree."
  },
  {
    "index": "F1244",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ある探索木が、実際にノードを赤と黒に塗り分け、全ての4つの不変条件が満たされるようなものです。",
    "output": "One, a search tree where you can actually color the nodes red or black so that all four invariants are maintained."
  },
  {
    "index": "F1245",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "赤黒木のとても簡単な例は、完全にバランスした木です。",
    "output": "So, one search tree which is very easy to make red black is a perfectly balanced one."
  },
  {
    "index": "F1246",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "たとえば、このように3つのノードがあって、3,5,7のキーがあり5がルートになっているとします。",
    "output": "So, for example, let's consider this three nodes search tree has the keys three, five, and seven and let's suppose the five is the root."
  },
  {
    "index": "F1247",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "両側に子ノードがひとつずつあります。3と7です。",
    "output": "So, it has one child on each side, the three and the seven."
  },
  {
    "index": "F1248",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは赤黒木でしょうか?問題は何だったでしょうか?",
    "output": "So, can this be made a red black tree?"
  },
  {
    "index": "F1249",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この3つのノードを赤か黒に塗り分けて、4つの不変条件を全て満たすような方法はあるか?ということです。",
    "output": "It's asking can we color theses three nodes some combination of red and black so that all four of the invariants are satisfied?"
  },
  {
    "index": "F1250",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ちょっと考えてみると、そう、たしかにこのノードを塗り分けて条件を満たすことができることがわかるでしょう。",
    "output": "If you think about it a little bit, you realize, yeah, you can definitely color these nodes red or black to make and satisfy for the invariants."
  },
  {
    "index": "F1251",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "とくに、全部のノードを黒だとしましょう。",
    "output": "In particular, suppose we color all three of the nodes, black."
  },
  {
    "index": "F1252",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "すべてのノードには色がついています。条件2も満たされます。",
    "output": "We've satisfied variant number one, we've colored all the nodes."
  },
  {
    "index": "F1253",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ルートノードは黒です。条件3も満たされます。",
    "output": "We've satisfied variant number two, and particularly, the root is black."
  },
  {
    "index": "F1254",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして、考えてみると、条件4も満たされます。なぜなら、ツリーは完全にバランスしているからです。",
    "output": "And, if you think about it, we've satisfied invariant four because this tree is perfectly balanced."
  },
  {
    "index": "F1255",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "どういう探索で失敗しても、必ず2つの黒ノードを通過します。",
    "output": "No matter what you unsuccessfully search for, you're going to encounter two black nodes."
  },
  {
    "index": "F1256",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "たとえば1を検索すると、3と5を通ります。",
    "output": "If you search for, say, one, you're going to encounter three and five."
  },
  {
    "index": "F1257",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "6を検索すれば、5と7を通ります。",
    "output": "If you search for, say, six, you're going to encounter five and seven."
  },
  {
    "index": "F1258",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり、ルートからのあらゆる経路は正確に2つの黒ノードを持ち、第4の不変条件も満たされます。",
    "output": "So, all root null paths have exactly two black nodes and variant number four is also satisfied."
  },
  {
    "index": "F1259",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "素晴らしい。",
    "output": "So, that's great."
  },
  {
    "index": "F1260",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ですがもちろん、二分探索木のポイントは、動的にしたいということです。",
    "output": "But, of course, the whole point of having a binary search tree data structure is you want to be dynamic."
  },
  {
    "index": "F1261",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "挿入や削除に対応できないといけません。",
    "output": "You want to accommodate insertions and deletions."
  },
  {
    "index": "F1262",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "挿入や削除のたびに、赤黒木に新しいノードができます。",
    "output": "Every time you have an insertion or a deletion into a red black tree, you get a new node."
  },
  {
    "index": "F1263",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "たとえば挿入の場合、新しいノードができて色を決めねばなりません。",
    "output": "Let's say, an insertion, you get a new node, you have to color it something."
  },
  {
    "index": "F1264",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "すると突然、4つの不変条件のどれも破られないか心配になってきますね。",
    "output": "And now, all of a sudden, you got to worry about breaking one of these four invariants."
  },
  {
    "index": "F1265",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では、あまり大変なことをしなくても挿入できるような、簡単な場合を見てみます。",
    "output": "So, let me just show you some easy cases where you can accommodate insertions without too much work."
  },
  {
    "index": "F1266",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "またの機会に、オプショナルなビデオでツリーの回転によって、もっと根本的な探索木の再構築を行い、4つの不変条件を維持してバランスした状態を保つための解説をします。",
    "output": "Time permitting we will include some optional videos with the notion of rotations which do more fundamental restructuring of search trees so that they can maintain the four invariants, and stay nearly perfectly balanced."
  },
  {
    "index": "F1267",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では、ここに赤黒木があって、全部のノードが黒だとします。そして例えば6を挿入します。",
    "output": "So, if we have this red black tree where everything's black, and we insert, say, six, that's going to get inserted down here."
  },
  {
    "index": "F1268",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでもし、これを黒にすると、もう赤黒木ではありません。",
    "output": "Now, if we try to color it black, it's no longer going to be a red black tree."
  },
  {
    "index": "F1269",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "なぜなら、たとえば5.5を探索すると、3つの黒ノードに遭遇することになるからです。ここで1を探索すると、2つの黒ノードにしか遭遇しません。",
    "output": "And that's because, if we do an unsuccessful search now for, say, 5.5, we're going to encounter three black nodes, where if we do an unsuccessful search for one, we only encounter two black nodes."
  },
  {
    "index": "F1270",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ですが6を黒にするかわりに、赤にするとうまくいきます。",
    "output": "But the way we can fix it is instead of coloring the six black, we color it red."
  },
  {
    "index": "F1271",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この場合、6は条件4からは無関係になります。",
    "output": "And now, this six is basically invisible to invariant number four."
  },
  {
    "index": "F1272",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "元のツリーではどのパスでも2つの黒ノードがあるのでした。6が来る前は。",
    "output": "So, because you have two black nodes in all roots in all paths before, before the six was there, that's still true now that you have this red six."
  },
  {
    "index": "F1273",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして、6が赤ならこれは変わりません。つまり、6を挿入しても赤くすれば4つの条件は全て満たされます。",
    "output": "So, all four invariants are satisfied once you insert the six and color it red."
  },
  {
    "index": "F1274",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "次に、たとえば8を挿入しましょう。全く同じやり方が使えます。",
    "output": "If we then insert, say, an eight, we can pull exactly the same trick, we can call it an eight red."
  },
  {
    "index": "F1275",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "同じく、このノードは条件4には参加しません。なので破られません。",
    "output": "Again, it doesn't participate in invariant four at all so we haven't broken it."
  },
  {
    "index": "F1276",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さらに言えば、2つの赤ノードは並んでいないので、条件3も破られていません。",
    "output": "Moreover, we still don't have two reds in a row, so we haven't broken invariant number three either."
  },
  {
    "index": "F1277",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "というわけで、これも赤黒木です。",
    "output": "So, this is yet another red black tree."
  },
  {
    "index": "F1278",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実は、この赤黒木を4つの条件を満たしつつ塗り分けるのはこれだけではありません。",
    "output": "In fact, this is not the unique way to color the nodes of this search tree, so that it satisfies all four of the invariants."
  },
  {
    "index": "F1279",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "たとえば、6と8を黒に変更します。ただ同時に、7を赤に塗り分けます。",
    "output": "If we, instead, recolor six and eight black, but at the same time, recolor the node seven, red, we're also golden."
  },
  {
    "index": "F1280",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "明らかに最初の3つの不変条件は満たされます。",
    "output": "Clearly, the first three invariants are all satisfied."
  },
  {
    "index": "F1281",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "また、6と8の赤を合併して上に押し上げ、7を赤にすることで、黒ノードの数は、どんな経路でもかわりません。",
    "output": "But also, in pushing the red upward, consolidating the red at six and eight, and putting it at seven instead, we haven't changed the number of black nodes on any given path."
  },
  {
    "index": "F1282",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "6を通ったパスは7を通りますし、8を通った経路も7を通ります。だから、これまでと同じく、正確に同じ数の赤と黒のノードが、どちらの経路でも存在します。",
    "output": "Any black, any path that previously went through six, went through seven, anything that went through eight, went through seven so there's exactly the same number of red and black nodes on each such path as there was before."
  },
  {
    "index": "F1283",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり、全ての経路が同じ数の黒ノードを持ち、条件4は満たされます。",
    "output": "So, all paths still have equal number of black nodes and invariant four remains satisfied."
  },
  {
    "index": "F1284",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでは、ごく単純な例だけをお見せしています。挿入の際、赤黒の性質を守るために大したことは必要ありません。",
    "output": "As I said, I've shown you here only simple examples, where you don't have to do much work on an insertion to retain the red black properties."
  },
  {
    "index": "F1285",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "一般に、もっとたくさんのものを挿入したり削除すると、4つの不変条件を維持するために大変なことをしなければいけなくなります。",
    "output": "In general, if you keep inserting more and more stuff and certainly if you do the deletions, you have to work much harder to maintain those four invariants."
  },
  {
    "index": "F1286",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "時間が許せば、オプショナルなビデオでそのさわりを説明します。",
    "output": "Time permitting, we'll cover just a taste of it in some optional videos."
  },
  {
    "index": "F1287",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ところで、赤黒木に足された一見適当な条件の要点は何でしょうか?",
    "output": "So, what's the point of these seemingly arbitrary four invariants of a red black tree?"
  },
  {
    "index": "F1288",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実は4つの不変条件を全て満たすようにすると、高さが小さくなるというのが要点です。",
    "output": "Well, the whole point is that if you satisfy these four invariants in your search tree, then your height is going to be small."
  },
  {
    "index": "F1289",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして高さが小さくなるので、全ての操作が速くなるのです。",
    "output": "And because your height's going to be small, all your operations are going to be fast."
  },
  {
    "index": "F1290",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では、4つの不変条件を満たすと、高さがとても小さくなることを証明します。",
    "output": "So, let me give you a proof that if a search tree satisfies the four invariants, then it has super small height."
  },
  {
    "index": "F1291",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実は、考えうる最小値の倍ほぼlog2(N)の2倍を超えません。2(N+1)となります。",
    "output": "In fact, no more than double the absolute minimum that we conceivably have, almost two times log base two of N."
  },
  {
    "index": "F1292",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "証明しましょう。この証明についてはっきりしているのは、不変条件3と4の果たす役割です。",
    "output": "And what's clear about this proof is it's very obvious the role played by this invariants three and four."
  },
  {
    "index": "F1293",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "本質的に、この不変条件が保証するのは、赤黒木は完全平衡木にある係数の増加を加えたようになります。",
    "output": "Essentially, what the invariants guarantee is that, a red black tree has to look like a perfectly balanced tree with at most a sort of factor two inflation."
  },
  {
    "index": "F1294",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "どういう意味か見てみましょう。",
    "output": "So, let's see exactly what I mean."
  },
  {
    "index": "F1295",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "とある考え方から始めます。",
    "output": "So, let's begin with an observation."
  },
  {
    "index": "F1296",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでは、赤黒木には何もしません。色のことはいったん忘れてください。",
    "output": "And this, this has nothing to do with red black trees."
  },
  {
    "index": "F1297",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "二分木の構造だけを考えます。",
    "output": "Forget about the colors for a moment, and just think about the structure of binary trees."
  },
  {
    "index": "F1298",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして、ツリーの中のルートノードからの経路の長さに下限があるとします。",
    "output": "And let's suppose we have a lower bound on how long root null paths are in the tree."
  },
  {
    "index": "F1299",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これをkとしましょう。kを、たとえば10とでも考えてみてください。",
    "output": "So, for some parameter k, and go ahead and think of k as, like, ten if you want."
  },
  {
    "index": "F1300",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "あるツリーがあってルートからはじめ、左右のどのように経路をたどってnullポインタまで到達しても、どう選んでも、少なくともk個のノードはたどることになります。",
    "output": "Suppose we have a tree where if you start from the root, and no matter how it is you navigate left and right, child pointers until you terminate in a null pointer."
  },
  {
    "index": "F1301",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もしこの仮定が満たされるなら、考えてみてください、このツリーの上位は完全に埋まっています。",
    "output": "If that hypothesis is satisfied, then if you think about it, the top of this tree has to be totally filled in."
  },
  {
    "index": "F1302",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このツリーの上位は完全平衡木になっています。高さk-1の二分木です。",
    "output": "So, the top of this tree has to include a perfectly balanced search tree, binary tree of depth k - 1."
  },
  {
    "index": "F1303",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では、k=3となるようなツリーを描いてみます。",
    "output": "So, let me draw a picture here of the case of k = three."
  },
  {
    "index": "F1304",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ルートからnullポインタまでどのように移動しても、必ず最低3つのノードを見るということです。",
    "output": "So, if no matter how you go from the root to a null pointer, you have to see at least three nodes along the way."
  },
  {
    "index": "F1305",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "孫ノードは全部で4つ。この考え方を、背理法で証明します。",
    "output": "That means the top three levels of this tree have to be full."
  },
  {
    "index": "F1306",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実際、上位k階層のノードのどれかが欠けていたとすると、k個のノードをたどる前にnullポインタに到達する経路が存在します。",
    "output": "So, you have to have the root."
  },
  {
    "index": "F1307",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでのポイントは、この下限から、ツリー内のノード数の下限が、ルートからnullまでの経路の長さの関数として与えられるということです。",
    "output": "The proof of this observation is by contradiction. If, in fact, you were missing some nodes in any of these top k levels."
  },
  {
    "index": "F1308",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ツリーの大きさNは深さk-1の完全平衡木のノード数、つまり2のk乗-1を含みます。",
    "output": "So, what's the point is, the point is this gives us a lower bound on the population of a search tree as a function of the lengths of its root null paths."
  },
  {
    "index": "F1309",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "たとえばk=3なら2の3乗-1の7です。",
    "output": "So, the size N of the tree must include at least the number of nodes in a perfectly balanced tree of depth k - 1 which is 2^k - 1, So, for example, when k = 3, it's 2^3 (two cubed) - 1, or 7 that's just a basic fact about trees, nothing about red black trees."
  },
  {
    "index": "F1310",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ではこれと赤黒木の不変条件を組み合わせて、なぜ赤黒木が低くなるか考えましょう。",
    "output": "So, let's now combine that with a red black tree invariant to see why red black trees have to have small height."
  },
  {
    "index": "F1311",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "また、前のスライドの結論を振り返りましょう。",
    "output": "So again, to recap where we got to on the previous slide."
  },
  {
    "index": "F1312",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ツリーのノード数Nは、少なくとも2のk乗-1はあります。ここでkは、ルートからnullまでの経路の一番小さい値です。",
    "output": "The size N, the number of nodes in a tree, is at least 2^k - 1, where k is the fewest number of nodes you will ever see on a root null path."
  },
  {
    "index": "F1313",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このことを少し書き換えて、kに対してNに制約を与えるのではなく、Nからkの上限を決めましょう。",
    "output": "So, let's rewrite this a little bit and let's actually say, instead of having a lower bound on N in terms of k, let's have an upper bound on k in terms of N."
  },
  {
    "index": "F1314",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり、ルートからのあらゆる経路の長さの最小値は、log2(N+1)より大きくなることはありません。",
    "output": "So, the length of every root null path, the minimum length of every root null path is bounded above by log base two of quantity N + 1."
  },
  {
    "index": "F1315",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは単に両辺に1を足して2を底とした対数を取るだけです。",
    "output": "This is just adding one to both sides and taking the logarithm base two."
  },
  {
    "index": "F1316",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では、これの何がいいんでしょうか?",
    "output": "So, what does this buy us?"
  },
  {
    "index": "F1317",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では赤黒木について考えましょう。",
    "output": "Well, now, let's start thinking about red black trees."
  },
  {
    "index": "F1318",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ノード数Nの赤黒木です。",
    "output": "So now, red black tree with N nodes."
  },
  {
    "index": "F1319",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "何が言えるでしょうか?",
    "output": "What does this say?"
  },
  {
    "index": "F1320",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "赤黒木と関係なくあるルートからnullまでの経路のノードの数は、たかだかlog2(N+1)です。最善の場合で。",
    "output": "This says that the number of nodes, forget about red or black, just the number of nodes on some root null path has to be the most log base two of N + 1."
  },
  {
    "index": "F1321",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "いくらかは赤ノードですが、最大の場合では、全てが黒ノードです。",
    "output": "Maybe some of them are red, but in the, in, the maximum case, all of them are black."
  },
  {
    "index": "F1322",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり、Nノードの赤黒木について次のことが言えます。ルート-null経路には、最大でもlog2(N+1)の黒ノードしか含まれない。",
    "output": "So, we can write in a red black tree with N nodes, there is a root null path with at most log base two of N + 1, black nodes."
  },
  {
    "index": "F1323",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは、証明したことよりは弱い主張です。",
    "output": "This is an even weaker statement than what we just proved."
  },
  {
    "index": "F1324",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "証明したのは、log2(N+1)ノードを必ず持つということですから。",
    "output": "We proved that it have some, somehow must have at most log based two, n + 1 total nodes."
  },
  {
    "index": "F1325",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "黒ノードを持つことがわかりました。",
    "output": "So, certainly, that path has the most log base two of N + 1 black nodes."
  },
  {
    "index": "F1326",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では2つの不変条件から2つのノックアウトパンチを繰り出しましょう。",
    "output": "Now, let's, now let's apply the two knockout punches of our two invariants."
  },
  {
    "index": "F1327",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そもそも、4つの不変条件は何を言っていたでしょうか?",
    "output": "Alright, so fundamentally, what is the fourth invariant telling us?"
  },
  {
    "index": "F1328",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "言っていたのは赤黒木の経路を見た時、ルートからはじめて失敗した探索を考えました。nullポインタまでたどります。",
    "output": "It's telling us that if we look at a path in our red black tree, we go from the root, we think about, let's say, that's an unsuccessful search, we go down to a null pointer."
  },
  {
    "index": "F1329",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして、赤ノードが見えないとして、全然数えないとすると、経路には対数的な数のノードしかないということです。",
    "output": "It says, if we think of the red nodes as invisible, if we don't count them in our tally, then we're only going to see log, basically a logarithmic number of nodes."
  },
  {
    "index": "F1330",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もちろん、赤黒木の高さについて考えるときは、すべてのノードを考えます。赤ノードと黒ノードを。",
    "output": "But when we care about the height of the red black tree, of course, we care about all of the nodes, the red nodes and the black nodes."
  },
  {
    "index": "F1331",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これまでのところ、黒ノードしか考えないと、うまくいって、log2(N+1)個のノードだけしかないということです。",
    "output": "So, so far we know, that if we only count black nodes then we're good, We only have log base two of N + 1 nodes that we need to count. So, here's where the third invariant comes in."
  },
  {
    "index": "F1332",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この条件は実は、ツリーでは黒ノードが多数派だと言っています。",
    "output": "It says, well actually, black nodes are a majority of nodes in the tree."
  },
  {
    "index": "F1333",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もともとは、どんな経路でも赤ノードが並ばないということです。",
    "output": "In a strong sense, there are no two reds in a row, on any path."
  },
  {
    "index": "F1334",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もし黒ノードの数が少なければ、赤ノードを並べることはできないので、経路上のノード数も2倍にしかなりません。",
    "output": "So, if we know the number of black nodes is small, then because you can't have two reds in a row, the number of total nodes on the path is at most twice as large."
  },
  {
    "index": "F1335",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最悪の場合で、黒のルートノードがあり、赤ノード、次に黒、次に赤黒、赤、黒、などとなります。",
    "output": "In the worst case, you have a black route, then red, then black, then red, then black, then red, then black, et cetera."
  },
  {
    "index": "F1336",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最悪の場合でも赤ノードの数は黒ノードの数と等しくなります。経路の長さは、赤ノードを考えた時、倍になります。",
    "output": "At the worst case, the number of red nodes is equal to the number of black nodes, which doubles the length of the path once you start counting the red nodes as well."
  },
  {
    "index": "F1337",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして、これはまさしく、ツリーの高さが対数的になるということです。",
    "output": "And this is exactly what it means for a tree to have a logarithmic depth."
  },
  {
    "index": "F1338",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実際、これはもしツリーが4つの不変条件を満たすなら、とくに赤ノードが並ばないというのと、黒ノードの経路上の数が等しいというなら、ツリーのことは他に何も知らなくても、ツリーはバランスされるという主張が証明されます。",
    "output": "So, this, in fact, proves the claim, if the search trees satisfies the invariants one through four, in particular if there's no two reds in a row and all root null paths have an equal number of black nodes, then, knowing nothing else about this search tree, it's got to be almost balanced."
  },
  {
    "index": "F1339",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "2を底として完全にバランスされます。",
    "output": "It's perfectly balanced up to a factor of two."
  },
  {
    "index": "F1340",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "また、ポイントとしては、探索木の操作も対数時間で実行されます。なぜなら、高さがこうした操作の実行時間を支配するからです。",
    "output": "And again, the point then is that operations in a search tree and the search trees are going to run in logarithmic time, because the height is what governs the running time of those operations."
  },
  {
    "index": "F1341",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さて、ある意味では、簡単な部分はお話しました。探索木が4つの不変条件を満たすなら、それでうまく行く。",
    "output": "Now, in some sense, I've only told you the easy part which is if it just so happens that your search tree satisfies these four invariants, then you're good."
  },
  {
    "index": "F1342",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "明らかにこれが、このデータ構造から欲しかったことです。",
    "output": "Clearly that's exactly what you want from this data structure."
  },
  {
    "index": "F1343",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ただ、このデータ構造を実際に実装しないといけない哀れな者どもは、データ構造が変化しても不変条件を維持するための労力をかけることになります。",
    "output": "But for the poor soul who has to actually implement this data structure, the hard work is maintaining these invariants even as the data structure changes."
  },
  {
    "index": "F1344",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでの問題は動的であること、挿入と削除に対応することです。",
    "output": "Remember, the point here is to be dynamic, to accommodate insertions and deletions."
  },
  {
    "index": "F1345",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "挿入と削除は4つの不変条件を台なしにするかもしれないので、コードを書き換えて条件を満たすようにすることで、ツリーを平衡に保ち、どんな挿入と削除の順番でも高さを保つ必要があります。",
    "output": "And searches and deletions can disrupt these four invariants and then one has to actually change the code to make sure they're satisfied again, so that the tree stays balanced, has low height, even under arbitrary sequences of insertions and deletions."
  },
  {
    "index": "F1346",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この部分は、このビデオでは扱いません。",
    "output": "So, we're not going to cover that in this video."
  },
  {
    "index": "F1347",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "操作のどれも明らかに遅くすることなしに実現できます。",
    "output": "It can be done, without significantly slowing down any of the operations."
  },
  {
    "index": "F1348",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これはとても複雑で、面白いアイデアを使います。",
    "output": "It's pretty tricky, takes some nice ideas."
  },
  {
    "index": "F1349",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "有名なアルゴリズムがいくつかあり、教科書に詳しく書いてあります。",
    "output": "There's a couple well-known algorithms textbooks that cover those details."
  },
  {
    "index": "F1350",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もしくは、オープンソースで平衡探索木のコードを探せば、実装するコードを読むこともできます。",
    "output": "Or if you look at open source and limitations of balanced search trees, you can look at code that does that implementations."
  },
  {
    "index": "F1351",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ともあれ、現実的に実現でき、しかも赤黒木は豊富な操作をサポートするので、数学アプリケーションでよく見かけます。",
    "output": "But, because it can be done in a practical way and because Red Black Tree supports such an original array of operations, that's why you will find them used in a number practical applications."
  },
  {
    "index": "F1352",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さて、対称暗号についてほどんど議論しつくしたが、次の話題に移る前に議論しておきたいちょっとしたものが少しある。",
    "output": "Well, we're almost done with our discussion of symmetric encryption."
  },
  {
    "index": "F1353",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まず最初に言っておきたいことは、私たちがどのようにある鍵から小さな鍵をつくっていくかについてだ。",
    "output": "There are just a couple of odds and ends that I'd like to discuss before we move on to the next topic."
  },
  {
    "index": "F1354",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そしてこの問題は実際にいつもつきまとう問題なんだ。だからみんながこの問題にどう正しく対処したらよいか、明らかにしておきたい。",
    "output": "So the first thing I'd like to mention is how we derive many keys from one key."
  },
  {
    "index": "F1355",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "どのような設定にしようか?",
    "output": "And it, actually, this comes up all the time in practice, so I'd like to make sure you know how to do this correctly."
  },
  {
    "index": "F1356",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "よし、色んな方法で作成されたある元となるキーがあるとしよう。",
    "output": "So what's the setting that we're looking at? Well, imagine we have a certain source key that's generated by one of, a number of methods."
  },
  {
    "index": "F1357",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そのあるキーはPRGによって作成されたか、またはあとで話す鍵交換プロトコルというものから作成されたとする。",
    "output": "Imagine the source key is generated by a hardware random number generator or perhaps is generated by a key exchange protocol which we're going to discuss later."
  },
  {
    "index": "F1358",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まあいずれにせよ、アリスとボブの間で作成されるキーの作り方はたくさんある。",
    "output": "But anyhow, there are a number of ways in which a source key might be generated between Alice and Bob, such that the attacker doesn't know what the source key is."
  },
  {
    "index": "F1359",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "攻撃者に知られていない鍵がね。",
    "output": "But now, as we said, in many cases, we actually need many keys to secure a session, not just one single source key."
  },
  {
    "index": "F1360",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さて、言ったようにさまざまな場合で、セッションを安全なものにするためには実際あるひとつの鍵ではなく、たくさんの鍵が必要なんだが、たとえば、もし覚えているなら、TLSは1方向の鍵が必要で、それが両方向に必要だった。",
    "output": "For example, if you remember, in TLS there were unidirectional keys and we needed keys in each direction."
  },
  {
    "index": "F1361",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実際、どちらの方向でも複数の鍵が必要で、MAC用の鍵、暗号化用の鍵、IVが必要などなど。",
    "output": "And in fact, in each direction, we needed multiple keys. We needed a MAC key, we needed an encryption key."
  },
  {
    "index": "F1362",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そこで、問題は私たちがどのように導出した鍵を使うかということだ。それはハードウェアから生成したものでも、鍵交換で手に入れたものでもよい。",
    "output": "And so, the question is, how do we use the one source key that we just derived, either from a hardware process or by key exchange, and generate a bunch of keys from it that we could then use to secure our session."
  },
  {
    "index": "F1363",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "その鍵でたくさんの新しい鍵の束を作成してセッションを安全なものにすることができる。",
    "output": "The way that's done, is using a mechanism called a key derivation function, KDF. And I want to talk a little bit about how KDF's are constructed."
  },
  {
    "index": "F1364",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今行ったのは鍵導出関数KDFという仕組みで、もうすこしKDFがどのように構築されるかを話したい。",
    "output": "So first of all, suppose we have a secure PRF, that happens to have key space K."
  },
  {
    "index": "F1365",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まず、安全なPRFがあるとして、鍵空間はKとする。",
    "output": "And now, suppose that it so happens that our source key SK is uniform in the key K."
  },
  {
    "index": "F1366",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私たちがもっている鍵はSKとする。SKは鍵空間で一様とする。",
    "output": "In this case, the source key is, in fact, a uniform random key for the secure PRF F."
  },
  {
    "index": "F1367",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実際安全なPRFでは、元となる鍵は一様ランダム鍵だ。",
    "output": "So in this case, the KDF is really simple. The key derivation function would just work as follows."
  },
  {
    "index": "F1368",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして、この鍵をセッションを安全にする鍵の生成にそのまま使える。",
    "output": "It would take as input the source key."
  },
  {
    "index": "F1369",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この場合、KDFはほんとに単純で、KDFは次のように働く。",
    "output": "It would take an input, a parameter context, which I'm gonna describe in just a minute."
  },
  {
    "index": "F1370",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "よし、KDFが何をするかというと、基本的には0についてPDFを評価する。",
    "output": "And then what it will do is it will basically evaluate the PRF on zero."
  },
  {
    "index": "F1371",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それから、1について、2について、と行っていき、Lまで行う。",
    "output": "Then it will evaluate the PRF on two, up until L."
  },
  {
    "index": "F1372",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "コンテキストについて話そう。基本的にはセッション。",
    "output": "And I will talk about what this context is in just a second."
  },
  {
    "index": "F1373",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "あなたが必要な場合は、方向キーを生成するだろう必要がありますので、あなた各キーが、暗号化キーおよびmacが含まれます1つキーレス方向を知っています。",
    "output": "And then, basically, you would use as many bits of the output as you would need to generate all the keys for the session. So, if you need unidirectional keys you would generate, you know, one key in each direction where each key might include an encryption key and a MAC key."
  },
  {
    "index": "F1374",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "キー。ので、基本的に必要なビットを生成するし、最後に出力オフときにセキュリティで保護するには、十分なキーを生成した時にカットをセッション。",
    "output": "And so, you would basically generate as many bits as you need and then finally cut off the output at the time when you've generated enough keys to secure your session."
  },
  {
    "index": "F1375",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "わかりましたので、これは基本的にを使用してはかなりまっすぐ進むメカニズムです、セキュリティで保護されたPRFは擬似乱数生成器として。",
    "output": "Okay so this is a fairly straight forward mechanism it's basically using the secure PRF as a pseudo random generator."
  },
  {
    "index": "F1376",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "唯一の問題は何ですのコンテキスト文字列です。",
    "output": "And the only question is what is its context string."
  },
  {
    "index": "F1377",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まあ、コンテキスト文字列が基本的には、一意であることよアプリケーションを識別する文字列。",
    "output": "Well, I'll tell you that the context string is basically a unique string that identifies the application."
  },
  {
    "index": "F1378",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だから実際には、複数を必要があります。複数のセキュリティで保護されたキーを確立しようとしては、同じシステム上のアプリケーション。",
    "output": "So in fact you might have multiple applications on the same system that's trying to establish multiple secure keys."
  },
  {
    "index": "F1379",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "たぶん1つのプロセスとしては、あなたを実行するwebサーバーがあるSSHをある別プロセス、および3番目としてのipアドレスを処理し、すべての3つの秘密キーが必要生成されました。",
    "output": "Maybe you have SSH running as one process, you have a web server running as another process, IPsec as a third process and all three need to have secret keys generated."
  },
  {
    "index": "F1380",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このコンテキスト変数は基本的に3つの別々にそれら。",
    "output": "And this context variable basically tries to separate the three of them."
  },
  {
    "index": "F1381",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だから、私に聞いてより正確に、何これの目的と思うコンテキスト変数ですか?",
    "output": "So, let me ask you, more precisely, what do you think the purpose of this context variable is?"
  },
  {
    "index": "F1382",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "例では、我々だけ3つのサービス、SSH、話をサーバー、およびIPの設定Web、彼らはすべて同じソースキーからハードウェア乱数を取得するが起こる場合ジェネレーターは、3つのアプリを異なるのでコンテキスト[になります。彼らはまだ彼ら[セキュリティで保護することができる3つの独立した文字列を得ることを確認してセッション。",
    "output": "So I guess I've given it away and this context variable is supposed to basically separate applications, so that even if, for example, the three services that we just talked about, SSH, web server, and IPsec, if they all happen to obtain the same source key from the hardware random number generator then the context since it's different for the three apps will make sure that they still get three independent strings that they can then use to secure the sessions."
  },
  {
    "index": "F1383",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは実際にはかなりですが、ことを覚えていて欲しいだけ簡単なとコンテキスト文字列を実際には前に話し合った重要なとは、アプリケーションを特定する必要がので、それぞれアプリケーションでは、独自のセクションのキーを取得します。",
    "output": "I just want you to remember that, even though this is actually fairly straightforward, and we discussed this before, the context string is actually important, and it does need to be specific to the application, so that each application gets its own session keys, even if multiple applications happen to sample the same SK."
  },
  {
    "index": "F1384",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "次の質問は、何行う場合ソースキーは実際に均一ではないです。",
    "output": "The next question is, what do we do if the source key actually isn't uniform?"
  },
  {
    "index": "F1385",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "我々は問題になりました。",
    "output": "Well, now we got a problem."
  },
  {
    "index": "F1386",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ソースキーでない場合は、制服の擬似ランダム関数キーはもはやと仮定することができ、擬似ランダム関数の出力がランダムから区別されます。",
    "output": "If the source key is not a uniform key for the pseudo random function then we can no longer assume that the output of the pseudo random function is indistinguishable from random."
  },
  {
    "index": "F1387",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実際には場合、使用するだけですし、出力がランダムに見えるかもしれませんが、先ほど述べたKDF敵、彼はいくつかのセッションキーが予期することができる可能性があります。",
    "output": "In fact, if we just use the KDF that we just described then the output might not look random to the adversary and then he might be able to anticipate some of the session keys that we'll be using and thereby break the session."
  },
  {
    "index": "F1388",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だから、我々は問題があります。",
    "output": "So then we have a problem."
  },
  {
    "index": "F1389",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今なぜこのソースキー制服ないだろうか?",
    "output": "Now why would this source key not be uniform?"
  },
  {
    "index": "F1390",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "多くの理由はなぜこの起こった。",
    "output": "Well there are many reasons why this happened."
  },
  {
    "index": "F1391",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "たとえば通常はたまたま、鍵交換プロトコルを使用してキー交換プロトコル高en-トリッパキーが生成されます。",
    "output": "For example if you use a key exchange protocol, it so happens typically that key exchange protocols will generate a high entropy key."
  },
  {
    "index": "F1392",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だからそれか均一な文字列にはないだろう。",
    "output": "So it's not going to be a uniform string."
  },
  {
    "index": "F1393",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "サブセット。大規模なのとすぐに我々の語ることの例を見るキー交換プロトコル。",
    "output": "It will be uniform in some subset of a larger set, And we'll see examples of that as soon as we talk about key exchange protocols."
  },
  {
    "index": "F1394",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "KDFs種の事実のために対応するので、キー交換プロトコルは実際に均一ビット文字列を生成しないでください。",
    "output": "And so KDFs have to kind of accommodate for the fact that key exchange protocols actually don't generate uniform bit strings."
  },
  {
    "index": "F1395",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "その他問題は、実際には、使用しているハードウェア乱数ジェネレーターかもしれないこと、実際に偏りのある出力を生成します。",
    "output": "The other problem is, that, in fact, the hardware random number generator you're using might actually produce biased outputs."
  },
  {
    "index": "F1396",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ハードウェアの非バイアスに依存する必要はありません。乱数ジェネレーター。",
    "output": "We don't wanna rely on the non bias of the hardware random number generator."
  },
  {
    "index": "F1397",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だから、すべての我々と仮定する必要がある高を生成することエントロピーの文字列が1つは、偏りがある場合があります。",
    "output": "And so all we want to assume is that it generates a high entropy string, but one that might be biased."
  },
  {
    "index": "F1398",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "場合は、私たち必要がなんとかしてあります。",
    "output": "In which case, we have to somehow clean this bias."
  },
  {
    "index": "F1399",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして、これは、このパラダイムを紹介しますKDFsを構築します。",
    "output": "And so this introduces this, this paradigm for building KDFs."
  },
  {
    "index": "F1400",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは、抽出と呼ばれるし、どこの最初のステップのパラダイムを展開KDFは、実際のソースキーから疑似ランダムキーを抽出することです。",
    "output": "This is called the extract-then-expand paradigm, where the first step of the KDF is to extract a pseudo random key from the actual source key."
  },
  {
    "index": "F1401",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そうでは画像をこのように考えることができます。",
    "output": "So in a picture you can think about it like this."
  },
  {
    "index": "F1402",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ある意味でこれらが異なっています。ソースキーの値。",
    "output": "In some sense these are the different possible values of the source key."
  },
  {
    "index": "F1403",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは、水平線と垂直軸のです。基本的に、これらの値のそれぞれの確率と見ることができますは、このソースキーが一様でないことを言うだろうでこぼこ関数の一種です。",
    "output": "This is the horizontal line and the vertical axis is basically the probability of each one of these values, and you can see that this is a kind of a bumpy function which would say that the source key is not uniformly distributed in the key space."
  },
  {
    "index": "F1404",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この場合は我々を使用すると呼ばれるものです、エクストラクター。",
    "output": "What we do in this case is we use what's called an extractor."
  },
  {
    "index": "F1405",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "抽出でこぼこの分布を作るものですのでそれは、鍵空間を均一な分布に。我々の場合に実際にだけなのです。",
    "output": "So an extractor is something that takes a bumpy distribution and makes it into a uniform distribution over the key space."
  },
  {
    "index": "F1406",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "計算の抽出器と呼ばれるものを使用しようとしました。すなわち必ずしもが最後に一様分布を生成しない抽出器彼らは制服から区別のつかない分布を生成しました。",
    "output": "In our case we're actually just gonna be using what are called computational extractors, namely extractors that don't necessarily produce uniform distribution at the end but they generated distribution that's indistinguishable from uniform."
  },
  {
    "index": "F1407",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今エクストラクターを通常取るとしてと呼ばれるものを塩と塩だけを入力サラダ、それ種類の味を足すように、それは何基本的のようなものです。どの入力分布の関係なく、出力は、物事をまぜこぜ分布はまだランダムから見分けがつかないことになります。",
    "output": "Now extractors typically take as input something called a salt, and a salt just like in a salad, it kind of adds flavor to things, what it does is basically kind of jumbles things around, so that no matter what the input distribution is, the output distribution is still going to be indistinguishable from random."
  },
  {
    "index": "F1408",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だから、塩基本的には、それは何ですか?",
    "output": "So a salt basically, what is it?"
  },
  {
    "index": "F1409",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それが公に知られているので、非秘密の文字列です。",
    "output": "It's a non-secret string, so it's publicly known."
  },
  {
    "index": "F1410",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それdoesn'tします。どのような塩、敵を知っている場合は、問題とそれが永久に固定されます。",
    "output": "It doesn't matter if the adversary knows what the salt is, and it's fixed forever."
  },
  {
    "index": "F1411",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "唯一ポイントは、あなたがそれを選んだときに、ランダム選択ことです。",
    "output": "The only point is that when you chose it, you chose one at random."
  },
  {
    "index": "F1412",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "その後、希望はちょっとから抽出しようとしている面白い分布を本質的にしません。上に塩を選んだしたがって、結果として、塩を使用によって異なります、ランダムからと見分けがつきません分布は実際に取得します。",
    "output": "And then the hope is that the funny distribution that you're trying to extract from kinda doesn't inherently depends on the salt that you chose and hence as a result using your salt, you will actually get a distribution that looks indistinguishable from random."
  },
  {
    "index": "F1413",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "とき、それがちょうど生成回ランダムで何かをする必要があります。当初は最後の研究者が何を知っている場合、固定永遠と罰金それし、それにもかかわらず、抽出、エントロピーと出力を抽出することです、一様乱数文字列キー。",
    "output": "So essentially the salt, you know, you can just bang it the keyboard a couple of times when you generate it but it just needs to be something that's random initially but then it's fixed forever, and it's fine if the adversary knows what it is and nevertheless the extractor is able to extract the entropy and output a uniformly random string K."
  },
  {
    "index": "F1414",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "いくつかの塩だけを守るには敵対の悪い分布が私たちの抽出を混乱可能性があります。",
    "output": "In some sense the salt is only there to defend against adversarially bad distributions that might mess up our extractor."
  },
  {
    "index": "F1415",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "わかりました、そう今は擬似ランダムキーを抽出しました。",
    "output": "Okay, so now that we have extracted a pseudo random key."
  },
  {
    "index": "F1416",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今、私たちにもちょうどそれをKDF使用可能性があります。我々は安全関数を使用して、キーを展開する見た我々は実際には、セッションを保護する必要がある同じビット数に。",
    "output": "Now, we might as well just use it in a KDF that we just saw using a secure pseudo random function to expand the key into as many bits as we need to actually secure the session."
  },
  {
    "index": "F1417",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "わかりましたはそこでください。これら2つの手順。",
    "output": "Okay, so there are these two steps."
  },
  {
    "index": "F1418",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最初の1つ私たちは擬似乱数キーをし、1回の抽出我々は我々として、多くのキーに拡張する方法を既に知っている擬似乱数キーがあります。我々は、擬似ランダム関数を使用する必要があります。",
    "output": "The first one is we extract a pseudo-random key, and then once we have a pseudo-random key we already know how to extend it into as many keys as we need using a pseudo-random function."
  },
  {
    "index": "F1419",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私たちがやっている、標準化、これです。",
    "output": "So the standardized way of doing this is called HKDF."
  },
  {
    "index": "F1420",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは、H-MACから組み込まれているKDFリビジョン関数です。",
    "output": "This is a KDF, a key derivation function that's built from HMAC."
  },
  {
    "index": "F1421",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでHMACが拡大PRFと抽出抽出ツールの両方として使用されます。初期の擬似キーです。",
    "output": "And here HMAC is used both as the PRF for expanding and an extractor for extracting the initial pseudo-random key."
  },
  {
    "index": "F1422",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ので、どのようにこの作品を説明させてください。",
    "output": "So let me explain how this works."
  },
  {
    "index": "F1423",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ので、抽出ステップ、私たちつもりの解決を使用する公共のメンバーを撤回した値だけが起こったランダム時間の先頭が生成されます。",
    "output": "So in the extract step, we're gonna use our salt which you remember is a public value just happened to be generated at random at the beginning of time."
  },
  {
    "index": "F1424",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この解決としてHMACを使用してキー。",
    "output": "And we use this salt as the HMAC key."
  },
  {
    "index": "F1425",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ソースキーはHMACデータとして使用するつもりです。",
    "output": "And then the source key we're gonna use as the HMAC data."
  },
  {
    "index": "F1426",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だから我々のようなものにしていますパブリック値をキーとして使用します。",
    "output": "So we're kind of using a public value as a key."
  },
  {
    "index": "F1427",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私たちがHMacを適用した場合などは、抽出のプロパティ結果のキーになります。一見ランダムなから、実際のソースキーを持つと仮定すると区別がつかない十分なエントロピーは。",
    "output": "And nevertheless, one can argue that HMAC has extraction properties, such that, when we apply HMAC, the resulting key is going to look indistinguishable from random, assuming that the source key actually has enough entropy to it."
  },
  {
    "index": "F1428",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今は私たちは擬似ランダムキー私たち単につもりです。HMacとしてのPRFを使用して生成するセッションキーを知って、多くのベースとして我々セッションキーを必要があります。",
    "output": "And now that we have the pseudo random key we're simply going to use HMAC as a PRF to generate a session key of you know as many bits as we need for the session keys."
  },
  {
    "index": "F1429",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "わかりました。",
    "output": "Okay."
  },
  {
    "index": "F1430",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だから基本的には我々の議論を結論します。HQDF。",
    "output": "So that basically concludes our discussion of HKDF."
  },
  {
    "index": "F1431",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "か、元のキーを取得した後、覚えてほしいだけハードウェアやキー交換プロトコルから、道に換算します。セッションキーはないそのサンプルを使用して直接です。",
    "output": "And I just want you to remember that, once you obtain a source key, either from hardware or from a key exchange protocol, the way you convert it into session keys is not by using that sample directly."
  },
  {
    "index": "F1432",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "あなたは決してソースキーを使用しません。直接プロトコル内のセッションキーとして。",
    "output": "You would never use a source key directly as a session key in a protocol."
  },
  {
    "index": "F1433",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だろうと何かを実行、ソースキー、KDFを介して。",
    "output": "What you would do is you will run the source key through a KDF."
  },
  {
    "index": "F1434",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "KDFのすべてのキーと出力を与えるだろう使用するランダムキーの偶発性のために必要なお客様プロトコル。",
    "output": "And the KDF would give you all the keys and output that you need, for, the randomness, for the random keys to be used in your protocol."
  },
  {
    "index": "F1435",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ありを使用する典型的なKDFHKDFは、実際になっている、非常にそこのトラクションのビットです。",
    "output": "And a typical KDF to use is HKDF, which is actually getting quite a bit of traction out there."
  },
  {
    "index": "F1436",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "わかりました。",
    "output": "Okay."
  },
  {
    "index": "F1437",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このセグメントで話したい最後のトピックパスワードからキーを抽出する方法。",
    "output": "The last topic I wanna talk about in this segment is, how do you extract keys from passwords."
  },
  {
    "index": "F1438",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでの問題はパスワード比較的低があります。",
    "output": "The problem here is that passwords have relatively low entropy."
  },
  {
    "index": "F1439",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実際には、私たちの後、コースのパスワードについて話をするつもりだとはユーザー認証についての話します。",
    "output": "In fact, we're gonna talk about passwords later on in the course when we talk about user authentication."
  },
  {
    "index": "F1440",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "あまりここで言うつもりはないので。",
    "output": "And so, I'm not gonna say too much here."
  },
  {
    "index": "F1441",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私はちょうどよパスワードは、一般的に20程度推定非常に少しのエントロピーが言うエントロピーのビットを言います。",
    "output": "I'll just say passwords generally have very little entropy estimated on the order of twenty bits of entropy, say."
  },
  {
    "index": "F1442",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "その結果、ない単に十分なエントロピーパスワードからセッションキーを生成します。",
    "output": "And as a result, there is simply not enough entropy to generate session keys out of a password."
  },
  {
    "index": "F1443",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まだ我々はまだ非常にする必要があります。",
    "output": "And yet we still need to do it very frequently."
  },
  {
    "index": "F1444",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "頻繁に。我々はまだ暗号化キーとMacのうち派生する必要では、どのようにパスワード。",
    "output": "We still need to derive encryption keys and MACs and so on out of passwords, so the question is how to do it."
  },
  {
    "index": "F1445",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最初は、知っている、このためです。種類の目的は、HKDFを使用しないでください。",
    "output": "The first thing is, you know, for this kind of purpose, don't use HKDF."
  },
  {
    "index": "F1446",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "起こる右のキーは実際に何かと呼ばれる脆弱性が存在することです。",
    "output": "That's not what it's designed for."
  },
  {
    "index": "F1447",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私たちずっと後に、コースについて話をするつもりは、辞書攻撃はときに、我々はユーザーの認証について話します。",
    "output": "What will happen is that the derived keys will actually be vulnerable to something called a dictionary attack, which we're gonna talk about much later in the course when we talk about user authentication."
  },
  {
    "index": "F1448",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だから、この低エントロピーに対する方法pbkdsを守る辞書攻撃とは結果が問題によって2つの手段です。",
    "output": "So, the way PBKDFs defend against this low entropy problem that results in a dictionary attack is by two means."
  },
  {
    "index": "F1449",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まず、としてを使用する前に、国民は、ランダムな値の固定永遠に。",
    "output": "First of all, as before they use a salt, a public, random value that's fixed forever."
  },
  {
    "index": "F1450",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかしでさらに、彼らは使用しても何の遅いハッシュ関数と呼ばれます。",
    "output": "But in addition, they also use what's called a slow hash function."
  },
  {
    "index": "F1451",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "説明させてください。パスワードからキーを派生する、標準的なアプローチのような。",
    "output": "And let me describe kind of the standard approach to deriving keys from passwords."
  },
  {
    "index": "F1452",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これはPKCS5と呼ばれる、何PBKDF1と呼ばれるが、特に、このスクライブのバージョンです。",
    "output": "This is called PKCS#5, and in particular, the version I'll describe is what's called PBKDF1."
  },
  {
    "index": "F1453",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私はこのメカニズムはので、最もcryptalライブラリに実装されていることを言う必要があります。あなた自身で実装する必要はありません。",
    "output": "And I should say that this mechanism is implemented in most crypto libraries so you shouldn't have to implement this yourself."
  },
  {
    "index": "F1454",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "すべての場合、あなたが知っているだろう、関数を呼び出すと、あなたは、パスワードから派生キーを知っています。",
    "output": "All you would do, you know, you would call a function, you know, derived key from password."
  },
  {
    "index": "F1455",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "あなたを与えるだろう、パスワードを入力とあなたとしてのキー出力としてなるでしょう。",
    "output": "You would give the password in as input, and you would get a key as output."
  },
  {
    "index": "F1456",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、あなたが知っておくべきこのキーは、実際にはなりますので高エントロピーがあるつもりはないコースデシベル。",
    "output": "But you should be aware of course that this key is not going to have high entropy so in fact it will be guessable."
  },
  {
    "index": "F1457",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これらの鉛KDFsがやろうとして推測の問題としては難しいです。",
    "output": "What these PBKDFs try to do is make the guessing problem as hard as possible."
  },
  {
    "index": "F1458",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "わかりました。",
    "output": "Okay."
  },
  {
    "index": "F1459",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私たちが言ったように、彼らが働く、まず第一に、方法、ので彼ら基本的にはハッシュは、パスワードとsaltの連結。",
    "output": "So the way they work, first of all, is, as we said, they basically hash, the concatenation of the password and the salt."
  },
  {
    "index": "F1460",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "して、ハッシュ自体は非常に遅いハッシュ関数をように設計されています。",
    "output": "And then the hash itself is designed to be a very slow hash function."
  },
  {
    "index": "F1461",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "低速ハッシュを構築する方法関数は1つの特定のハッシュ関数と言う56と私たちによってです。それ多くは、多くの場合、反復処理C回。",
    "output": "And the way we build a slow hash function is by taking one particular hash function, say, SHA-256, and we iterate it many, many times, C times."
  },
  {
    "index": "F1462",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "1000回を想像することができます、おそらくでも、100万回。",
    "output": "So you can imagine 1000 times, perhaps even a million times."
  },
  {
    "index": "F1463",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そしてそれを反復することで何を意味するか。",
    "output": "And what do I mean by iterating it?"
  },
  {
    "index": "F1464",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だから、まあ、私たちを取る、パスワードは、塩。",
    "output": "So, well, we take the password and the salt."
  },
  {
    "index": "F1465",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "1つの入力、ハッシュ関数の内部入れます。",
    "output": "And we put them inside of one input to the hash function."
  },
  {
    "index": "F1466",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "我々はハッシュ関数適用おっと、それがこのような書き込みさせてください。",
    "output": "And then we apply the hash function, oops, let me write it like this."
  },
  {
    "index": "F1467",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして私たちハッシュ関数を適用し、出力を取得し、我々ハッシュを適用関数をもう一度、私たちは、別の出力を取得します。",
    "output": "And then we apply the hash function and we get an output, and then we apply the hash function again and we get another output."
  },
  {
    "index": "F1468",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "我々は再び、もう一度、もう一度これを行うたぶん千回は100万回によってどのように高速あなたのプロセッサか最後に私たちは実際には、キーとして出力として、最終的な出力を取得します。このキー導出関数の出力。",
    "output": "And we do this again and again and again maybe a thousand times or a million times depending on how fast your processors are and then finally we get the final output that we actually output as, as the key output of this key derivation function."
  },
  {
    "index": "F1469",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今ここでのポイントは何でしょうか。",
    "output": "Now what is the point here?"
  },
  {
    "index": "F1470",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "関数10,000回または100万倍も非常に少し時間を取るつもりです。現代のCPUと結果として、それは本当に、ユーザーの経験に影響しません。",
    "output": "Iterating a function 10,000 times or even a million times is going to take very little time on a modern CPU, and as a result, it doesn't really affect the user's experience."
  },
  {
    "index": "F1471",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "は彼のパスワードでは、ユーザーの種類は100万回ハッシュを取得し、出力を取得します。",
    "output": "The user types in his password, it gets hashed a million times and then it gets output."
  },
  {
    "index": "F1472",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "たぶんそれも取ることができる2番目の10分の1を知っているし、ユーザーwouldn'tそれに気づきます。",
    "output": "And maybe that could even take, you know a tenth of a second and the user wouldn't even notice it."
  },
  {
    "index": "F1473",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、攻撃者が、彼は彼のすべてのパスワードを試すことができます。我々は知っているので、辞書では、人々パスワード辞書で選ぶ傾向がある、彼が1つずつにしようと、思い出して塩を彼は知っているので公開ですどのような塩です。",
    "output": "However the attacker, all he can do is he can try all the passwords in the dictionary, because we know people tend to pick passwords in dictionaries, and so he could just try them one by one, remember the SALT is public, so he knows what the SALT is."
  },
  {
    "index": "F1474",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "彼はちょうど一つずつこのハッシュを試すことができます。",
    "output": "And so he can just try this hash one by one."
  },
  {
    "index": "F1475",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかしのでハッシュ関数は遅い、各試行が彼が2番目の10分の1を取るつもりです。",
    "output": "However because the hash function is slow, each attempt is gonna take him a tenth of second."
  },
  {
    "index": "F1476",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "だから彼は必要がある場合辞書を介して、ご存知のように、実行すると、2000億のパスワードには、ハッシュ関数は低速であるため、これはかなり時間がかかるつもりです。",
    "output": "So if he needs to run through a dictionary, you know, with, with a 200 billion passwords in it, because the hash function is slow, this is gonna take quite awhile."
  },
  {
    "index": "F1477",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "することによって我々は辞書攻撃ダウンが遅いし、我々が、攻撃者には難しく、私たちのセッションキーを取得します。",
    "output": "And by doing that, we slow down the dictionary attack, and we make it harder for the attacker to get our session keys."
  },
  {
    "index": "F1478",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "不可能ではない、ただ困難。",
    "output": "Not impossible, just harder."
  },
  {
    "index": "F1479",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "すべてこれはしようとしているです。",
    "output": "That's all this is trying to do."
  },
  {
    "index": "F1480",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さて、基本的に何を言ってみたいので、このパスワードはKDFsに基づきます。",
    "output": "Okay, so this is basically what I wanted to say about password based KDFs."
  },
  {
    "index": "F1481",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私としてこれを自分で構築するない何か。",
    "output": "As I said, this is not something you would build yourself."
  },
  {
    "index": "F1482",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "あなただけを呼び出すと、パスワードをキーに変換し、結果を使用して適切な関数キー。",
    "output": "And you would just call the appropriate function to convert a password into a key, and then use the resulting key."
  },
  {
    "index": "F1483",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さて、次のセグメントでは、対称暗号化を使用する方法を参照してください俺たち方法では、私たちの暗号テキストを検索することができます。",
    "output": "Okay, in the next segment, we're gonna see how to use symmetric encryption in a way that allows us to search on the cipher texts."
  },
  {
    "index": "F1484",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "はじめましてプリンストン大コンピュータ・サイエンス教授のボブ・セジウイックですこの「アルゴリズム」のオンラインコースはプリンストン大のケヴィン・ウェインと共に開発しましたまずなぜアルゴリズムを学習するのかを簡単に説明しこのコースに必要なリソースをお話ししますこのコースは「アルゴリズムとは何か?",
    "output": "This is our online course Algorithms developed by myself and Kevin Wayne here at Princeton. We're gonna start with an overview discussion of why you might want to study algorithms and a little bit of discussion about the resources that you need to take this course."
  },
  {
    "index": "F1485",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "」を学ぶ中級レベルのコースです実際の場面で使えるプログラミングや問題解決の手順を中心に特に次の2点に重点を置いて学びます問題を解決する手順である「アルゴリズム」と問題に関するデータを格納する「データ構造」でこれはアルゴリズムと切り離すことはできませんこの2つの基本的なトピックを2つのパートに分けて説明しますパート1ではデータタイプやソート(並べ替え)やサーチ(検索)を学びますここで紹介する様々なデータ構造とアルゴリズムはスタック、キュー、バッグ、プラオリティキューなどの理解に不可欠です次に定番の並べ替えに使われるソート・アルゴリズム--クイックソート、マージソート、ヒープソート、基数ソートを勉強しますまた、定番のサーチアルゴリズム--二分探索木や赤黒木やハッシュテーブルを紹介しますパート2ではさらに高度なアルゴリズム--グラフやグラフ探索のアルゴリズムや最小全域木と最短経路アルゴリズムを検討します。",
    "output": "We're going to concentrate on programming and problem solving in the context of real applications, and our focus is going to be on two things, Algorithms which are methods for solving problems and data structures which store the information associated in problem, with a problem and go hand in hand with algorithms."
  },
  {
    "index": "F1486",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "文字列を処理するアルゴリズムについても検討し、正規表現やデータ圧縮などを扱います。",
    "output": "We'll consider a number of data structures and algorithms that are basic to all the methods we consider including stacks, queues, bags and priority queues. Then we'll consider classic algorithms for sorting, putting things in order."
  },
  {
    "index": "F1487",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さらに、いくつかの複雑なアルゴリズムについても取り扱い、コースの前半で開発した基本的なアルゴリズムを利用するものになっています。",
    "output": "And then some advanced algorithms that make use of the basic algorithms that we developed earlier in the course."
  },
  {
    "index": "F1488",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さて、なぜアルゴリズムを学ぶ必要があるのでしょうか?",
    "output": "So, why should one study algorithms?"
  },
  {
    "index": "F1489",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "その影響はとても広くさまざま分野に及んでいます。",
    "output": "Well, their input, impact is very broad and far-reaching."
  },
  {
    "index": "F1490",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "インターネットから生物学、商用コンピューティング、コンピュータグラフィック、セキュリティ、マルチメディア、ソーシャルネットワーク、科学利用まで、アルゴリズムは身の回りのいたるところにあるのです。",
    "output": "From the internet to biology to, commercial computing, computer graphics, security, multimedia, social networks, and scientific applications, algorithms are all around us."
  },
  {
    "index": "F1491",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "映画やビデオゲーム、粒子衝突シミュレーションに利用され、ゲノムの研究にも利用され、他のあらゆる分野に適用されています。",
    "output": "They're used for movies and video games, for particle collision simulation, they're used to study the genome, and all manner of other applications."
  },
  {
    "index": "F1492",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "アルゴリズムを学ぶひとつの重要な理由は、このように影響が非常に広い分野に及んでいるためです。",
    "output": "So, that's one important reason to study algorithms, their impact is broad and far-reaching."
  },
  {
    "index": "F1493",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "アルゴリズムの研究自身もとても面白いもので、古くからの起源を持っています。",
    "output": "Algorithms are also interesting to study, because they, they have ancient roots."
  },
  {
    "index": "F1494",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最初のアルゴリズムは紀元前300年にさかのぼり、ユークリッドの時代です。",
    "output": "Now the first algorithm we studied goes back to 300 B.C., dating at least to Euclid."
  },
  {
    "index": "F1495",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "アルゴリズムの概念が厳密に定式化されたのは、ここ、プリンストンで、チャーチとチューリングによって、1930年代に行われました。",
    "output": "The concept of an algorithm was formalized actually here at Princeton, by Church and Turing, in the 1930s."
  },
  {
    "index": "F1496",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、私たちが検討するアルゴリズムの大部分は、比較的最近発見されたものです。",
    "output": "But most algorithms that we consider, were discovered in recent decades."
  },
  {
    "index": "F1497",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実際、そのうちのいくつかは、このコースや類似のコースの学生によって発見されたものです。",
    "output": "In fact, some were discovered by undergraduates in a course, course like this."
  },
  {
    "index": "F1498",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まだ多くのアルゴリズムがあなた方学生によって発見されるのを待っているのです。",
    "output": "And there's plenty of other algorithms waiting to be discovered by students like you."
  },
  {
    "index": "F1499",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "アルゴリズムを学ぶ一番の理由は、他の方法では対応することができない問題の解決を可能にすることです。",
    "output": "The main reason that people study algorithms, is to be able to solve problems that it could not otherwise be addressed."
  },
  {
    "index": "F1500",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最初の講義でその一例としてお話しするのは、ネットワークコネクティビティの問題です。この問題は、ペアとしてつながっている要素の集合に対して、その接続をたどって、ある要素から他の要素へと通じる経路があるかどうかを確かめるものです。",
    "output": "For example, in the first lecture, we're going to talk about the network connectivity problem, where the problem is, given a large set of items that are connected together pairwise is there a way to get from one to another with a path through the connections."
  },
  {
    "index": "F1501",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この例からわかるように、そのような経路が存在するかどうかは明らかではありません。このような場合、コンピュータプログラムが必要になり、実際、そのための効率的なアルゴリズム必要になります。",
    "output": "As you can see from this example, it's not clear whether or not there's such a path, we need a computer program to do it, in fact, we need an efficient algorithm to do it."
  },
  {
    "index": "F1502",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この場合は、答えはそのような経路が存在することになります。",
    "output": "In this case the answer is that there is such a path."
  },
  {
    "index": "F1503",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "アルゴリズムを学ぶもうひとつの理由は思考実験となるためです。",
    "output": "Another reason to study algorithms is for intellectual stimulation."
  },
  {
    "index": "F1504",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "アルゴリズムはとても面白い研究対象です。",
    "output": "Algorithms are very interesting objects to study."
  },
  {
    "index": "F1505",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "」アルゴリズムをただ利用するだけのものと考えてはいけません。また、フランシス・サリバンはこのようにも言っています。",
    "output": "Don Knuth who wrote several books on, on algorithms and was a pioneer in the field said that, \"An algorithm must be seen to be believed.\" You can't just think about an algorithm you have to work with it."
  },
  {
    "index": "F1506",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "「偉大なアルゴリズムは計算の詩である。」韻文詩のように簡潔で、難解で、濃密で、神秘的でさえあります。",
    "output": "Another quote from Francis Sullivan, says, \"The great algorithms are the poetry of computation.\" Just like verse, they can be terse, elusive, dense, and even mysterious."
  },
  {
    "index": "F1507",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、一度その鍵を開けることができれば、計算のいくつかの面に眩い新しい光を当てることになるのです。",
    "output": "But once unlocked, they cast a brilliant new light on some aspect of computing."
  },
  {
    "index": "F1508",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "多くの人々がアルゴリズムを研究するもうひとつの理由、そして、皆さんの多くの人もそうだと思いますが、それは、良いアルゴリズム、効率的なアルゴリズム、良いデータ構造を理解し、優秀なプログラマになるためです。",
    "output": "Another reason many people study algorithms and I suspect many of you, is it's necessary to understand good algorithms, efficient algorithms, a good data structures in order to be a proficient programmer."
  },
  {
    "index": "F1509",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "リナス・トーバルズは、Linuxを開発したのですが、こう言っています。悪いプログラマと良いプログラマの違いは、コードやデータ構造のどちらに重きを置いているかだと。",
    "output": "Linus Torvalds, who created lin, Linux, says that the difference between a bad programmer and a good one is whether he considers his code or his data structures more important."
  },
  {
    "index": "F1510",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "駄目なプログラマはコードばかりを気にしていて、優秀なプログラマはデータ構造と、データ構造とコードの関係を大事にしている。",
    "output": "Bad programmers worry about the code, good programmers worry about data structures, and their relationships."
  },
  {
    "index": "F1511",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さらに私はそれらを扱うアルゴリズムを付け加えたいと思う。",
    "output": "And, I might add, the algorithms that process them."
  },
  {
    "index": "F1512",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もう一人のコンピュータサイエンス分野のパイオニアの、二クラウス・ワースは、アルゴリズム+データ構造=プログラムと呼ばれている有名な本を書いている。",
    "output": "Niklaus Wirth, another pioneer in computer science, wrote a famous book called Algorithms + Data Structures = Programs."
  },
  {
    "index": "F1513",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今日、アルゴリズムを研究する別な理由は、アルゴリズムが自然を理解するための共通言語であるためです。",
    "output": "Another reason nowadays to study algorithms is that, they have become a common language for understanding, nature."
  },
  {
    "index": "F1514",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "アルゴリズムは計算モデルであり、科学的な疑問に対して、アルゴリズム的なモデルが数理モデルに置き換わってきているのです。",
    "output": "Algorithms are computational models, and algorithmic models are replacing mathematical models in scientific inquiry."
  },
  {
    "index": "F1515",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "20世紀は、数理科学者が数理モデルを開発し、自然現象を理解しようとしていました。",
    "output": "In the twentieth century, math, scientists developed mathematical models to try to understand natural phenomenon."
  },
  {
    "index": "F1516",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、まもなく、このような数理モデルでは、それを解決することが困難であるということが明らかになってきました。",
    "output": "It soon became clear that those mathematical models were difficult to solve."
  },
  {
    "index": "F1517",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "解答を出すのが困難なのは、自然現象に対する仮定を検証する必要があるためです。",
    "output": "It was difficult to create solutions, to be able to test hypotheses against natural phenomenon."
  },
  {
    "index": "F1518",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そのため、今日では数多くの人々がコンピュテーショナルモデルを作り、それを使って自然界で何が起きているのかシミュレーションし、より深い理解をしようとしているのです。",
    "output": "So, more and more and more now a days people are developing computational models, where they attempt to simulate what might be happening in nature in order to try to better understand it."
  },
  {
    "index": "F1519",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "アルゴリズムはこのプロセスの中で極めて重要な役割を果たしているのです。",
    "output": "Algorithms play an extremely important role in this process."
  },
  {
    "index": "F1520",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私たちもこのコースの中でいくつかの例を見ていくことにしましょう。",
    "output": "And we'll see some examples of this in this course."
  },
  {
    "index": "F1521",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もう一つの大切な理由は、効果、つまり、アルゴリズムとデータ構造の効率的な使い方を知っていれば、テクノロジー業界では就職面接でよりよいチャンスを得ることができることです。",
    "output": "Another important reason is that if you know effect, how to effectively use algorithms and data structures you're going to have a much better chance at interviewing for a job in the technology industry then if you don't."
  },
  {
    "index": "F1522",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このようにアルゴリズムを学ぶのには沢山の理由があるのです。",
    "output": "So, here's a bunch of reasons that I just went through for studying algorithms."
  },
  {
    "index": "F1523",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "アルゴリズムの影響は広く、至る所にいきわたっており、古い起源を持ち、最近の新しい機会も提供してくれます。他の方法では対処することができない問題を解決することができ、思考実験を通じて優秀なプログラマになることができるのです。",
    "output": "Their impact's broad and far-reaching, they have old roots and present new opportunities, they allow us to solve problems that could not otherwise be addressed, you can use them for intellectual stimulation to become a proficient programmer."
  },
  {
    "index": "F1524",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "世界中の生命の秘密の鍵を解き、楽しみや得になるものなのです。",
    "output": "They might unlock the secrets of life in the universe, and they're good for fun and profit."
  },
  {
    "index": "F1525",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実際、プログラマは尋ねることでしょう。なぜ他のことを学ぶのかと。",
    "output": "In fact, a pr ogrammer might ask, why study anything else?"
  },
  {
    "index": "F1526",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そう、他のことを学ぶのにもそれぞれ多くの理由がありますが、アルゴリズムを勉強しない理由はないと、自身を持って言うことができます。",
    "output": "Well, there's plenty of good reasons to study other things, but I'll submit there's no good reason not to study algorithims."
  },
  {
    "index": "F1527",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このコースのために、私たちは2つの材料を用意したので、その話をしましょう。コンテンツに入る前に、よく理解しておくようにしてください。",
    "output": "So, for this course we have two resources that I want to talk about and make sure that people are familiar with before entering into the content."
  },
  {
    "index": "F1528",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは、出版モデルでケヴィン・ウェインと私が開発し、長年使ってきたものです。このコースで提供する予定の講義のようなものを支援するとても効率的な方法だと思っています。",
    "output": "This is a publishing model that Kevin Wayne and I developed and have been using for many years, and we think it's a very effective way to support the, kinds of lectures that we're going to be giving in this course."
  },
  {
    "index": "F1529",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最後には、このコースでは必ずしも必要ではありませんが、テキストブックもあります。",
    "output": "Down at the bottom, and it's optional for this course, we have a text book."
  },
  {
    "index": "F1530",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "伝統的なテキストブックでコースのトピックを広くカバーしています。",
    "output": "It's a traditional, text book that extensively covers the topics in the course, in fact many more topics than we can present in lecture."
  },
  {
    "index": "F1531",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さらに、テキストをサポートする無料のオンライン教材もあり、ブックサイトと呼んでいます。",
    "output": "And then supporting that textbook, is free online material that we call the book site."
  },
  {
    "index": "F1532",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "テキストやブックサイトで講義のスライドを見ることができます。",
    "output": "You can go to books, the book site to see the lecture slides."
  },
  {
    "index": "F1533",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、より重要なのは、コードや練習問題、多くの情報がそこにはあるのです。",
    "output": "But more important, there's code, there's exercises, tere's a great deal of information there."
  },
  {
    "index": "F1534",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "事実、本にあるものの、約10倍にもなり、コンテンツの要約も含んでいます。",
    "output": "In fact, maybe ten times what's in the book, including a summary of the content."
  },
  {
    "index": "F1535",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "したがって、このコースの受講中は、頻繁にブックサイトを参照し、オンラインでの作業をすることになります。",
    "output": "So, during this course you'll be referring to the book site frequently while working online."
  },
  {
    "index": "F1536",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "受講条件についての質問も良く受けます。このコースではプログラミングができることを前提としており、基本的なループ処理や配列、関数について知っていることが必要です。",
    "output": "We're assuming that people who take this course know how to program, and know the basics of loops, arrays, functions."
  },
  {
    "index": "F1537",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "オブジェクト指向プログラミングや再帰についての知識が必要となるときもあります。",
    "output": "They have some exposure to object oriented programming and recursion."
  },
  {
    "index": "F1538",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "Javaを使いますが、Javaについて詳しく触れることはしません。例示のためのプログラミング言語として使用するだけです。",
    "output": "We use the Java language, but we don't dwell on details of Java, we mostly use it as an expository language."
  },
  {
    "index": "F1539",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "数学も使いますが、発展的なものではありません。",
    "output": "We do some math, but not advanced math."
  },
  {
    "index": "F1540",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このコースの前提としている事項を復習しておきたい場合は、本のセクション1.1と1.2を見ておくと良いでしょう。",
    "output": "If you want to review the material that we think is prerequisite for the material in this course, you can do a quick review by looking at sections 1.1 and 1.2 of the book."
  },
  {
    "index": "F1541",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ブックサイトでも、テキストブックでもどちらでもよいです。",
    "output": "Either at the book site or in the text book."
  },
  {
    "index": "F1542",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "詳しく復習しておきたい場合には、完全なテキストも用意しています。“IntroductiontoProgramminginJava:AnInterdisciplinaryApproach\"です。",
    "output": "If you want an in depth review, we have a full text book called, An Introduction to Programming in Java: An Interdisciplinary Approach."
  },
  {
    "index": "F1543",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "同様に、ブックサイトとテキストブックがあります。",
    "output": "There is a book site and text book as well."
  },
  {
    "index": "F1544",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、ボトムラインは、プログラムが書けることであり、準備ができているかどうか確認するには、自分のコンピュータでプログラムを書いてみることで、ブックサイトに載っているプログラミングモデルを使ってみるといいでしょう。",
    "output": "But, the bottom line is, you should be able t o program, and the quick exercise to get ready is, to write a java program on your computer perhaps using a programming model, as described on the book site."
  },
  {
    "index": "F1545",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さらに詳しい情報を提供する予定です。それで宿題にも対応できるようになるでしょう。",
    "output": "We will provide much more detail information on that as we get into the assignments."
  },
  {
    "index": "F1546",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そのほうがよければそれでよいですし、私たちのものをダウンロードして使うこともできます。",
    "output": "You can use your own programming environment if your comfortable with one or you download ours."
  },
  {
    "index": "F1547",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ウェブサイトに利用方法を載せてあります。",
    "output": "We have instructions on the web on how to do that."
  },
  {
    "index": "F1548",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今日お話するのは、はunionfind問題いわゆる動的接続問題を解くアルゴリズムのことです。",
    "output": "Welcome back to algorithms. Today, we're going to talk about the union find problem."
  },
  {
    "index": "F1549",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まず、二つの古典的なアルゴリズムから始めます。",
    "output": "A set of algorithms for solving the so-called dynamic connectivity problem. We'll look at two classic algorithms."
  },
  {
    "index": "F1550",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "QuickFIndとQuickUnionです。適用例を紹介し、これらのアルゴリズムの改良を考えてみます。",
    "output": "Quick Find and Quick Union, and some applications and improvements of those algorithms."
  },
  {
    "index": "F1551",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "本日の講義のサブテキストは使えるアルゴリズムを開発するためにこれから紹介する手順を繰り返し実施するということです。",
    "output": "The subtext of today's lecture really is to go through the steps that we'll follow over and over again to develop a useful algorithm."
  },
  {
    "index": "F1552",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最初のステップは問題のモデル化です。",
    "output": "The first step is to model the problem."
  },
  {
    "index": "F1553",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "基本的には解決すべき問題の主な要素がなんであるかを理解する必要があります。",
    "output": "Try to understand, basically, what are the main elements of the problem that need to be solved."
  },
  {
    "index": "F1554",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "すると問題を解決するアルゴリズムをいくつか発見するようになります。",
    "output": "Then we'll find some algorithm to solve the problem."
  },
  {
    "index": "F1555",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "多くの場合、多くの場合は最初に見つけたアルゴリズムが十分に高速で、メモリにも収まるものと思います。その場合は、どんどん先に進み、それを使っていけばよいでしょう。",
    "output": "In many cases, the first algorithm we come up with would be fast enough and maybe it fits in memory and, we'll go ahead and use it, and be off and running."
  },
  {
    "index": "F1556",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、他の多くの場合は、十分な速度を得られなかったり、メモリが不足したりします。",
    "output": "But in many other cases maybe it's not fast enough, or there's not enough memory."
  },
  {
    "index": "F1557",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そのようなときに、私たちがやるべきことは、原因を突き止め、問題の原因となっているものへの対処を検討し、新しいアルゴリズムを見つけ、満足できるまでこれを繰り返すのです。",
    "output": "So, what we do is try to figure out why, find a way to address whatever's causing that problem, find a new algorithm and iterate until we're satisfied."
  },
  {
    "index": "F1558",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これはアルゴリズムを設計、分析するときの科学的なアプローチです。そこでは、数理モデルを構築し、何が起きているのか理解し、モデルの確からしさを検証し、物事を改善する役に立つのです。",
    "output": "This is the scientific approach to designing and analyzing algorithms, where we build mathematical models to try and understand what's going on, and then we do experiments to validate those models and help us improve things."
  },
  {
    "index": "F1559",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まず最初に動的接続問題について、次にunion-findの問題のモデルついての話をします。",
    "output": "So, first we'll talk about the dynamic connectivity problem, the model of the problem for union find."
  },
  {
    "index": "F1560",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さて、次のように考えてみましょう。",
    "output": "So, here's the idea."
  },
  {
    "index": "F1561",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それらが何かは問題ではありません。",
    "output": "Doesn't really matter what they are."
  },
  {
    "index": "F1562",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "数字のゼロからnを使って、それらをモデル化します。",
    "output": "We're going to use the numbers, zero through N to model our objects."
  },
  {
    "index": "F1563",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "次に2つの間の接続について考えてみます。",
    "output": "And then, we have the idea of a connection between two objects."
  },
  {
    "index": "F1564",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "何かの命令が存在すると考えて、2つをつなぐことにするのです。",
    "output": "And, we'll, postulate that there's going to be a command that says, connect two objects."
  },
  {
    "index": "F1565",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "2つのものがあり、それらの間に接続を考えるのです。",
    "output": "Given two objects, provide a connection between them."
  },
  {
    "index": "F1566",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして、問題の重要な部分はクエリー、あるいは、一連のクエリーを見つけることで、そのクエリを使って、2つのものの間の経路があるかどうかを答えることができるのです。",
    "output": "And then key part of the problem is find query or the connected query, which just asks, is there a path connecting the two objects."
  },
  {
    "index": "F1567",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "例えば、この集合は10個の要素があり、既に多くのunion命令を実行して、4と3を、3と8を、6と5を、9と4を、2と1を接続しています。",
    "output": "So for example, in this set of ten objects, we performed already, a bunch of union commands, connecting four and three, three and eight, six and five, nine and four, two and one."
  },
  {
    "index": "F1568",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここで、クエリを発行し、0と7が接続されているかを問い合わせてみます。",
    "output": "And now we might have a connected query that says, is zero connect ed to seven?"
  },
  {
    "index": "F1569",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この場合は接続はありませんので、Noを答えることになります。",
    "output": "Well, in this case, there is no connection, so we say no."
  },
  {
    "index": "F1570",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、8と9の接続を問い合わせられたら、Yesを答えることになります。",
    "output": "But if we ask is eight connected to nine? We are going to say yes, even no we don't have a direct connection between eight and nine."
  },
  {
    "index": "F1571",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "8と9の間には直接の接続はありませんが、8から3へ、そして4へ、次に9へという経路が存在しているのです。",
    "output": "There is a path from eight to three to four to nine."
  },
  {
    "index": "F1572",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これが今回の問題で、与えられた集合に対してこれら二つの命令に公式に対応することなのです。",
    "output": "So, that's our problem, to be able to officially support these two commands for given set of objects."
  },
  {
    "index": "F1573",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここで、5と0のunionを追加します。",
    "output": "Now, let's say we add a union five, zero."
  },
  {
    "index": "F1574",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "5と0の間の接続をつくります。",
    "output": "So, that creates a connection between five and zero."
  },
  {
    "index": "F1575",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "7と2の間の接続を構築し、6と1の間の接続を構築します。",
    "output": "Seven and two creates a connection between seven and two."
  },
  {
    "index": "F1576",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここで、0と7は接続されているでしょうか?そうですね1と0もつなげることができます。",
    "output": "So, now if we ask our zero connected to seven, well one and zero we can do that too."
  },
  {
    "index": "F1577",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは冗長な接続ですね。",
    "output": "And that's a redundant connection."
  },
  {
    "index": "F1578",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここで0が7と接続されているかどうか質問されたら、答えはYesとなりますね。",
    "output": "And now, if we ask is zero connected to seven we're going to answer yes."
  },
  {
    "index": "F1579",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そう、これが今回の問題で、union命令と接続のクエリを組み合わせで、多数のものに対して、これらの命令を明確にサポートすること必要があるのです。",
    "output": "So that's our problem, intermix union, commands and connected queries and we need to be able to officially support those commands for a large number of objects."
  },
  {
    "index": "F1580",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここにより大きな例があります。",
    "output": "So, here's a much bigger example."
  },
  {
    "index": "F1581",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これに対しては効率的なアルゴリズムが必要となるのはわかりますね。",
    "output": "And you can see that we're going to need efficient algorithms for this."
  },
  {
    "index": "F1582",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まず最初に、コンピュータが必要ですね。",
    "output": "First of all, you can see we're going to need a computer for this."
  },
  {
    "index": "F1583",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "接続があるかどうかを人間が確かめるには、相当の時間かかります。",
    "output": "It would take quite, quite some time for a human to figure out whether there's a connection."
  },
  {
    "index": "F1584",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この場合は接続が存在します。",
    "output": "In this case there is a connection."
  },
  {
    "index": "F1585",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さて、アルゴリズムは、私たちが今日見るものですが、それは、2つのものを接続する経路を実際に与えるものではありません。",
    "output": "Now, the algorithms that we're looking at today are not going to actually give the path connecting the two objects."
  },
  {
    "index": "F1586",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ただ、問い合わせに答えるだけです。経路があるかどうかいうね。",
    "output": "It's just going to be able to answer the question, is there a path?"
  },
  {
    "index": "F1587",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "コースの第2部では、経路を明示的に発見するアルゴリズムを検討する予定です。",
    "output": "In part two of the course, we'll consider algorithms that explicitly find paths."
  },
  {
    "index": "F1588",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それらはunionfindほどは効率的なものではありません。なぜなら、やらないといけないことが多いですから。",
    "output": "They're not as efficient as union find because they have more work to do."
  },
  {
    "index": "F1589",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このアルゴリズムはいろんな種類のものに対して適用することができます。",
    "output": "Now, applications of these, these algorithms involve objects of all types."
  },
  {
    "index": "F1590",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "抽象的なものにも使われます、プログラムの変数名や数学の集合の要素などですね。複合材料の金属部位のような物理的なものにも使われます。",
    "output": "These are used for digital photos, where the objects are pixels they're used for networks, where the objects are computers, social networks, where it's people, or computer chips, where it's circuit elements or abstract things like variable names in a program, or elements in a mathematical set, or physical things like metallic sites in a composite system."
  },
  {
    "index": "F1591",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そのため、どんな種類のものに対しても、プログラミングのためには、それぞれの対象に対する名前をつける必要があります。ここでは対象を数字、0からN-1までの整数で識別することにします。",
    "output": "So, all different types of objects for, but for programming we're going to associate each object with a name and we'll just name the objects with a number, integers from zero to N-1."
  },
  {
    "index": "F1592",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "プログラミングの最初の出発点としてはとても便利です。整数を配列のインデックスとして使うことができますから、すると、各対象に関連する情報に簡単にアクセスすることができますね。",
    "output": "That's a very convenient initial starting point for our programs because we can use integers as an index into an array then, and then quickly access information relevant to each object."
  },
  {
    "index": "F1593",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "また、unionfindに関係ない詳細な事項を省略することができます。",
    "output": "And it also just supresses a lot of details that are not relevant to union find."
  },
  {
    "index": "F1594",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実際、対象の名前から0からN-1の整数に対するマッピングは、シンボルテーブルや探索アルゴリズムへの応用にみることができます。探索アルゴリズムはこのコースでも後ほど問題を解くためのアルゴリズムやデータ構造について学習する予定です。",
    "output": "In fact, to make this mapping from an object name to the integer zero through N - one is to find application of a symbol table or a searching algorithm, which is one of the things that we'll be studying later in this course algorithms and data structures for solving that problem."
  },
  {
    "index": "F1595",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さて、接続は満たすべき2,3の抽象的な性質があります。",
    "output": "Now, the connections, well, we need, a few abstract properties that these connections have to satisfy."
  },
  {
    "index": "F1596",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "みな、自然で直観的なものばかりです。",
    "output": "And they're all quite natural and intuitive."
  },
  {
    "index": "F1597",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "\"接続されている\"というのは同値関係と仮定します。",
    "output": "So we assume that is connected to is an equivalence relation."
  },
  {
    "index": "F1598",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり、すべての対象は自分自身と接続されています。対称であるとします。",
    "output": "That is, every object's connected to itself, it's symmetric."
  },
  {
    "index": "F1599",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり、PがQと接続されているならば、QはPと接続されているということです。また、推移的です。",
    "output": "If P's connected to Q, then Q's connected to P, and it's transitive."
  },
  {
    "index": "F1600",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "PとQが接続され、QとRが接続されているなら、PとRは接続されているということです。",
    "output": "If P's connected to Q, and Q's connected to R, then P's connected to R."
  },
  {
    "index": "F1601",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これらの性質はとても直観的ですね。",
    "output": "Now these properties are very intuitive."
  },
  {
    "index": "F1602",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、それらを明示して、われわれのアルゴリズムがそれを満たしていることを保証するのは重要なことです。",
    "output": "But it's worthwhile to state them explicitly and make sure that our algorithms maintain them."
  },
  {
    "index": "F1603",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "同値関係があれば、対象と接続の集合が接続コンポーネントという部分集合に分割することができます。",
    "output": "When we have an equivalence relation a set of objects and connections divide into subsets called connected components."
  },
  {
    "index": "F1604",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "たとえば、ここに簡単な例を挙げましょう。3つの接続コンポーネントがありますね。",
    "output": "For example in this small example here, there's three connected components."
  },
  {
    "index": "F1605",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "1つ目は、対象0しかありません。2つ目は1と4と5があります。",
    "output": "One consisting of just object zero, second one objects one, four and five."
  },
  {
    "index": "F1606",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "3つ目には、残りの4つの対象があります。",
    "output": "And third one the other four objects."
  },
  {
    "index": "F1607",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これらのコンポーネントはそこに含まれるどの2つの対象も接続されていて、外側にはこれらの対象に接続されている対象がないとき、接続されたコンポーネントであるといいます。",
    "output": "And these components have the property that if any two objects in them are connected and there is no object outside that is connected to those objects, that's connected components."
  },
  {
    "index": "F1608",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今回のアルゴリズムは接続コンポーネントを維持して、効率性を確保する予定であり、その知識を利用して、提示されたクエリに効率的に答えを返すことができるのです。いいですね。",
    "output": "Our algorithms will gain efficiency by maintaining connected components and using that knowledge to efficiently answer the query that's, that they're presented with."
  },
  {
    "index": "F1609",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では、この操作を実装するためには、クエリコマンドとunionコマンドを見つける必要があります。",
    "output": "Okay, so to implement the operations, we have to find query and the union command."
  },
  {
    "index": "F1610",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "また、接続コンポーネントを維持する必要があるのです。",
    "output": "And so we're going to mai ntain the connected components."
  },
  {
    "index": "F1611",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "findコマンドは2つのオブジェクトが同じコンポーネントに入っているかどうかをチェックする必要があり、unionコマンドは2つのオブジェクトを含むコンポートをその合併、union、で置換するのです。",
    "output": "The find is going to have to check if two objects are in the same component and the union command is going to have to replace components containing two objects with their union."
  },
  {
    "index": "F1612",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "例えば、このようなコンポーネントで、2と5を接続するunionコマンドが発行されたとしています。",
    "output": "So, for example, if we have these components, and we get the command to union connect, two and five."
  },
  {
    "index": "F1613",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このときには必ず、2を含む接続コンポーネントと5を含む接続コンポーネントを併合して、1つの接続コンポーネントにします。そうして、接続コンポーネントを2つだけにします。",
    "output": "Essentially, we need to merge the connected components containing the one containing two or the one containing five to get a big connected components and now we have only two connected components."
  },
  {
    "index": "F1614",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これで、プログラミングで必要となる、データ型をきめて、問題を解くために実装する必要があるメソッドの仕様を考えることができるようになりました。",
    "output": "All of that leads up to, in a programming world to specifying, a data type which is simply specification of the methods that we are want to going to implement in order to solve this problem."
  },
  {
    "index": "F1615",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "典型的なJavaモデルでは、まず最初に、UFというクラスを作り、そこに2つのメソッド、1つはunionメソッドを実装し、もう一つは、bool値を返すconnectedメソッドを実装します。",
    "output": "So you know, typical Java model, what we will do is create a class called UF that contains two methods, one to implement union, the other one to implement connected, which returns a boolean."
  },
  {
    "index": "F1616",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "コンストラクターは、SR単位をとり、対象の数を表すものですが、対象の数を応じたデータ構造を構築します。",
    "output": "The constructor, takes SR unit, the number of objects, so that it can build data structure based on the number of objects."
  },
  {
    "index": "F1617",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここで、対数オーダーで構築するように気をつける必要があります。対象の数が多くなることもありますし、操作の数についても同様です。",
    "output": "So, and we have to, bear in mind, as we're building our logarithms, that both the number of objects can be huge, but also, the number of operations."
  },
  {
    "index": "F1618",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "unionやconnectedのオペレーションは非常に多くなることがありますので、このアルゴリズムは、このような状況でも効率的である必要があるのです。",
    "output": "We can have a, a very large number, of union and connected, operations and our algorithms are going to have to be efficient, under those conditions."
  },
  {
    "index": "F1619",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このコースでよく従うプラクティスの一つが、APIの設計をチェックすることです。問題に深く入りこむ前に、クライアントプラグラムを作って、開発しているデータ型を使ってみるのです。",
    "output": "One of the practices that will follow often in this course is to check our API design before getting too far into dealing with the problem, by building a client that is going to use the data type that we develop."
  },
  {
    "index": "F1620",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今回の例では、標準入力から情報を読み取るクライアントを作りました。",
    "output": "So, for this example, we've got a client that, Will read information from standard input."
  },
  {
    "index": "F1621",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最初に、整数、これは処理すべき対象の数を表します。",
    "output": "First, an integer which is the number of objects that are going to be processed."
  },
  {
    "index": "F1622",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "次に、一連の対象の名前のペアを処理します。",
    "output": "And then a series of pairs of object names."
  },
  {
    "index": "F1623",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "クライアントプログラムがやることは、まず、整数を標準入力からリードして、UFオブジェクトを生成します。",
    "output": "And what the client does is it, it'll, first it'll read the integer from standard input, and create a, a UF object."
  },
  {
    "index": "F1624",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "次に標準入力が空になるまで、入力から2つの整数を読み込み、次に、それらが接続されていなければ、それらを接続し、プリントアウトします。",
    "output": "And then as long as standard input is not empty, it's going to read two integers from the input. And if they're not connected, then it'll connect them and print them out."
  },
  {
    "index": "F1625",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "接続されている場合は、無視します。",
    "output": "If they are connected it'll ignore."
  },
  {
    "index": "F1626",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これがテストクライアントプログラムで、このテストクライアントでどのような実装でも期待するように動作することを確認することができるのです。",
    "output": "So, that's our test client and that's a fine test client to make sure that any implementation does what we expect that it will."
  },
  {
    "index": "F1627",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これで準備はできました。プログラムとして実装したいことはすべて説明し、実装が機能するかどうかを確認するクライアントプログラムも作ることができます。",
    "output": "We've described the operations we want to implement all the way down to code and we have client code that we're going to have to be able to service with our"
  },
  {
    "index": "F1628",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "動的接続問題を解くアルゴリズムの最初の実装を見てみましょう。",
    "output": "Now we'll look at our first implementation of an algorithm for solving the dynamic connectivity problem, called Quick-find."
  },
  {
    "index": "F1629",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これはいわゆる欲張りアルゴリズムで、接続問題をとくことが出来ます。",
    "output": "This is a so called eager algorithm, for solving kind activity problem."
  },
  {
    "index": "F1630",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "アルゴリズムで使っているデータ構造は対象でインデックス化された整数配列です。",
    "output": "The data structure that we're going to use to support the algorithm is simply an integer array indexed by object."
  },
  {
    "index": "F1631",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "PとQの2つの対象が接続されているということは、配列の中の2つのエントリが同じであり、かつ、そのときに限ると考えることが出来ます。",
    "output": "The interpretation is the two objects, P and Q are connected if and only if, their entries in the array are the same."
  },
  {
    "index": "F1632",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今回の10個の対象の例では、配列idで7つの接続が出来た後の状況を示しており、スライドの中央に示しています。",
    "output": "So for example in this example with our ten objects the idea array that describes the situation after seven connections is illustrated in the middle of the slide."
  },
  {
    "index": "F1633",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "で、ここでは、0、5、6はすべて同じ接続コンポーネントに含まれています。なぜなら、それらは同じ配列のエントリ、0になっているからです。",
    "output": "So that, after the, at this point zero, five, and six are all in the same connected component, because they have the same array entry, zero."
  },
  {
    "index": "F1634",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "1、2、7も皆、エントリが1で、3、4、8、9はすべてエントリが8になっています。",
    "output": "And three, four, eight, and nine all have entry eight."
  },
  {
    "index": "F1635",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり、このようにして、接続されていることを示しているのです。",
    "output": "So that representation is, shows that they're connected."
  },
  {
    "index": "F1636",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "また明らかに。findの操作に対する高速な実装をサポートすることができます。",
    "output": "And clearly, that's going to support a quick implementation of the find operation."
  },
  {
    "index": "F1637",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "配列のエントリをチェックして、それらが等しいかどうかを見ればよいですね。",
    "output": "We just check the array entries to see if they're equal."
  },
  {
    "index": "F1638",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "PとQが同じIDを持っているのかをチェックするのです。",
    "output": "Check if P and Q have the same ID."
  },
  {
    "index": "F1639",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そう、6と1は違うIDになっています。",
    "output": "So, six and one have different IDs."
  },
  {
    "index": "F1640",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "1のIDは1で6のIDは0です。",
    "output": "One has ID one, six has ID zero."
  },
  {
    "index": "F1641",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この2つは同じ接続コンポーネントの中には含まれていないということです。",
    "output": "They're not in the same connected component."
  },
  {
    "index": "F1642",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "unionはもう少し難しく、与えられた2つの対象を含むコンポーネントを併合する必要があります。",
    "output": "Union is more difficult in order to merge the components, containing two given objects."
  },
  {
    "index": "F1643",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "エントリがどちらかのIDに等しいID場合は、もう片方のIDniすべて変更する必要があるのです。",
    "output": "We have to change all the entries, whose ID is equal to one of them to the other one."
  },
  {
    "index": "F1644",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そのときにはPと同じものをすべてQと同じになるように変更する必要があります。",
    "output": "And arbitrarily we choose to change the ones that are the same as P to the ones that are same as Q."
  },
  {
    "index": "F1645",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "6と1を連結するときは、0、5、6のエントリを変更する必要があります。",
    "output": "So if we're going to union six and one, then we have to change entries zero, five, and six."
  },
  {
    "index": "F1646",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "6と同じ接続コンポーネントにあるもの全部です。",
    "output": "Everybody in the same connected component as six."
  },
  {
    "index": "F1647",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "0から1に変更します。",
    "output": "From zero to one."
  },
  {
    "index": "F1648",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは、皆さんもわかると思いますが、対象の数が非常に大きくなるときには、ちょっと問題になります。",
    "output": "And this is, as we'll see, this is a bit of a problem when we have a huge number of objects, because there's a lot of values that can change."
  },
  {
    "index": "F1649",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "なぜかというと、たくさんの値を変更することになるからです。",
    "output": "But still, it's easy to implement, so that'll be our starting point."
  },
  {
    "index": "F1650",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、それでも簡単に実装できるので、これを最初のスタート地点にします。",
    "output": "So we'll start with a, a demo of how this works."
  },
  {
    "index": "F1651",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そう、最初は、配列idを準備して、各エントリはそのインデックスと等しくなっています。",
    "output": "So, initially, we set up the ID array, with each entry, equal to its index."
  },
  {
    "index": "F1652",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "こらは、すべての対象が独立であるということです。",
    "output": "And so all that says is that all the objects are independent."
  },
  {
    "index": "F1653",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "皆、自分自身の接続コンポーネントに入っているということですね。",
    "output": "They're in their own connected component."
  },
  {
    "index": "F1654",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さあ、ここでunionオペレーションを受け取ると、そうですね、4が3と接続されるとします。",
    "output": "Now, when we get a union operation."
  },
  {
    "index": "F1655",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "すると、すべてのエントリ、IDが1番目のIDと同じIDのものをすべて、2番目のIDに変更します。",
    "output": "Then we're going to change, all entries, whose ID is equal to the first ID to the second one."
  },
  {
    "index": "F1656",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この場合は、3と4を接続するということは、4を3に変更する必要があります。そして、もう少し続けてみましょう。",
    "output": "So in this case, we'll change the, connect three and four means that we need to change the four to a three."
  },
  {
    "index": "F1657",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "するとどのようにしているのかを理解するようになってきます。",
    "output": "And we'll continue to do a few more so you'll get an idea of how it works."
  },
  {
    "index": "F1658",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "3と83と8を接続するために、こんどは3と4を8と接続する必要があります。",
    "output": "So three and eight now so to connect three and eight now three and four have to be connected to eight."
  },
  {
    "index": "F1659",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これらのエントリをすべて8に変更する必要があります。",
    "output": "So both of those entries have to change to eight."
  },
  {
    "index": "F1660",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "いいですか?",
    "output": "Okay?"
  },
  {
    "index": "F1661",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今度は、6と5はどうでしょう?",
    "output": "So now, what about six and five?"
  },
  {
    "index": "F1662",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今度も1番目のエントリを変更して、2番目と会わせる必要があります。",
    "output": "So again, we change the first one to match the second one."
  },
  {
    "index": "F1663",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そうです、6と5を接続するには、6を5に変更します。",
    "output": "So to connect six and five, we change the six to a five."
  },
  {
    "index": "F1664",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "9と4はどうでしょうか?",
    "output": "What about nine and four?"
  },
  {
    "index": "F1665",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今度も変更する必要がありますね、9と4を接続するのですから、9のエントリを4と同じにする必要があります。",
    "output": "So, now we have to change the, to connect nine and four, we have to change, 9's entry to be the same as 4's."
  },
  {
    "index": "F1666",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これで、3、4、8、9ができました。",
    "output": "So now we have three, four, eight, and nine."
  },
  {
    "index": "F1667",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "皆、エントリが8になっています。",
    "output": "All have entries eight."
  },
  {
    "index": "F1668",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "同じ接続コンポーネントに入っていることになりますね。",
    "output": "They're all on the same connected component."
  },
  {
    "index": "F1669",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "2と1についても、2を1に変更して接続します。",
    "output": "Two and one means that we connect two and one by changing the 2201."
  },
  {
    "index": "F1670",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "8と9は、もう接続されています。",
    "output": "Eight and nine are already connected."
  },
  {
    "index": "F1671",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "配列idのエントリがもう同じですから。",
    "output": "They have the same, entries in the idea array."
  },
  {
    "index": "F1672",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "接続のクエリ、findは真を返します。既に接続されています。",
    "output": "So, that connected query, that find says, true, they're already connected."
  },
  {
    "index": "F1673",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "5と0のエントリは違っています。",
    "output": "And five and zero have different entries."
  },
  {
    "index": "F1674",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "接続されていないということですから、この場合は偽を返します。接続されていないということです。",
    "output": "They're not connected, so we'd return false, in that case, not connected."
  },
  {
    "index": "F1675",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もし、5と0を接続したいのであれば、同じように、5と6の両方の対応するエントリを0に変更すればよいですね。",
    "output": "And then, if we want to connect five and zero. Then, as usual we'll connect, the entry corresponding to both five and six to zero."
  },
  {
    "index": "F1676",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "7と2は、7と2を接続しましょう。",
    "output": "Seven and two, union seven and two."
  },
  {
    "index": "F1677",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは簡単ですね。",
    "output": "That's an easy one."
  },
  {
    "index": "F1678",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "6と1を接続してみます。今度は3つのエントリを変更する必要があります。",
    "output": "And union, six and one so there is three entries that have to get changed."
  },
  {
    "index": "F1679",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "すべて0になっているのを1に変更する必要があります。",
    "output": "All those zeros have to get changed to ones."
  },
  {
    "index": "F1680",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "quickfindのデモを見てみました。",
    "output": "So, that's a quick demo of Quick-find."
  },
  {
    "index": "F1681",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今度は、これを実装したプログラムを見てみましょう。",
    "output": "Now next we'll look at the code for implementating that."
  },
  {
    "index": "F1682",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "デモを頭に浮かべておくと、このアルゴリズムをプログラミングするのはきっと単純だと思います。",
    "output": "Okay, with this concrete demo in mind then moving to coding up this algorithim is pretty straight forward."
  },
  {
    "index": "F1683",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "とても面白いプログラミングの練習で、最初は多くの人が間違えます。",
    "output": "Although it's an interesting programming exercise that a lot of us would get wrong the first time."
  },
  {
    "index": "F1684",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では、コンストラクターからはじめます。プライベートな整数配列があります。",
    "output": "So let's start with the constructor, well we have a, a private integer array."
  },
  {
    "index": "F1685",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これが、id配列です。",
    "output": "That's our ID array."
  },
  {
    "index": "F1686",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このデータ構造を使って、実装を進めることになります。",
    "output": "That's the data structure that's going to support this implementation."
  },
  {
    "index": "F1687",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "コンストラクターは配列を生成し、配列のインデックスに対応した値をセットしていきます。i番目の配列にはiをセットします。",
    "output": "The constructor has to create the array and then go through and set the value corresponding to each index I to I."
  },
  {
    "index": "F1688",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "findオペレーション、あるいは、connectedオペレーションです。",
    "output": "The find operation, or connected operation."
  },
  {
    "index": "F1689",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは簡単ですね。",
    "output": "That's the easy one ."
  },
  {
    "index": "F1690",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これが、quickfindアルゴリズムです。",
    "output": "This is the Quick-find algorithm."
  },
  {
    "index": "F1691",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "2つの引数、PとQをとって、id配列のエントリが等しいかどうかをチェックして、その結果を返します。",
    "output": "So it simply takes its two arguments, P and Q, and checks whether their ID entries are equal, and returns that value."
  },
  {
    "index": "F1692",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "等しければ、真を返し、異なるときは偽を返します。",
    "output": "If they're equal, it returns true. If they're not equal, it returns false."
  },
  {
    "index": "F1693",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "複雑なオペレーションを実装しているのはunionです。",
    "output": "The more complicated operation implement is a union."
  },
  {
    "index": "F1694",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そこでは、まず、一番目の引数に対応するidを見つけ、次に二番目の引数に対応するidを見つけます。",
    "output": "And there, we find first the ID corresponding with the first argument, and then the ID corresponding to the second argument."
  },
  {
    "index": "F1695",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "次に、すべての配列を探索して、一番目の引数のidと等しいidのエントリを探し、そこに二番目の引数のidをセットするのです。",
    "output": "And then we go through the whole array, and looking for the entries whose IDs are equal to the ID of the first argument, and set those to the ID of the second argument."
  },
  {
    "index": "F1696",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これはちょっと愚直な実装ですね。",
    "output": "That's a pretty straightforward implementation."
  },
  {
    "index": "F1697",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "多くの人が間違いをおかすといいましたね。",
    "output": "And I mentioned that a lot of us would get us wrong."
  },
  {
    "index": "F1698",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここで犯しやすい間違いは、ここに、一番目に取り出した値でなく、Pのidをセットしまうことです。",
    "output": "The mistake we might make is to put ID of P here rather than first picking out, that value."
  },
  {
    "index": "F1699",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さて、これがquickfindの実装です。",
    "output": "And you can think about the implications of that. That's an insidious bug."
  },
  {
    "index": "F1700",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "次に考えるのは、アルゴリズムがどれくらい効率的であるかということです。",
    "output": "So, that's a fine implementation of QuickFind so the next thing to decide is how effective or efficient that algorithm is going to be and we'll talk in some detail about how to do that but for this it's sufficient to just think about the number of times the code has to access the array."
  },
  {
    "index": "F1701",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実行してわかるのは、初期化とunion操作の両方がforループを含んでいて、配列をすべて走査しています。",
    "output": "As we saw when doing the implementation, both the initialized and union operations involved the for-loop that go through the entire array."
  },
  {
    "index": "F1702",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "したがって、配列のエントリにアクセスした後、一定のn倍の比率でアクセスする必要があります。",
    "output": "So they have to touch in a constant proportional to n times after touching array entry."
  },
  {
    "index": "F1703",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "findオペレーションは高速で、配列のエントリに対するチェックは、コンスタントな回数です。",
    "output": "Find Operation is quick, it's just to a constant number of times check array entries."
  },
  {
    "index": "F1704",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは問題で、union操作のコストが大きすぎるのです。",
    "output": "And this is problematic because the union operation is too expensive."
  },
  {
    "index": "F1705",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "特にn個の対象に対して、n個のunionコマンドがあるときは、合理的でないことが明らかです。",
    "output": "In particular if you just have N union commands on N objects which is not unreasonable."
  },
  {
    "index": "F1706",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それぞれが接続されているか、そうでないかのいずれかで平方的な時間という二次関数的な時間が必要になるのです。",
    "output": "They're either connected or not then that will take quadratic time in squared time."
  },
  {
    "index": "F1707",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このコースを通して、繰り返し登場するテーマの一つが、二次関数的な時間は非常に遅いということです。",
    "output": "And one of the themes that we'll go through over and over in this course is that quadratic time is much to slow."
  },
  {
    "index": "F1708",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "大規模な問題では、二次関数時間のアルゴリズムは適用することはできません。",
    "output": "And we can't accept quadratic time algorithms for large problems."
  },
  {
    "index": "F1709",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "なぜなら、スケールしないからです。",
    "output": "The reason is they don't scale."
  },
  {
    "index": "F1710",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "コンピュータがより高速に、大規模なものになっても、二次関数的なアルゴリズムは実際はどんどん遅くなるのです。",
    "output": "As computers get faster and bigger, quadratic algorithms actually get slower."
  },
  {
    "index": "F1711",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "簡単に私が意図していることをお話しておきます。",
    "output": "Now, let's just talk roughly about what I mean by that."
  },
  {
    "index": "F1712",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "非常にラフな基準ですが、コンピュータは毎秒何十億もの命令を実行することができ、メモリには何十億ものエントリを格納することができます。",
    "output": "A very rough standard, say for now, is that people have computers that can run billions of operations per second, and they have billions of entries in main memory."
  },
  {
    "index": "F1713",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり、メモリ上のすべてのエントリに約1秒以内でアクセスすることができます。",
    "output": "So, that means that you could touch everything in the main memory in about a second."
  },
  {
    "index": "F1714",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このような不思議なことに、このような基準が50~60年もの間用いられてきました。",
    "output": "That's kind of an amazing fact that this rough standard is really held for 50 or 60 years."
  },
  {
    "index": "F1715",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "コンピューターはより大きくなりましたが、同時により高速にもなったので、メモリを全部アクセスするのに2、3秒ですむというものです。",
    "output": "The computers get bigger but they get faster so to touch everything in the memory is going to take a few seconds."
  },
  {
    "index": "F1716",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "メモリ上にあるのが数千ワードのであれば正しいですし、数十億、それ以上の場合でも大丈夫です。",
    "output": "Now it's true when computers only have a few thousand words of memory and it's true now that they have billions or more."
  },
  {
    "index": "F1717",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ですからコンピューターはこのようなものだとしましょう。",
    "output": "So let's accept that as what computers are like."
  },
  {
    "index": "F1718",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは、巨大なメモリ空間があれば、巨大な問題を解決することができるということです。",
    "output": "Now, that means is that, with that huge memory, we can address huge problems."
  },
  {
    "index": "F1719",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "数十億の対象がある場合も、そこで数十億のunionコマンドを実行することは期待できるでしょう。",
    "output": "So we could have, billions of objects, and hope to do billions of union commands on them."
  },
  {
    "index": "F1720",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、問題はquickfindアルゴリズムで、10の18乗のオペレーション、あるいは、配列への操作やメモリアクセスが必要になるのです。",
    "output": "And, but the problem with that quick find algorithm is that, that would take ten^18th operations, or, say array axises or touching memory."
  },
  {
    "index": "F1721",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "簡単な計算で、三十数年もの計算時間となることがわかります。",
    "output": "And if you do the math, that works out to 30 some years of computer time."
  },
  {
    "index": "F1722",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "現在のコンピューターでこのような問題を解くことは現実的ではないですね。",
    "output": "Obviously, not practical to address such a problem on today's computer."
  },
  {
    "index": "F1723",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "また、理由、問題は二次関数的なアルゴリズムが技術に対してスケールしないことです。",
    "output": "And, and the reason is, and the problem is that quadratic algorithms don't scale with technology."
  },
  {
    "index": "F1724",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "十倍の速さの新しいコンピュータがあれば、十倍の大きさの問題を解決しようとします。",
    "output": "You might have a new computer that's ten times as fast but you could address a problem that's ten times as big."
  },
  {
    "index": "F1725",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、二次関数的なアルゴリズムを使うと、十倍遅くなってしまうのです。",
    "output": "And with a quadratic algorithm when you do that. It's going to be ten times as slow."
  },
  {
    "index": "F1726",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このような状況を回避するために、より効率的なアルゴリズムを開発し、このような問題を解く必要があるのです。",
    "output": "That's the kind of situation we're going to try to avoid by developing more efficient algorithms for solving problems like this."
  },
  {
    "index": "F1727",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さて、高速findは巨大な問題には遅すぎます。",
    "output": "All right so QuickFind is too slow for huge problems."
  },
  {
    "index": "F1728",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では、どうやってより良く実行しましょうか?",
    "output": "So, how are we going to do better?"
  },
  {
    "index": "F1729",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最初に、高速unionと呼ばれる代替案を試します。",
    "output": "Our first attempt is an alternative called, Quick-union."
  },
  {
    "index": "F1730",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは、いわゆる遅延評価のアプローチで、する必要があるまで仕事をしないでおくというものです。",
    "output": "This is so called lazy approach to algorithm design where we try to avoid doing work until we have to."
  },
  {
    "index": "F1731",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このアルゴリズムでは、サイズMの同じデータ構造、配列IDを使いますが、今度は異なる解釈をします。",
    "output": "It uses the same data structure or array ID with size M but now it has a different interpretation."
  },
  {
    "index": "F1732",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私たちは、この配列をフォレストと呼ばれる木の集合として解釈します。",
    "output": "We are going to think of that array as representing a set of trees that's called a forest as depicted at right."
  },
  {
    "index": "F1733",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "スライドの右に示したようなものです。",
    "output": "So, each entry in the array is going to contain a reference to its parent in the tree."
  },
  {
    "index": "F1734",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "配列の各要素は、木の親への参照を含んでいます。たとえば、3の親は4で、4の親は9です。",
    "output": "So, for example, 3's parent is four, 4's parent is nine."
  },
  {
    "index": "F1735",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここで、配列の各要素はルートに関連付けられています。",
    "output": "Now each entry in the array has associated with it a root."
  },
  {
    "index": "F1736",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "各要素の木のルートです。",
    "output": "That's the root of its tree."
  },
  {
    "index": "F1737",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "要素は、すべてそれ自体が自分につながったコンポーネントなので、自分自身を指しています。ですので1は1を指しています。",
    "output": "Elements that are all by themselves in just, in their own connected component, point to themselves, so one points to itself but also nine points to itself."
  },
  {
    "index": "F1738",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは木のルートであり、2と4と3を含んでいます。",
    "output": "It's the root of the tree, containing two, four and three."
  },
  {
    "index": "F1739",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり、このデータ構造から、各要素とルートとを関連付けることができます。",
    "output": "So, from this data structure we can associate with each item a root, which is representative, say, of it's connected component."
  },
  {
    "index": "F1740",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "接続されたコンポーネントを代表するのがルートと言うことですね。ですので、3のルートは9です。",
    "output": "So that's the root of three is nine, going up that root."
  },
  {
    "index": "F1741",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さて、いったんルートが計算できればfind操作は実装できます。接続されているか確かめようとしている2要素が同じルートを持っているかを確かめれば良いだけです。",
    "output": "Now, once we can calculate these roots, then we can implement the find operation just by checking whether the two items that we're supposed to check with are connective where they have the same root."
  },
  {
    "index": "F1742",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは、同じ接続コンポーネントを持っているか、というのと同じことです。",
    "output": "That's equivalent to saying, are they in the same connective component?"
  },
  {
    "index": "F1743",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "各要素のルートを探すのは少し作業がいりますが、unionはとても簡単です。",
    "output": "So that's some work, going to find the roots of each item but the union operation is very easy."
  },
  {
    "index": "F1744",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "2つの異なる要素を含んだコンポーネントを結合するには、ここでの2要素は異なるコンポーネントと考えられますが、PのルートIDをQのルートIDに設定するだけで良いです。",
    "output": "Two items that are in different components. All we do is set the ID of P's route to the ID of Q's route."
  },
  {
    "index": "F1745",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ではPの木をQを指すようにしましょう。",
    "output": "Let's make P's tree point to Q."
  },
  {
    "index": "F1746",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この場合では、9のエントリを6にすることで、3と5とを結合します。",
    "output": "So in this case, we would change the entry of nine to be six to merge three and five."
  },
  {
    "index": "F1747",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この木は3と5を含んでいますので。",
    "output": "The components containing three and five."
  },
  {
    "index": "F1748",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして、配列内の1つの値を変更するだけで2つの大きなコンポーネントを結合できます。",
    "output": "And with just changing one value in the array we get the two large components emerged together."
  },
  {
    "index": "F1749",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これが高速unionアルゴリズムです。",
    "output": "That's the Quick-union algorithm."
  },
  {
    "index": "F1750",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "なぜなら、union操作が配列内の1要素を変更するだけで良いからです。",
    "output": "Because a union operation only involves changing one entry in the array."
  },
  {
    "index": "F1751",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "find操作は少し作業が必要です。",
    "output": "Find operation requires a little more work."
  },
  {
    "index": "F1752",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それでは実装を見てみましょう。まず1つの操作例をデモで見てみます。",
    "output": "So let's look at the Implementation, a demo of that one in operation first."
  },
  {
    "index": "F1753",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでは、繰り返しになりますが、同じ方法で開始しますが、配列の要素の考え方はそれぞれの要素が小さな木になっており、ノードは自分自身を指していると考えます。",
    "output": "So again we, we start out the same way but now the idea array entry really means that every one of these things is a little tree where the one node each everyone pointing to itself."
  },
  {
    "index": "F1754",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "自分自身の木のルート、ということです。ここで、4を3を同じコンポーネントに入れる必要があれば1番目の要素の入ったコンポーネントのルートを取り出し、これを2番目の要素の入ったコンポーネントのルートの子とすれば良いだけです。",
    "output": "It's the root of it's own tree so now if we have to put four and three in the same component, then all we do is we take the root, of the component containing the first item and make that a child of the root of the component, component containing the second item."
  },
  {
    "index": "F1755",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この場合では、4の親を3とするだけです。",
    "output": "In this case we just make four as parent three."
  },
  {
    "index": "F1756",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それから3と8。",
    "output": "So now three and eight."
  },
  {
    "index": "F1757",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでも繰り返しますが、最初の要素を取り出し、それを2番目の要素を含んだ木のルートの子とします。",
    "output": "So again, we take the first item and make it a child of the root of the tree containing the second item."
  },
  {
    "index": "F1758",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ですので、3,4,8が同じコンポーネント内にあることになります。",
    "output": "So now three, four, and eight are in the same component."
  },
  {
    "index": "F1759",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "6と5ですね。",
    "output": "Six and five six goes below five."
  },
  {
    "index": "F1760",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "6が5の下に付きます。",
    "output": "Nine and four, So now four is the root of the tree containing four is eight."
  },
  {
    "index": "F1761",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここで、4は4を含んだ木のルートは8で、9を含んだ木のルートは8ですので、9を8の子とします。",
    "output": "And the root of tree containing nine is nine. And so we make nine a child of eight."
  },
  {
    "index": "F1762",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "2と1ですね。これは簡単です。",
    "output": "Two and one, that's an easy one."
  },
  {
    "index": "F1763",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここで、8と9が接続されているかチェックを受ければ、それらが同じルートを持つかどうかだけチェックします。",
    "output": "Now if we get our, our eight and nine connected, we just checked that they have the same root and they both have the same root eight and so they're connected."
  },
  {
    "index": "F1764",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "5と4の場合、4のルートは8です。",
    "output": "Five and four 4's root is eight."
  },
  {
    "index": "F1765",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "5はルートが5ですから違います。",
    "output": "5's root is five."
  },
  {
    "index": "F1766",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "5と0ですね。",
    "output": "Five and zero."
  },
  {
    "index": "F1767",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "5が0の子になります。",
    "output": "Five goes to be a child of zero."
  },
  {
    "index": "F1768",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "7が2のルートである1の子になります。",
    "output": "Seven and two seven goes to be a child of 2's root which is one."
  },
  {
    "index": "F1769",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "6と1ですね。",
    "output": "Six and one."
  },
  {
    "index": "F1770",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "6のルートは0で1は自分がルートなので、0がその子になります。",
    "output": "6's route is zero 1's its own route, so zero becomes a child of one."
  },
  {
    "index": "F1771",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "union操作の1つ1つが単純に配列の1要素を変更するだけです。",
    "output": "Each one of these union operations just involves changing one entry in the array."
  },
  {
    "index": "F1772",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最後に7と3ですね。",
    "output": "And finally, seven and three."
  },
  {
    "index": "F1773",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "7のルートは1で3のルートは8ですので、1が8の子となります。",
    "output": "So seven's root is one, three's root is eight, one becomes a child of eight."
  },
  {
    "index": "F1774",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これで1つのコンポーネントを得、すべての要素がつながりました。",
    "output": "Okay and now we have one connected component with all the items together."
  },
  {
    "index": "F1775",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では高速unionの実装コードを見てみましょう。",
    "output": "Alright, so now let's look at the code for implementing Quick-union."
  },
  {
    "index": "F1776",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "コンストラクタは同じです。",
    "output": "The constructor is the same as the other one."
  },
  {
    "index": "F1777",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "配列を作り、各要素が自分自身をルートに設定します。",
    "output": "We create the array and then set each element to be it's own root."
  },
  {
    "index": "F1778",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "iがiのID値と等しくなるまで親への参照を追いかけます。等しくなければ、iを木の一段上に移動させます。",
    "output": "Now we have a private method that implements this process of finding the root by chasing parent pointers until we get to the point where I is equal to ID of I, and if it's not equal, we just move I up one level in the tree, set I equals ID of I and return it."
  },
  {
    "index": "F1779",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ですので、どのノードから始めてもID値がiのID値と等しいものになるまで追いかけ、つまりルートにたどり着きます。これはprivateメソッドでありfindおよびconnected操作の実装に使用します。",
    "output": "So starting at any node, you just follow ID equals ID of I until they're equal and then you're at a root and that's a private method that we can use to implement the find operation or the connected operation."
  },
  {
    "index": "F1780",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "同じかどうかのチェックには、PのルートとQのルートを見つければよいだけです。",
    "output": "You just find the root of P and the root of Q and if you check if they're equal."
  },
  {
    "index": "F1781",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "union操作は簡素化しており、2つの要素のルートを探し、第1引数のIDを第2引数のそれに設定するだけです。",
    "output": "And then the union operation is simply find the two roots I and then set the idea the first one could be the second one."
  },
  {
    "index": "F1782",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "高速findよりコード量は少ないです。forループがありません。",
    "output": "Actually less code than for Quick Find, no fore loops."
  },
  {
    "index": "F1783",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "少し心配する必要のあるwhileループが一個ありますが。",
    "output": "There's this one wild loop that we have to worry about a little bit."
  },
  {
    "index": "F1784",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、これは高速でエレガントなコード実装で、動的接続問題を解くものです。高速unionと呼ばれます。",
    "output": "But that's a quick and elegant implementation of code to solve the dynamic connectivity problem called Quick-union."
  },
  {
    "index": "F1785",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それでは、このコードが大きな問題に対して効率的かを見ていきましょう。",
    "output": "So now we're going to have to look at can this code be effective for large problems?"
  },
  {
    "index": "F1786",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まぁ、残念ながら高速unionは速いのですが、同時に遅すぎるのです。",
    "output": "Well unfortunately Quick-union is faster but it's also too slow."
  },
  {
    "index": "F1787",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "数倍速いこともありますが、数倍遅すぎることもあるのです。",
    "output": "And it's a little different kind of too slow then for Quick Find, there's times when it could be fast, but there's also times when it could be too slow."
  },
  {
    "index": "F1788",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "高速unionの欠点は、木がとても高くなってしまうことがあることです。",
    "output": "And the defect for Quick-union is that the trees can get too tall."
  },
  {
    "index": "F1789",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これはつまり、find操作がとても高くついてしまうということです。",
    "output": "Which would mean that the find operation would be too expensive."
  },
  {
    "index": "F1790",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "各オブジェクトは次の要素を指しているだけですから底にあるオブジェクトに対するfind操作は木をすべて上っていく処理になります。",
    "output": "Of each object just pointing to next and then to do a find operation for object at the bottom would involve going all the way through the tree."
  },
  {
    "index": "F1791",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "コストは、単にfind操作を行うだけで配列のアクセス量が増えてしまいます。たくさん操作をすれば遅すぎるでしょう。",
    "output": "Costing involving in the ray axises just to do the find operation and that's going to be too slow if you have a lot of operations."
  },
  {
    "index": "F1792",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "良いでしょう。",
    "output": "Okay."
  },
  {
    "index": "F1793",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私たちは高速なUnionおよびFindアルゴリズムを見てきました。",
    "output": "So, we've looked at the quick union and quick find algorithms."
  },
  {
    "index": "F1794",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "どちらも実装は簡単ですが、巨大な接続問題をサポートできません。",
    "output": "Both of which are easy to implement."
  },
  {
    "index": "F1795",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では、どのように改善したら良いでしょうか?",
    "output": "So, how are we going to do better?"
  },
  {
    "index": "F1796",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それを次に見ていきます。",
    "output": "That's what we'll look at next."
  },
  {
    "index": "F1797",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "非常に効果的な改善案は、重み付けと呼ばれるものです。",
    "output": "A very effective improvement, it's called weighting."
  },
  {
    "index": "F1798",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このコースのようなアルゴリズムの講義を見ると出会っていたかもしれませんね。",
    "output": "And it might have occurred to you while we are looking at these algorithms."
  },
  {
    "index": "F1799",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "考え方としては、高速なUnionアルゴリズムを実装する際に段階を踏んで、高い木を作らないようにすることです。",
    "output": "The idea is to when implementing the quick union algorithm take steps to avoid having tall trees."
  },
  {
    "index": "F1800",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "大きな木と小さな木とを接続させるとき、試したいことは大きな木を下に付けないようにすることです。",
    "output": "If you've got a large tree and a small tree to combine together what you want to try to do is avoid putting the large tree lower, that's going to lead to long tall trees."
  },
  {
    "index": "F1801",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これを実装するのには比較的簡単なやり方があります。",
    "output": "And there's a relatively easy way to do that."
  },
  {
    "index": "F1802",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "付いているオブジェクトの数をそれぞれの木で追跡しておき、バランスを維持するようにします。小さい方の木のルートを大きい方の木のルートに必ず接続するようにすることで実現します。",
    "output": "What we'll do is we'll keep track of the number of objects in each tree and then, we'll maintain balance by always making sure that we link the root of the smaller tree to the root of the larger tree."
  },
  {
    "index": "F1803",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これで、私たちは最初の状況、大きい方の木が下に来る、という状況を回避できます。",
    "output": "So, we, we avoid this first situation here where we put the larger tree lower."
  },
  {
    "index": "F1804",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "重み付けアルゴリズムでは、常に小さい木が下に来ます。",
    "output": "In the weighted algorithm, we always put the smaller tree lower."
  },
  {
    "index": "F1805",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では、どのように実装するのかを見てみましょう。",
    "output": "How we, let's see how we implement that."
  },
  {
    "index": "F1806",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まずデモを見ましょう。",
    "output": "Let's see a demo first."
  },
  {
    "index": "F1807",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "最初は通常の開始状態と同じところから始めます。それぞれが自分自身の木にいます。",
    "output": "Okay, so again start out in our normal starting position, where everybody's in their own tree."
  },
  {
    "index": "F1808",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "2つのアイテムしか接続しない場合は、従来と同じように動きます。",
    "output": "And for when there's only two items to link it, it works, works the same way as before."
  },
  {
    "index": "F1809",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、ここで要素8を4と3に接続する際には、8を子にします。",
    "output": "But now, when we have eight to merge with four and three, we put the eight as the child, no matter which order their arguments came, because it's the smaller tree."
  },
  {
    "index": "F1810",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "引数順に関係なく、8の方が小さい木だからです。",
    "output": "So, six and five doesn't matter, whichever one goes down doesn't matter."
  },
  {
    "index": "F1811",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "9と4ですが、9の方が小さい木で、4の方が大きい木ですから、9が下に置く木になります。",
    "output": "Nine and four, so now, nine is the small one four is the big one."
  },
  {
    "index": "F1812",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "2と1、5と0。",
    "output": "Two and one, five and zero."
  },
  {
    "index": "F1813",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここで、5の方が大きい木ですから、0が下に来ます。",
    "output": "So now, five and zero five is in the bigger tree so zero goes below."
  },
  {
    "index": "F1814",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "7と2ですが、2の方が大きい木ですので7が下に来ます。",
    "output": "Seven and two, two is in the bigger tree so seven goes below."
  },
  {
    "index": "F1815",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "6と1ですが、これらは同じ大きさの木ですね。",
    "output": "Six and one they're in equal size trees."
  },
  {
    "index": "F1816",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして7と3ですが、3の方が小さい木ですので、下につきます。",
    "output": "And seven and three, three is in the smaller tree so it goes below."
  },
  {
    "index": "F1817",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このように、重み付けアルゴリズムでは小さい方の木が必ず下に配置されます。",
    "output": "So, the weighted algorithm always makes sure that the smaller tree goes below."
  },
  {
    "index": "F1818",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここで、再びすべてのオブジェクトを表現する1本の木に巻き取りましたが、今度は、ある保証があります。",
    "output": "And again, we wind up with a single tree representing all the objects."
  },
  {
    "index": "F1819",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つい先ほどお話ししたとおり、ルートから遠く離れた要素は存在しない、ということです。",
    "output": "But this time, we h ave some guarantee that no item is too far from the root and we'll talk about that explicitly in a second."
  },
  {
    "index": "F1820",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これが、重み付け高速Unionを行った効果を示した例です。ここでは、同じUnionコマンドを行った際に、小さい方の木が常に下に置かれるようになっています。",
    "output": "So, here's an example that shows the effect of doing the weighted quick union where we always put the smaller tree down below for the same set of union commands."
  },
  {
    "index": "F1821",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは100のサイトに88回Union操作を行ったものです。",
    "output": "This is with a hundred sites and 88 union operations."
  },
  {
    "index": "F1822",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "上の例では大きな木があり、中に少しの木とノードがあり、ルートからとても離れていますね。",
    "output": "You can see in the top the big tree has some trees, some nodes, a fair distance from the root."
  },
  {
    "index": "F1823",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "下の例では、重み付けアルゴリズムの場合で、ノードはすべてルートから4の距離までしか離れていません。",
    "output": "In the bottom, for the weighted algorithm all the nodes are within distance four from the root."
  },
  {
    "index": "F1824",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ルートからの平均距離はずっとずっと小さいのです。",
    "output": "The average distance to the root is much, much lower."
  },
  {
    "index": "F1825",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "Javaの実装を見て、詳しいところを、定量的な情報を見てみましょう。",
    "output": "Let's look at the Java implementation and then we'll look in more detail at, at that quantitative information."
  },
  {
    "index": "F1826",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私たちは同じデータ構造を使いますが、今回は追加の配列が必要です。これは、各要素について、その要素に到達するまでのツリー内のオブジェクト数を与えます。",
    "output": "So, we used the same data structure except, now we need an extra array, that for each item, gives the number of objects in the tree routed at that item."
  },
  {
    "index": "F1827",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "findの実装は高速unionと同じです。ルートが同一かどうかをチェックするだけです。",
    "output": "Find implementation is identical to for quick union, you're just checking whether the roots are equal."
  },
  {
    "index": "F1828",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "union操作については、サイズをチェックするコードを変更します。",
    "output": "For the union implementation, we're going to modify the code to check the sizes."
  },
  {
    "index": "F1829",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それぞれの場合で、小さい方の木のルートを大きい方の木のルートに接続します。",
    "output": "And link the root of the smaller tree to the root of the larger tree in each case."
  },
  {
    "index": "F1830",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "idのリンクを変更した後、size配列も変更します。",
    "output": "And then after changing the id link, we also change the size array."
  },
  {
    "index": "F1831",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "idをiからjの子に変更したら、jの木のサイズをiの木のサイズだけ増やします。",
    "output": "If we make id, i a child of j, then we have to increment the size of j's tree by the size of i's tree."
  },
  {
    "index": "F1832",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "逆の場合では、iの木のサイズをjの木のサイズ分だけ増やす必要があります。",
    "output": "Or if we do the other way around, then we have to increment the size of i's tree by the size of j's tree."
  },
  {
    "index": "F1833",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "白地になっているところが高速union全体のコードです。",
    "output": "So, that's the full code in white for implementing quick union."
  },
  {
    "index": "F1834",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それほどコードは大きくないですが、ずっと良いパフォーマンスが得られます。",
    "output": "So, not very much code but much, much better performance."
  },
  {
    "index": "F1835",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実際、数学的に実行時間を分析できます。定義した操作を行う時間は、ノードがどれだけ木の深い位置にあるかに比例しますがどのノードも木の深さが高々底が2のlogNに収まることが保証されていることが分かります。",
    "output": "In fact we can analyze the running time mathematically and show that defined operation, it takes time proportional to how far down the trees are in the node in the tree, the nodes are in the tree, but we can show that it's guaranteed that the depth of any node in the tree is at most the logarithm to the base two of N."
  },
  {
    "index": "F1836",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここでlgは底が2のlogを常に表します。",
    "output": "We use the notation Lg always for logarithm to the base two."
  },
  {
    "index": "F1837",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ですので、Nが1000なら10ですし、百万なら20、10億なら30です。",
    "output": "And, and, so for, if N is a thousand, that's going to be ten, if N is a million that's twenty, if N is a billion that's 30."
  },
  {
    "index": "F1838",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "Nに比べれば非常に小さな数です。",
    "output": "It's a very small number compared to N."
  },
  {
    "index": "F1839",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ではこの証明を見てみましょう。",
    "output": "So, let's look at the proof of that."
  },
  {
    "index": "F1840",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このコースでは、時々数学的証明をします。今回のように重要な場面では。",
    "output": "We do some mathematical proofs in, in this course when they're critical such as this one."
  },
  {
    "index": "F1841",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "なぜ、どのノードxについても高さが高々底が2のlogNになるのでしょうか。",
    "output": "And why is it true that the depth of any node x is, at most, log base two of N?"
  },
  {
    "index": "F1842",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "理解する鍵は、任意のノードの深さが増加するのはどんなときなのかどんなときに木を深くたどることになるのかを正確に見ていくことです。",
    "output": "Well, the key to understanding that is to, take a look at exactly when does the depth of any node increase?"
  },
  {
    "index": "F1843",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この図に示すT1という木が他の木に結合するとき、Xの深さは1増加します。この図ではT2ですね。",
    "output": "The x's depth will increase by one, when its tree, T1 in this diagram, is merged into some other tree, T2 in this diagram."
  },
  {
    "index": "F1844",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このとき、T2の大きさがT1より大きいか等しいときときだけ結合が行われると言えます。",
    "output": "Well, at that point we said we only do that if the size of T2 was bigger than the or equal to size of T1."
  },
  {
    "index": "F1845",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ですので、Xの深さが増加するときには木のサイズは少なくとも2倍になります。",
    "output": "So, when the depth of x increases, the size of its tree at least doubles."
  },
  {
    "index": "F1846",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "Xを含む木のサイズは、最大でもlogN回で倍になります。なぜなら1から始めてlogN回だけ2倍していけばNに到達し、木にはN個のノードしかないことになるからです。",
    "output": "So, that's the key because that means that the size of the tree containing x can double at most log N times because if you start with one and double log N times, you get N and there's only N nodes in the tree."
  },
  {
    "index": "F1847",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これが任意のノードXの深さは高々底が2のlogNだという大まかな証明の流れです。",
    "output": "So, that's a sketch of a proof that the depth of any node x is at most log base two of N."
  },
  {
    "index": "F1848",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この事実が、このアルゴリズムの性能に深い影響を与えています。",
    "output": "And that has profound impact on the performance of this algorithm."
  },
  {
    "index": "F1849",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここで、初期化は常にNに比例する時間がかかりますが、union、結合、find操作は底が2のlogNに比例します。",
    "output": "Now instead of the initialization always takes time proportional to N. But now, both the union and the connected or find operation takes time proportional to log base two of N."
  },
  {
    "index": "F1850",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これがスケールできるアルゴリズムです。",
    "output": "And that is an algorithm that scales."
  },
  {
    "index": "F1851",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "Nが100万から10億に増えたとしても、計算コストは20から30に増えるだけです。これならとても受け入れられるものです。",
    "output": "If N grows from a million to a billion, that cost goes from twenty to 30, which is quite not acceptable."
  },
  {
    "index": "F1852",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "さて、このアルゴリズムは実装がとても簡単で実行もすぐ終わりますが、通常はアルゴリズムのデザインを変えると、性能を上げることができるということが理解できます。",
    "output": "Now, this was very easy to implement and, and we could stop but usually, what happens in the design of algorithms is now that we understand what it is that gains performance, we take a look and see, well, could we improve it even further."
  },
  {
    "index": "F1853",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この場合、もっとずっと簡単に改良できます。",
    "output": "And in this case, it's very easy to improve it much, much more."
  },
  {
    "index": "F1854",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そのアイディアはパス圧縮です。",
    "output": "And that's the idea of path compression."
  },
  {
    "index": "F1855",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このアイディアとは、与えられたノードを含んだ木のルートを探そうとするとき、そのノードからルートまでのすべてのノードを触っています。",
    "output": "And this idea is that, well, when we're trying to find the root of the tree containing a, a given node."
  },
  {
    "index": "F1856",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "その際に、通った各ノードがルートを指すようにしてしまうのが良いでしょう。",
    "output": "We're touching all the nodes on the path from that node to the root."
  },
  {
    "index": "F1857",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そうしない理由もないですから。",
    "output": "There's no reason not to."
  },
  {
    "index": "F1858",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ですので、ノードPのルートを探そうと検索しているとき、探し終わった後でそのまま戻って、パス上のノードはすべてルートを指すようにします。",
    "output": "So when we're looking, we're trying to find the root of, of P."
  },
  {
    "index": "F1859",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "一定量の追加コストはかかるでしょうが、いったんルートを見つけたらパスを持ち上げて、木をより平坦にしていきます。",
    "output": "That's going to be a constant extra cost. We went up the path once to find the root."
  },
  {
    "index": "F1860",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そうしないでおく理由がないでしょう。",
    "output": "And the reason would be, no reason not to do that."
  },
  {
    "index": "F1861",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "驚くことに、木を平坦化するためのコードは1行です。",
    "output": "We had one line of code to flatten the tree, amazingly."
  },
  {
    "index": "F1862",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実際、1行のコードで1つの変数だけで、パス内の他のノードすべてを2世代前のノードを指すようにできます。",
    "output": "Actually to make a one liner code, we use a, a simple variant where we make every other node in the path point to its grandparent on the way up the tree."
  },
  {
    "index": "F1863",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実際には、全体を平坦化するよりは良くないですが、十分良いものです。",
    "output": "Now, that's not quite as good as totally flattening actually in practice that it actually is just about as good."
  },
  {
    "index": "F1864",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このように、1行足すだけで木を概ね完全に平坦化できます。",
    "output": "So, with one line of code, we can keep the trees almost completely flat."
  },
  {
    "index": "F1865",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このアルゴリズムを、人々は重み付けアルゴリズムを発見してから比較的早く見つけ出しかなり本コースの範囲を外れるほど解析がイライラするものだと判明していますが、この例に触れることで、簡単なアルゴリズムであっても面白く、複雑な解析が必要なものになることを示しました。",
    "output": "Now, this algorithm people discovered rather early on after figuring out the weighting and it turns out to be fascinating to analyze quite beyond our scope. But we mentioned this example to illustrate how even a simple algorithmah, can have interesting and complex analysis."
  },
  {
    "index": "F1866",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "Hopcroft,Ulman,Tarjanによると、N個オブジェクトがある場合、M個のunion-find操作をすると配列を高々c(N+Mlg*N)回しか触らないことが証明されています。",
    "output": "And what was proved by Hopcroft Ulman and Tarjan was that if you have N objects, any sequence of M union and find operations will touch the array at most a c (N + M lg star N) times."
  },
  {
    "index": "F1867",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "lg*Nは変わった関数で、logN個の中から1を取得するのにかかる回数を指します。",
    "output": "And now, lg N is kind of a funny function."
  },
  {
    "index": "F1868",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実世界では、この値は5より小さいと考えておくのが最善です。",
    "output": "It's the number of times you have to take the log of N to get one."
  },
  {
    "index": "F1869",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ですので、重み付け高速Unionで、パス圧縮を施した方式の実行時間は、実世界では線形になるでしょう。",
    "output": "And the way to think, it's called the iterated log function."
  },
  {
    "index": "F1870",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして、もっと興味深いアッカーマン関数と呼ばれる関数まで改良できるでしょう。この関数はlg*よりもずっと遅くしか値が増えていきません。",
    "output": "And in the real world, it's best to think of that as a number less than five because lg two^ 65536 is five."
  },
  {
    "index": "F1871",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このアルゴリズムは線形に近づいてきているので、N×時間に比例するようになるように見えます。",
    "output": "So, that means that the running time of weighted quick union with path compression is going be linear in the real world and actually could be improved to even a more interesting function called the Ackermann function, which is even more slowly growing than lg."
  },
  {
    "index": "F1872",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "成長の遅い関数×Nではなくて、です。",
    "output": "And another point about this is it so close to being linear that is t ime proportional to N instead of time proportional to N times the slowly growing function in N."
  },
  {
    "index": "F1873",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "人々は、長い時間それを探していて、そのようなアルゴリズムは実際には存在しないことが証明できました。",
    "output": "And people, looked for a long time for that, and actually it works out to be the case that we can prove that there is no such algorithm."
  },
  {
    "index": "F1874",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ですので、私たちが使っているアルゴリズムの背後にはたくさんの理論があり、その理論を知ることは重要であり、実際どのアルゴリズムを選べば良いか、どこにより良いアルゴリズムを用いようと努力を傾けるかを決める手助けになります。",
    "output": "And it's important for us to know that theory and that will help us decide how to choose which algorithms we're going to use in practice, and where to concentrate our effort in trying to find better algorithms."
  },
  {
    "index": "F1875",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "FriedmanとSachsによって、このunion-find問題を解くアルゴリズムに線形時間で終わるものがないと証明されたのは驚きです。",
    "output": "It's amazing fact that was eventually proved by Friedman and Sachs, that there is no linear time algorithm for the union find problem."
  },
  {
    "index": "F1876",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかし、パス圧縮付きの重み付けアルゴリズムは実用上は巨大は問題を解くことができるようになるには十分です。",
    "output": "But weighted quick union with path compression in practice is, is close enough that it's going to enable the solution of huge problems."
  },
  {
    "index": "F1877",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では、動的接続問題を解くアルゴリズムについてのまとめです。",
    "output": "So, that's our summary for algorithms for solving the dynamic connectivity problem."
  },
  {
    "index": "F1878",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "重み付けアルゴリズムとパス圧縮を用いると、他のアルゴリズムでは対応ができなかった問題を解くことができます。",
    "output": "With using weighted quick union and with path compression, we can solve problems that could not otherwise be addressed."
  },
  {
    "index": "F1879",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "たとえば、10億個オブジェクトがあって10億回操作があった場合、前に述べたように、30年かかるでしょう。",
    "output": "For example, if you have a billion operations and a billion objects I said before it might take thirty years."
  },
  {
    "index": "F1880",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それを6秒で行うことができます。",
    "output": "We can do it in six seconds."
  },
  {
    "index": "F1881",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このアルゴリズムについて認識する上で最も重要なことは、アルゴリズムのデザイン如何で問題を解くことができる、ということです。",
    "output": "Now, and what's most important to recognize about this is that its the algorithm design that enables the solution to the problem."
  },
  {
    "index": "F1882",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "高速なコンピュータを持ってきてもあまり役に立ちません。",
    "output": "A faster computer wouldn't help much."
  },
  {
    "index": "F1883",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "あるいは2ヶ月とかかもしれませんね。しかし、高速なアルゴリズムを用いれば皆さんのPCでも数秒で解くことができるのです。",
    "output": "You could spend millions on a super computer, and maybe you could get it done in six years instead of 30, or in two months but with a fast logarithm, you can do it in seconds, in seconds on your own PC."
  },
  {
    "index": "F1884",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ジョンズ・ホプキンス・データ・サイエンス・トラックへようこそ。",
    "output": "Welcome to the Johns Hopkins Data Science Track."
  },
  {
    "index": "F1885",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして続く9ヶ月の間にあなたがどこまで辿り着く事になるか、についてお話するのは。",
    "output": "I'm incredibly excited to tell you a little bit about the track and about where you're going to be going over the next nine months."
  },
  {
    "index": "F1886",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私はジェフ・リークといいます、ジョンズ・ホプキンス大学ブルームバーグ公衆衛生大学院の教授です。",
    "output": "My name is Jeff Leek, and I'm a professor in the Johns Hopkins Bloomberg School of Public Health."
  },
  {
    "index": "F1887",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この入門ビデオを私の好きな合衆国大統領の一人,テディ・ルーズベルトの名言から始めたいと思います。",
    "output": "I thought I'd lead off this introductory video with a quote by one of my favorite US Presidents, Teddy Roosevelt."
  },
  {
    "index": "F1888",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "彼は言いました。『重要なのは,あれこれと批判する人ではない。",
    "output": "He said it's not the critic who counts."
  },
  {
    "index": "F1889",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "実際に仕事を行っている人が,どんな風に間違っているとか,へまをしているとか,そういったことを指摘する人ではないのだ。",
    "output": "It's not the person who points out how the person who's actually doing things is doing them wrong or messing up."
  },
  {
    "index": "F1890",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そうではなく,障害を乗り越え,実際に仕事をやり遂げようとした人たちなのだ。",
    "output": "It's the person who's actually trying to get things done, even when there are obstacles in the way."
  },
  {
    "index": "F1891",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "』そして現在の多くのデータサイエンスでは,大きくて汚いデータを扱う際に遭遇する多くの困難を乗り越えてやり遂げることができるようになってきています。",
    "output": "And a lot of data science right now is being able to push through a lot of the difficulties that you have when you're dealing with either large or messy data."
  },
  {
    "index": "F1892",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それには,データの収集,クリーニング,それからそのデータから新しい情報を引き出すための新しい分析技術の構築が含まれます。",
    "output": "It includes collecting the data clean them up and then building new announced techniques that exploring new information about that data."
  },
  {
    "index": "F1893",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして,これらの全てのステップは少々複雑であり,何か新しく,興味深いことをしようとした際,批判にさらされることもあります。",
    "output": "And so, all of those steps are a little bit complicated and sometimes it opens you to criticism when you're trying to do something new and interesting."
  },
  {
    "index": "F1894",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ですので,たとえ批判されることになっても、そういったことを勇敢にやり遂げようとすることが重要だ、と教えてくれる警句から始めたかったのです。",
    "output": "And so I wanted to lead with a quote that said it's important to strive the valiantly do these sorts of things, even if you're going to take some criticism."
  },
  {
    "index": "F1895",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "データサイエンスにおける鍵となる挑戦についてはダン・マイヤーのこの警句に本当によくまとめられています。",
    "output": "So the key challenge in data science is actually really nicely summed up in this quote by Dan Myer."
  },
  {
    "index": "F1896",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "『振り返ってみてください,これまでの人生で,解く価値があるような問題を解くときに,前もって全ての情報が与えられていた,なんてことがあったでしょうか?",
    "output": "He says, ask yourselves, what problem you, have you ever solved, ever, that was worth solving, where you knew all of the given information in advance?"
  },
  {
    "index": "F1897",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "情報が過剰なために,フィルターをかける必要もなく,あるいは情報が足りないために,探しに行かなくてもよかったような?",
    "output": "Where you didn't have a surplus of information and have to filter some of it out, or you didn't have insufficient information and have to go find some?"
  },
  {
    "index": "F1898",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "』そして私は,これはけだし名言だと思います。データサイエンスでは,これこそが通常起こっていることだからです。",
    "output": "And so, I think that this is a kind of a critical quote because, in data science, this is usually what is going on."
  },
  {
    "index": "F1899",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "自分が興味を持っている疑問に答えるのに十分なデータを持っておらず,それらを調査しなければならないかもしれません,ウェブや他の場所で調べるということです。",
    "output": "You're either in a situation where you really don't have enough data to answer the question that you're interested in, and you have to go out and try to search for it, find it on the web, or find it in other places."
  },
  {
    "index": "F1900",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "あるいは,過剰なデータによって困惑させられ,適当でない情報をフィルターにかけて除くことで,自分の疑問に合わせたものに限定しなければなりません。",
    "output": "Or you're in a situation where you are overwhelmed with a surplus of data and you have to filter out all of the irrelevant information to try to narrow in on your question."
  },
  {
    "index": "F1901",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "皆さんは今,いずれの場合にも私が「疑問」と口にしたことに気付かれたでしょう。",
    "output": "And you'll notice that I said question in both of those cases."
  },
  {
    "index": "F1902",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私の考えでは,これは,データサイエンスにおける我々の哲学の中心に位置するものです。",
    "output": "And I think this goes to the heart of our philosophy about data science."
  },
  {
    "index": "F1903",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "私たちは,データによって,疑問に答えることに興味があるのです。",
    "output": "We're interested in answering questions with data."
  },
  {
    "index": "F1904",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "疑問がはじめにあって,データは後からついてくるのです。このことは,それをさらに挑戦的にします。",
    "output": "We think the question should come first and then the data should follow after."
  },
  {
    "index": "F1905",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "なぜなら,皆さんはあるデータによって,ある疑問に答えることができるかもしれませんが,そうでない場合もあるからです。",
    "output": "And that actually makes it more challenging, because sometimes, you can answer a question with some data but you might not be able to answer your question with some data."
  },
  {
    "index": "F1906",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "皆さんが手持ちのデータで解きたいと思うような疑問に、です。",
    "output": "So this track is about refocusing on answering the question that you're interested in solving with the data that you have."
  },
  {
    "index": "F1907",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ここで,このコース・トラックを通して担当する講師について少し,ご紹介します。",
    "output": "So I thought I'd tell you a little bit about the instructors that you'll be hearing from throughout the course of this, course track."
  },
  {
    "index": "F1908",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "我々は皆,ジョンズ・ホプキンス大学の生物統計学科のブルームバーグ公衆衛生大学院の教員です。",
    "output": "So we are all faculty in the Johns Hopkins Blumberg School of Public Health in the Biostatistics Department."
  },
  {
    "index": "F1909",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "我々は生物学や医学における大量のデータを使う統計学に従事している,と言えるでしょう。",
    "output": "And you could say that we all do data intensive statistics in biology and medicine."
  },
  {
    "index": "F1910",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ブライアン・カフォは脳の統計学に従事,つまり脳の画像データを解析しています。",
    "output": "Brian Caffo works on the statistics of brain, analyzing brain imaging data."
  },
  {
    "index": "F1911",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして私はゲノムデータの解析の統計学に従事しています。",
    "output": "And I work on the statistics of analyzing genomics data."
  },
  {
    "index": "F1912",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ロジャー・ペンは微粒子状物質の解析の統計学に従事しています。",
    "output": "And Roger Peng works on the statistics of analyzing fine particulate matter."
  },
  {
    "index": "F1913",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "我々は皆,データがきれいで良く,扱いやすい,とは限らない問題を扱っています。",
    "output": "All of us work on problems where the data aren't always clean and nice and easy to handle."
  },
  {
    "index": "F1914",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "我々は皆,答えたいと思っている疑問が複雑で,いくつかの部分に分割して扱う必要のあるようなものを扱っています。",
    "output": "All of us work on problems where the questions that we want to answer are complicated and you have to break them down into parts."
  },
  {
    "index": "F1915",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして我々は皆,人類の健康に資するような疑問に適切な答えを得ようと,熱意をもって取り組んでいるのです。",
    "output": "And all of us, sort of, work on questions where we're very passionate about trying to get the right answer so that we can help people in human health."
  },
  {
    "index": "F1916",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかしながら,この講座で皆さんが学ぶ技術は生物学や医学に限定されるものではありません。",
    "output": "But the techniques that you're going to be learning about are not exclusive to biology and medicine."
  },
  {
    "index": "F1917",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは,利用可能なデータ量が最近になって突如増加した一分野に過ぎないのです。",
    "output": "That's just one area where there's been a recent upsurge in the amount of data that's available."
  },
  {
    "index": "F1918",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ではなぜデータサイエンスなのでしょうか?",
    "output": "So why data science?"
  },
  {
    "index": "F1919",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "なぜ皆さんはこのプログラムを履修するのでしょうか?",
    "output": "Why should you take this program?"
  },
  {
    "index": "F1920",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これはエコノミスト誌の表紙です。",
    "output": "This is a cover of The Economist now."
  },
  {
    "index": "F1921",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "今となっては少し古く,2,3年も前の話題です。",
    "output": "It's a little bit old I guess ancient history from a couple of years ago."
  },
  {
    "index": "F1922",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかしながら,これはデータの大洪水のお話で,実際,本当のことですが、ここ何年かにわたって,データは実に,実に安く集められるようになりました。",
    "output": "But it talks about the data deluge and it's really true. Over the last several years data has become much, much cheaper to collect."
  },
  {
    "index": "F1923",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "蓄積も簡単になっています。",
    "output": "It's much easier to store."
  },
  {
    "index": "F1924",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして現在,非常に多くの無料の計算ツールが世に出ており,皆さんは実際に全ての科学やビジネスの分野を襲いつつあるこのデータの大洪水を使って何事かをなすことができるのです。",
    "output": "And there's so many free computing tools out there right now, that you can actually do something with this entire data deluge that's sort of assaulting all different areas of science and business."
  },
  {
    "index": "F1925",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "話題は変わりますが,ビッグデータという用語を聞いたことがあるでしょう。",
    "output": "So the other thing is that you've probably heard the term big data."
  },
  {
    "index": "F1926",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この講座,データサイエンティストの道具箱,を通じて,我々がビッグデータについて考えていることを少し詳しくお話しします。",
    "output": "And so we'll hear a little bit more about what we think about big data throughout the course of this particular course, the Data Scientist's Toolbox."
  },
  {
    "index": "F1927",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかしビッグデータは,実に最先端と言えるものです。これまで持ちえなかった分野のデータを持っている,という意味で。",
    "output": "But big data is, sort of a new frontier in the sense that, we have data in areas that we didn't used to have that data."
  },
  {
    "index": "F1928",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "全世界の人々の自動車からのGPS座標の情報へのアクセスなんてできませんでした。",
    "output": "We didn't have access to information about GPS coordinates from cars from everybody in the entire world."
  },
  {
    "index": "F1929",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "一人ひとりのゲノム情報をシーケンスすることもできませんでした。",
    "output": "It wasn't possible to sequence everybody's genome."
  },
  {
    "index": "F1930",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして現在,これらはすべて可能となりました。",
    "output": "And now that's all possible."
  },
  {
    "index": "F1931",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "こういったデータにアクセスできるようになり,従来不可能であった疑問に答えることが,可能となりました。",
    "output": "So we have access to this data and it allows us to answer questions we never could before."
  },
  {
    "index": "F1932",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "というわけで,今,本当に刺激的な瞬間であり,皆さんはそれに取組み,そういった疑問に答えるためにデータを使用できる,一員なのです。",
    "output": "So, it's an incredibly exciting time, and you're somebody who can get in there and use that data to answer those questions."
  },
  {
    "index": "F1933",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ではなぜ,統計的データサイエンスなのでしょうか?",
    "output": "So why statistical data science?"
  },
  {
    "index": "F1934",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "皆さんお気づきのように,この講座の講師はすべて生物統計の教授ですので,このデータサイエンス・トラックは明らかに幾分,統計学的な傾向を持っています。",
    "output": "You'll notice that we're, all of your instructors are biostatistics professors and so this will, this data science track will obviously have a little bit of a statistical bend."
  },
  {
    "index": "F1935",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "統計学とはデータから学ぶ科学であると。",
    "output": "I think that that's appropriate given that statistics is the science of learning from data."
  },
  {
    "index": "F1936",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "何の不確実性もなく,全ての答えが明らかであるようなデータセットを得ることは,本当に本当に,極めて稀なことです。",
    "output": "So, data is very, very, it's very rare that you'll get a data set where all of the answers are really clear, and there's no uncertainty."
  },
  {
    "index": "F1937",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "不確実性があるような場合はいつでも,統計学が必要で,何らかの役割を果たします。",
    "output": "In any case where there is uncertainty, that's where statistics comes and plays a role."
  },
  {
    "index": "F1938",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これはまた,少し古いニューヨーク・タイムスの記事ですが,多くの大学卒業生にとって多くの仕事への扉を開くキーワードが,統計を学ぶことである,と述べています。",
    "output": "So, this is a again, a little bit older New York Times article now, but it talks about how the key word for a lot of graduates to open the door for a lot of jobs, is to learn about statistics."
  },
  {
    "index": "F1939",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ではなぜ皆さん幸運なのでしょうか?",
    "output": "So why are you lucky?"
  },
  {
    "index": "F1940",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それは,今この瞬間が,ジェフ・べゾスがインターネットを発見した瞬間の様なものだからです。",
    "output": "You're lucky because this moment, right now, in time is sort of like the moment that Jeff Bezos discovered the internet."
  },
  {
    "index": "F1941",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "彼はインターネット利用が爆発的に成長しつつあるときにインターネットの会社を作り,驚異的で,巨大で,素晴らしい何かを作り上げる機会の扉を開いたのです。",
    "output": "He got into building a internet company at the time when there was this explosive growth in internet usage and it just opened the door for the opportunity to build something amazing and huge and wonderful."
  },
  {
    "index": "F1942",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして言うなれば,データにとって,今がその瞬間なのです。",
    "output": "And sort of, that's the right, that's what the time is right now for data."
  },
  {
    "index": "F1943",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "皆さんが想像しうる全ての領域でデータが爆発的に成長しつつあるのです。",
    "output": "It sort of there's an explosive growth of data in every possible area you can imagine."
  },
  {
    "index": "F1944",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まさに今,ロケットに乗り込み,何か面白いものを見出す絶好の機会なのです。そして,それを大々的に実行に移すべき時なのです。",
    "output": "And so it's the opportunity right now to sort of jump on a rocket and, and find out something interesting, and, and sort of carry it off into a, a really major endeavor."
  },
  {
    "index": "F1945",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ツール,コンテスト,ウェブサイトが全て開発されてきており,それによりデータを学ぶことを助けるだけでなく,大変注目を集める結果を生むプロジェクトへの参加も可能となっています。",
    "output": "You're also lucky because tools and competitions and websites have all been developed around the idea of helping to learn about data, but also getting involved in projects that have super high profile results."
  },
  {
    "index": "F1946",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "1つの例がここに示すHeritageHealthPrizeです。",
    "output": "So, one example is the Heritage Health Prize, which I'm showing you a picture of here."
  },
  {
    "index": "F1947",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "HeritageHealthPrizeは賞金300万ドルのコンテストで,データを解析することにより,次の年に病院に入院することになる人をより良く予測する手法を開発した人々に与えられたものです。",
    "output": "The Heritage Health Prize was a $3 million contest for people who could analyze data and come up with a better predictor of who would be admitted to a hospital in another year."
  },
  {
    "index": "F1948",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "非常な大金がこれらのアルゴリズム開発や予測のデータサイエンスに投資されつつあることがお分かりでしょう。",
    "output": "So you can see that's a huge amount of money that's being invested in these ideas of algorithm development and data science of prediction."
  },
  {
    "index": "F1949",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "つまり,5年や10年前には無かったようなプロジェクトへ参加する刺激的な機会が提供されているのです。",
    "output": "So it gives you an exciting opportunity to get involved in projects that, sort of, weren't happening five or ten years ago."
  },
  {
    "index": "F1950",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このコース・トラックでは,もっぱら,プログラミング言語Rの使用に焦点を当てます。",
    "output": "This course track will focus almost exclusively on the use of the R programming language."
  },
  {
    "index": "F1951",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "いい機会ですので,なぜ我々がRをそんなに好きなのか,お話ししましょう。",
    "output": "And so I thought it was appropriate to talk a little bit about why we like R so much."
  },
  {
    "index": "F1952",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "我々がRのこと好きなのは,まず,我々全員が使っているからです。",
    "output": "So we like R obviously, because we all use it."
  },
  {
    "index": "F1953",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それに加え,データサイエンスのために使われる最も一般的に使われる言語でもあるためです。",
    "output": "But it's also sort of increasingly the most commonly used language for data science."
  },
  {
    "index": "F1954",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "非常に有用な,他の言語もあります。",
    "output": "There are other languages that are also very useful."
  },
  {
    "index": "F1955",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このコースではそれらについて多くはお話ししませんが,例えばPythonなどは,プログラミング言語Rを良く補完してくれます。",
    "output": "And we won't be talking about them a lot in this course but they're obviously good complements to the R programming language."
  },
  {
    "index": "F1956",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このクラスでRに注目するのは,正に生データファイルそのものから,共同制作者と共有できるようなインタラクティブな報告書や文書やウェブアプリに至るまでを可能とする幅広いパッケージを有しているからです。",
    "output": "Like, Python, in this class we'll be focusing on R because it has a broad range of packages that allow you to go from the rawest of raw files, all the way to interactive reports and documents and web apps that you can share with your collaborators."
  },
  {
    "index": "F1957",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "Rを使う他の理由として,無料だということがあります。また,私がお話ししたようなデータサイエンスの全ての過程に対する包括的なパッケージ群を有しています。",
    "output": "So, some more reasons why we might use r is because it's free, it has a comprehensive set of packages, like I mentioned, for all the processes that are involved in data science."
  },
  {
    "index": "F1958",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "また,全てのプログラミング言語の開発環境の中で最良のものの一つである,RStudioを有しています。",
    "output": "It has one of the best development environments of any programming language, in our studio."
  },
  {
    "index": "F1959",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "また,開発者の素晴らしい生態系も有しています。",
    "output": "It also has an amazing ecosystem of developers."
  },
  {
    "index": "F1960",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "どういう意味かと言うと,Rパッケージを開発する多くの人々がいるということです。",
    "output": "And what I mean by that is there are a lot of people that are developing our packages."
  },
  {
    "index": "F1961",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして彼らに,メーリングリストや,個別の電子メール,あるいはStackOverflowにおいて,連絡をとることができます。",
    "output": "And they're also available to get in touch with on mailing lists or by email or on stack overflow."
  },
  {
    "index": "F1962",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ですので,文字通り開発されつつある最新のパッケージについて,学ぶことができるのです。",
    "output": "And so it's really possible to learn about the cutting edge of packages that are being developed."
  },
  {
    "index": "F1963",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これらはインストールも容易で,複数のパッケージが実にうまく働きますが,これはデータサイエンスで使われる多くの言語にはない利点です。",
    "output": "There also very easy to install and play nicely together, which is a, a feature that doesn't always happen in a lot of the languages that are used for data science."
  },
  {
    "index": "F1964",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "次にお話ししたいのは,誰がデータサイエンティストなのか?",
    "output": "So the next thing I thought I would mention is, who is a data scientist?"
  },
  {
    "index": "F1965",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これからデータサイエンスについてたくさんお話しするのですが,本人が自分はそうだと言っておらず,また他の人もそう呼んでいなくても,私がデータサイエンティストだと思う人たちについて,ご紹介したいと思います。",
    "output": "And I thought I'd mention that some people that I think are data scientists, that might not, either label themselves that way or have other people label them that way."
  },
  {
    "index": "F1966",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "まず,ダリル・モーリーです。彼は米国のバスケットボールチームのヒューストン・ロケッツのジェネラル・マネージャーです。",
    "output": "So the first is Daryl Morey, who'd the general manager of the Houston Rockets basketball team in the US."
  },
  {
    "index": "F1967",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "彼はデータを使ってバスケットボール選手を分析し,契約やトレードを行います。",
    "output": "So he uses data to analyze basketball players and transactions and making trades."
  },
  {
    "index": "F1968",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "ですので,私は彼を一人のデータサイエンティストだと考えます。彼はバスケットボールについての疑問に,データを使って答えようとしている人だからです。",
    "output": "And so I would consider him to be a data scientist Because he's a person who uses data to answer questions about basketball."
  },
  {
    "index": "F1969",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "もう一人のデータサイエンティストは,皆さんがご存知かどうか分かりませんが,ヒラリー・メイソンです。",
    "output": "Another data scientist that you may, or may not, have heard of, is Hilary Mason."
  },
  {
    "index": "F1970",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "彼女はBitly社のチーフ・データサイエンティストだったのですが,現在はAccelPartner社にいます。",
    "output": "So, she used to be the Chief, Data Scientist at Bentley, and now she's at Accel Partners."
  },
  {
    "index": "F1971",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "彼女はデータを使って,ウェブを探索したり,人々がソーシャルメディアを通してどのように接触しているかを理解するためのあらゆる種類の疑問に答えます。",
    "output": "And so, she uses data to answer all sorts of questions about mining the web, and understanding that way that humans interact with each other through social media."
  },
  {
    "index": "F1972",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "この場合も,彼女自身はデータサイエンティストと名乗らないかもしれませんが,私は,彼女がデータを使う方法は,このデータサイエンス・トラックで伝えたいと考えている考え方を思い起こさせるものだと思います。",
    "output": "So, again she might not label herself a data scientist, but I think the way that she uses data, is a evocative of the sort of ideas, that we would like to convey in this data sciences track."
  },
  {
    "index": "F1973",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このコースを履修している人なら,ダフニー・コラーが誰かご存知でしょう。",
    "output": "If you're taking this course, you probably know who Daphne Koller is."
  },
  {
    "index": "F1974",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "彼女はCoursera社のCEOです。",
    "output": "She's the CEO of Coursera."
  },
  {
    "index": "F1975",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "彼女もまた,Courseraから集めたデータを使い,ここCourseraが行っているような大規模な教育の供給や教育的な評価の方法を改善しようと取り組んでいる人です。",
    "output": "But she's also another person who's using all the data they're collecting through Coursera to better, to improve the way that we do educational delivery and educational assessment at this huge scale that Coursera is providing."
  },
  {
    "index": "F1976",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "そして最後に,ネイト・シルバーですが,彼は今日の世界で,もっとも有名なデータサイエンティスト,あるいは統計学者です。",
    "output": "And finally, Nate Silver is one of the most famous data scientists, or statisticians in the world today."
  },
  {
    "index": "F1977",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "彼は大量の全く無料の公的なデータを使い,米国の選挙で誰が勝つかという予測をし,それが極めて正確なものだったのです彼にここで最後のデータサイエンティストとして登場してもらったのは,彼は公的な無料のデータを使って,多くの人々が読み,また興奮するような驚異的な製品を生み出せたからです。",
    "output": "So he used a large amount of totally free public data to make predictions about who would win elections in the United States, and was remarkably accurate."
  },
  {
    "index": "F1978",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "我々のゴールは,データサイエンティストとして有用な多くの異なる技術を皆さんに教えることです。",
    "output": "So our goal is to teach you about a bunch different skills that will be useful for you as a data scientist."
  },
  {
    "index": "F1979",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "データサイエンティストや統計学者の中にはベン図が嫌いな人もいますが,ともかく,これで説明します。",
    "output": "So, this is a Venn Diagram and some statisticians and data scientists don't like Venn Diagrams but I'm going to get, show you one anyway."
  },
  {
    "index": "F1980",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このベン図では,データサイエンスが中心にあり,異なるいくつかの技術を横断しています。",
    "output": "And so, this Venn Diagram has Data Science at the, sort of, the center of this Venn diagram that intersects several different skills."
  },
  {
    "index": "F1981",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "データサイエンスですね,これは3種の異なる要素を含んでいます。",
    "output": "So, if you look right here there's data science and it involves three different components."
  },
  {
    "index": "F1982",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これは「ハッキング技術」,これは「数学と統計学の知識」,そしてこれは「十分な専門性」ですね。",
    "output": "There's hacking skills, there's math and statistics knowledge, and there's substantive expertise."
  },
  {
    "index": "F1983",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "我々のデータサイエンス・トラックではこれらの何れにも焦点を当てますが,基本的には数学と統計学の知識とハッキング技術に焦点を絞ります。",
    "output": "And so our data science track will focus a little bit on each of these, but it will primarily focus on math and statistics knowledge and hacking skills."
  },
  {
    "index": "F1984",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "「数学と統計学の知識」はそのままを表していますね。",
    "output": "And so math and statistics knowledge sort of speaks for itself."
  },
  {
    "index": "F1985",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "数学について少し,また統計学について少し教えていきます。",
    "output": "We're going to teach you a little bit about math and a little bit about statistics."
  },
  {
    "index": "F1986",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "1つは,コンピュータのプログラミングについて,少なくともRを使ったプログラミングについて。これにより,皆さんはデータにアクセスでき,色々操作したり,分析したり,プロットしたりできるようになります。",
    "output": "One thing is we're going to teach you a little bit about computer programming or at least computer programming with R, which will allow you to access data and play around with it and analyze it, plot it."
  },
  {
    "index": "F1987",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "しかしながら,ハッキング技術には外に出て皆さん自身のために疑問に答える能力という別の要素も含まれます。",
    "output": "But hacking skills also has another component to it which is the ability to go out and answer questions for yourself."
  },
  {
    "index": "F1988",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "現在のデータサイエンティストの仕事の鍵となる要素の1つは,殆どの答えはまだ教科書に書かれていない,ということです。",
    "output": "One key component of a data scientist job right now is that most of the answers aren't already outlined in the textbook."
  },
  {
    "index": "F1989",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "全て今現在起こりつつあることなのです。",
    "output": "This is all new stuff that's happening."
  },
  {
    "index": "F1990",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "データサイエンティストであるための主要な技術は,GoogleやStackOverflow,それに他のサイトへ行って、何を学ぶ必要があるのかを調べ、どのような答えを知っているのか、そしてどのような答えを知らないのかを見出し、それから、自分が答えたいと思う疑問に答えるため、どのように手持ちの情報を使えばよいのか、を見出すことです。",
    "output": "So what are the major skills of being a data scientist is being to go to Google, and go to Stack Overflow, and go to one of the other sites and look up what you need to learn and figure out what answers you know and what answers you don't know, and then figuring out how you can use the information you have to answer the question that you'd like to answer."
  },
  {
    "index": "F1991",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "皆さんがこのコース・トラックを履修するのを決めた理由かもしれません。",
    "output": "That might be the reason you're taking this course track."
  },
  {
    "index": "F1992",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このグラフはデータサイエンスの仕事の一覧と時間の関係をプロットしたもので、もちろん爆発的に増えています。",
    "output": "And so you can see this is a plot of listings are for data science jobs over time and of course it's exploding."
  },
  {
    "index": "F1993",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "これを必ずしも永久に外挿すべきではないことをお話していきますが、しかしこれはデータサイエンスが成長しつつあるホットな領域であることを示唆しており、我々はそのことに興奮していますし、皆さんにもそうであって欲しい、と思います。",
    "output": "And we'll talk a little bit about why you shouldn't extrapolate, necessarily, from your data forever, but it does suggest that data science is a hot area that's growing and I think obviously we're very excited about it and hope you're excited about it too."
  },
  {
    "index": "F1994",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "このコース、データサイエンティストの道具箱では、以下の3種のことについての講義が続きます。",
    "output": "So this course, Data Scientist's Toolbox, will continue with lectures on the following three things."
  },
  {
    "index": "F1995",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "はじめに、このコース・トラックについて紹介をします。",
    "output": "First, we're going to introduce you to the course track."
  },
  {
    "index": "F1996",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それから、いくつかのツールのセット・アップとインストールについて少しお話します。",
    "output": "Then we're going to tell you a little bit about getting the tools that you need to get set up and get installed, hopefully get you over that hump."
  },
  {
    "index": "F1997",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "それから、我々はデータサイエンスの背景となる基本的な知識について、いくつか取り上げて詳しく説明していきます。",
    "output": "And then we're going to give you the basic background on data science sort of writ large, so that you'll be ready to jump into any of the individual classes and really take off."
  },
  {
    "index": "F1998",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "では、残りの講義でお会いすることを楽しみにしています。",
    "output": "Looking forward to seeing you in the rest of the class."
  },
  {
    "index": "F1999",
    "instruction": "次の日本語を英語に翻訳してください。",
    "input": "コースの2週目では,このコースの名前通りデータサイエンティストの道具箱を構成する多くのソフトウェアをインストールします。",
    "output": "In week two of course, we're going to be covering a bunch of software that you're going to install that will constitute the data scientist's toolbox, as we described it for this course's track."
  }
]