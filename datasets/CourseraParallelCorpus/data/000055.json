[
  {
    "index": "F1000",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So those are the reasons to start out with Merge Sort.",
    "output": "なのでマージソートから始めることには理由がある。"
  },
  {
    "index": "F1001",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So what is the computational problem that Merge Sort is meant to solve?",
    "output": "さて、マージソートが解くべき計算的問題とはどんなものだろうか?"
  },
  {
    "index": "F1002",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But let me tell you a little bit about it anyways, just so that we're all on the same page.",
    "output": "君らは全員ソート問題を知ってると思うけど、念のためみんながついてこれるように、少しばかり説明するよ。"
  },
  {
    "index": "F1003",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "An array of N numbers in arbitrary order, and the goal of course is to produce output array where the numbers are in sorted order, let's say, from smallest to largest.",
    "output": "まず入力として、ランダムな順序のN個の数字の配列を入力として受け取る。それを数字の順序(例えば小さい順に)に整列させて出力するのがゴールだ。"
  },
  {
    "index": "F1004",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay so, for example, we could consider the following input array, and then the goal would be to produce the following output array.",
    "output": "例えば、この入力配列を、こっちの出力配列のようにするのがゴールってことだ。"
  },
  {
    "index": "F1005",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now one quick comment. You'll notice that here in input array, it had eight elements, all of them were distinct, it was the different integers, between 1 and 8.",
    "output": "一つコメントすると、ここには8つの要素があり、それらは全てお互いに異なる1~8の整数値である。"
  },
  {
    "index": "F1006",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now the sorting problem really isn't any harder if you have duplicates, in fact it can even be easier, ...",
    "output": "ソート問題は、重複する値があっても別に難しくなるわけではない。それどころか易しくなると言える。"
  },
  {
    "index": "F1007",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "... but to keep the discussion as simple as possible let's just, among friends, go ahead and assume that they're distinct, for the purpose of this lecture.",
    "output": "だが、ここでは議論をシンプルにするために、このレクチャーにおいては、全ての値は異なるという仮定を置こう。"
  },
  {
    "index": "F1008",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And I'll leave it as an exercise which I encourage you to do, which is to think about how the Merge Sort algorithm implementation and analysis would be different, if at all, if there were ties, okay?",
    "output": "同じ値がある場合にソートアルゴリズムとその分析が異なるかどうか、異なるとしたらどうなるか、それについては君への宿題としよう。"
  },
  {
    "index": "F1009",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Go ahead and make the distinct assumption for simplicity from here on out.",
    "output": "というわけで、シンプルにするために値が異なるとの仮定で進めるよ。"
  },
  {
    "index": "F1010",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay, so before I write down any pseudo code for Merge Sort, let me just show you how the algorithm works using a picture, ...",
    "output": "よし、まずは擬似コードを書く前に、アルゴリズムがどのように動くかを図で示そう。"
  },
  {
    "index": "F1011",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "and I think it'll be pretty clear what the code would be, even just given a single example.",
    "output": "どういうコードになるのはかなり明らかだと思うよ。たった一つの例を見るだけでも十分だ。"
  },
  {
    "index": "F1012",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So let's go ahead and consider the same unsorted input array that we had on the previous slide.",
    "output": "だからどんとん進めて行こう。前のスライドのソートされてない配列の入力を考えよう。"
  },
  {
    "index": "F1013",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the Merge Sort algorithm is a recursive algorithm, and again, that means that a program which calls itself and it calls itself on smaller sub problems of the same form, okay?",
    "output": "MergeSortは再帰的なアルゴリズムだ。それが意味するのはプログラムが自分自身を同じ形で、でも少し小さな問題に分けて呼び出すって事だ。"
  },
  {
    "index": "F1014",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the Merge Sort is its purpose in life is to sort the given input array.",
    "output": "MergeSortの場合、その人生の目的は入力の配列をソートする事だ。"
  },
  {
    "index": "F1015",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So it's going to spawn, or call itself on smaller arrays.",
    "output": "その為に、より小さな配列に対して、自分自身をまた生み出す、または呼び出す。"
  },
  {
    "index": "F1016",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And this is gonna be a canonical Divide-and-Conquer application, where we simply take the input array, we split it in half, we solve the left half recursively, we solve the right half recursively, and then we combine the results.",
    "output": "入力の配列を単純に半分に分けて、左半分を再帰的に解き、右半分を再帰的に解き、そして両方の結果を結合する。"
  },
  {
    "index": "F1017",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So let's look at that in the picture.",
    "output": "それを絵で見てみましょう。"
  },
  {
    "index": "F1018",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the first recursive call gets the first four elements, the left half of the array, namely 5, 4, 1, 8.",
    "output": "最初の再帰呼び出しは配列の左半分として最初の4つの要素、5,4,1,8を取る。"
  },
  {
    "index": "F1019",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And, of course, the other recursive call is gonna get the rest of the elements, 7, 2, 6, 3.",
    "output": "もちろんもう一つの再帰は残りの7,2,6,3を取る。"
  },
  {
    "index": "F1020",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You can imagine these has been copied into new arrays before they're given to the recursive calls.",
    "output": "再帰呼び出しに渡される前にこれらの値は新しい配列にコピーされることは想像がつくと思う。"
  },
  {
    "index": "F1021",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, by the magic of recursion, or by induction if you like, the recursive calls will do their task.",
    "output": "そうしたら、再帰の魔法により、もしくは帰納でも何でもいいが、再帰呼び出しが自分の仕事をしてくれる。"
  },
  {
    "index": "F1022",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "They will correctly sort each of these arrays of four elements, and we'll get back sorted versions of them.",
    "output": "つまり4要素の配列を正しくソートしてくれる。ソート済みバージョンで戻ってくる。"
  },
  {
    "index": "F1023",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So from our first recursive call, we receive the output, 1, 4, 5, 8, and from the second recursive call, we received the sorted output, 2, 3, 6, 7.",
    "output": "最初の再帰呼び出しからは1,4,5,8が、次のからは2,3,6,7が。"
  },
  {
    "index": "F1024",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So now, all the remains to complete the Merge Sort is to take the two results of our recursive calls, these two sorted elements of length-4, and combine them to produce the final output, namely the sorted array of all eight of the input numbers.",
    "output": "するとマージソートを終わらせるために残っているのは、2つの再帰呼び出しの結果であるソート済み配列を受け取って、最終結果、つまりはじめの8個の要素をソートした配列を作ることだ。"
  },
  {
    "index": "F1025",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And hopefully you are already are thinking about how you might actually implement this merge in a computationally efficient way.",
    "output": "これがマージと呼ばれるステップだきっと皆さんも、自分ならどうすれば計算機科学的に効率的にこのマージが実装できるか考え始めていることと思う詳細についてはみなさんにお任せします。"
  },
  {
    "index": "F1026",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And I will tell you exactly how the merge is done.",
    "output": "ここでは正確にはどうマージが行われるかを話します。"
  },
  {
    "index": "F1027",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In effect, you just walk pointers down each of the two sort of sub-arrays, copying over, populating the output array in the sorted order.",
    "output": "実際には、2つのソート済み部分配列それぞれでポインタを動かし、コピーして、ソートされた順序で出力配列に書き出します。"
  },
  {
    "index": "F1028",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But I will give you some more details in just a slide or two.",
    "output": "もう少し詳細を、スライド1、2枚で説明しましょう。"
  },
  {
    "index": "F1029",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Split it in half, solve recursively, and then have some slick merging procedure to combine the two results into a sorted output.",
    "output": "半分に分け再帰的に解き、素晴らしいマージの手続きによって2つの結果を一つのソート済みの出力にします。"
  },
  {
    "index": "F1030",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay, so let's move on, and actually discuss the pseudo-code for the merge sort algorithm.",
    "output": "どんどん行きましょう。そして実際にMergeSortの擬似コードを議論していきましょう。"
  },
  {
    "index": "F1031",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "First, let me just tell you the pseudo-code, leaving aside exactly how the merging subroutine is implemented.",
    "output": "最初に擬似コードの話をします、マージのサブルーチンがどう実装されてるのかは脇においといて。"
  },
  {
    "index": "F1032",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And thus, high levels should be very simple and clear at this point.",
    "output": "なので、上のレベルではこの点はとてもシンプルで明確なはずです。"
  },
  {
    "index": "F1033",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So there's gonna be two recursive calls, and then there's gonna be a merging step.",
    "output": "2つの再帰呼び出しがあり、そしてマージのステップがある。ここでちょっとコメントがあります。"
  },
  {
    "index": "F1034",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Again, as I promised, this isn't something you would directly translate into code, although it's pretty close.",
    "output": "私はちょっとだらしないので、お約束したように、これは直接コードに翻訳するような何かではありません。"
  },
  {
    "index": "F1035",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But so what are the couple of the ways that I'm being sloppy?",
    "output": "結構それに近いですけどね。でもどこで手抜きをしてるんでしょうか?"
  },
  {
    "index": "F1036",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Well, first of all, there's, , you know, in any recursive algorithm, you gotta have some base cases.",
    "output": "まずはじめに、基底のケースが無い。ご存知のように、全ての再帰のアルゴリズムは基底の場合の処理があります。"
  },
  {
    "index": "F1037",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You gotta have this idea that when the input's sufficient.",
    "output": "そこに至るのは入力が十分小さくなってそれ以上再帰がいらなくなった所でです。"
  },
  {
    "index": "F1038",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Really small you don't do any recursion, you just return some trivial answer.",
    "output": "ただトリビアルな答えを返すだけ。"
  },
  {
    "index": "F1039",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So in the sorting problem the base case would be if your handed an array that has either zero or an elements, well it's already sorted, there's nothing to do, so you just return it without any recursion.",
    "output": "ソートのアルゴリズムなら基底のケースは長さゼロの配列か要素が一つだけ入った配列、って所でしょう。それは既にソートされてるので、特にやる事は無い。"
  },
  {
    "index": "F1040",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay, so to be clear, I haven't written down the base cases.",
    "output": "OK。分かりやすくするために、基底のケースは書きません。"
  },
  {
    "index": "F1041",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Although of course you would if you were actually implementing, a merge short.",
    "output": "もちろんあなたが実際にマージソートを実装する時は書かないとダメですが。その事は気に留めておいた方がいいかも。"
  },
  {
    "index": "F1042",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Some of you, make a note of that.",
    "output": "どっちでも好きな方にしてよろしい。"
  },
  {
    "index": "F1043",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "A couple of other things I'm ignoring. I'm ignoring what the, what to do if the array has odd lengths, so if it has say nine elements, obviously you have to somehow break that into five and four or four and five, so you would do that just in either way and that would fine.",
    "output": "二番目に、私は詳細、または再帰的なソートという時に実際には何を意味しているか、を無視している。"
  },
  {
    "index": "F1044",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then secondly, I'm ignoring the details or what it really means to sort of recursively sort, so for example, I'm not discussing exactly how you would pass these subarrays onto the recursive calls.",
    "output": "例えば、これらの部分配列をどう再帰呼び出しに渡すかを正確に議論したりはしない。"
  },
  {
    "index": "F1045",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's something that would really depend somewhat on what, on the programming language, so that's exactly what I want to avoid.",
    "output": "それは何のプログラミング言語で作業してるか、とかに凄く依存する所ですからね。それがまさに私の避けたい事でもあるので。"
  },
  {
    "index": "F1046",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "I really want to talk about the concepts which transcend any particular programming language implementation.",
    "output": "私は言語の実装を超えた、コンセプト的な所をお話したい。"
  },
  {
    "index": "F1047",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So that's why I'm going to describe algorithms at this level okay.",
    "output": "そんな訳でアルゴリズムをこのレベルで記述していきます。オーケー。"
  },
  {
    "index": "F1048",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Alright, so the hard part relatively speaking, that is. How do you implement the merge depth?",
    "output": "では相対的に難しい部分はマージの底の部分をどう実装するか?"
  },
  {
    "index": "F1049",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The recursive calls have done their work.",
    "output": "再帰呼び出しは彼ら自身の仕事をする。"
  },
  {
    "index": "F1050",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We have these two sort of separated half the numbers.",
    "output": "これら半分づつソートされた数たちを得る。"
  },
  {
    "index": "F1051",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The left half and the right half.",
    "output": "左半分と右半分。"
  },
  {
    "index": "F1052",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "How do we combine them into one?",
    "output": "これらをどう一つにまとめるか?"
  },
  {
    "index": "F1053",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And in English, I already told you on the last slide.",
    "output": "英語ではすでに直前のスライドに書いた。"
  },
  {
    "index": "F1054",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The idea is you just populate the output array in a sorted order, by traversing pointers or just traversing through the two, sorted sub-arrays in parallel.",
    "output": "ポインタをたどるか、ソートされた部分配列を並行にたどるかして、出力配列をソートされた形にして埋めてゆくというアイデアだ。"
  },
  {
    "index": "F1055",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So let's look at that in some more detail.",
    "output": "もっとくわしく見てみよう。"
  },
  {
    "index": "F1056",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay, so here is the pseudo-code for the merge step.",
    "output": "オッケー、ここにマージのステップの擬似コードがある。"
  },
  {
    "index": "F1057",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So let me begin by, introducing some names for the, characters in the, what we're about to discuss.",
    "output": "(音)まずは対象の名前を決めよう。ここでは出力配列をCで表すことにする。"
  },
  {
    "index": "F1058",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "To denote the output array. So this is what we're suppose to spit out with the numbers in sorted order.",
    "output": "これに数値をソートされた順に出力することを考える。"
  },
  {
    "index": "F1059",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then, I'm gonna use a and b to denote the results of the two recursive calls, okay?",
    "output": "そして、二つの再帰呼び出しの結果をaとbと呼ぶことにする。"
  },
  {
    "index": "F1060",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, the first recursive call has given us array a, which contains the left half of the input array in sorted order.",
    "output": "つまり、最初の再帰呼び出しがaで、入力配列の左半分がソートされた順で入っている。"
  },
  {
    "index": "F1061",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Similarly, b contains the right half of the input array, again, in sorted order.",
    "output": "同じくbには入力配列の右半分がまたソートされた順で入っている。"
  },
  {
    "index": "F1062",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, as I said, we're gonna need to traverse the two, sorted sub-arrays, a and b, in parallel.",
    "output": "さっき言ったように、ソートされた二つの部分配列aとbを並行にたどる必要がある。"
  },
  {
    "index": "F1063",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, I'm gonna introduce a counter, i, to traverse through a, j to traverse through b.",
    "output": "ではカウンタiをAを辿るのに、カウンタjをBを辿るのに導入する。"
  },
  {
    "index": "F1064",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "I and j will both be initialized to one, to be at the beginning of their respective arrays.",
    "output": "i,jは両方とも1に初期化。それぞれの配列の最初指すように。"
  },
  {
    "index": "F1065",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We're going to do a single pass of the output array copying it in an increasing order.",
    "output": "そして実行する、出力配列に昇順に一パスでコピーしていく。"
  },
  {
    "index": "F1066",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Always taking the smallest from the union of the two sorted sub arrays.",
    "output": "いつも2つのソートされた配列の両方から一番小さい物を取る。"
  },
  {
    "index": "F1067",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And if you, if there's one idea in this merge step it's just the realization that.",
    "output": "ここで一計。このマージの段階では、まだ見てない中で一番小さい要素は2つのリストのどちらかの先頭にある。"
  },
  {
    "index": "F1068",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The minimum element that you haven't yet looked at in A and B has to be at the front of one or the two lists right so for example at the very beginning of the algorithm where is the minimum element over all.",
    "output": "例えばアルゴリズムの最初の段階では、最小の値は一体どこにあるか?"
  },
  {
    "index": "F1069",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Well, which ever of the two arrays it lands in -- A or B -- it has to be the smallest one there okay.",
    "output": "2つの配列、AかB、のどちらかだろう。最小の要素はどちらかにある。"
  },
  {
    "index": "F1070",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the smallest element over all is either the smallest element A or it's the smallest element B.",
    "output": "だから全体の中で最小の要素は、Aの最小の要素か、Bの最小の要素。"
  },
  {
    "index": "F1071",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So you just check both places, the smaller one is the smallest you copy it over and you repeat.",
    "output": "だから両方チェックして、より小さい方が最小の物だ。"
  },
  {
    "index": "F1072",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's it.",
    "output": "以上。"
  },
  {
    "index": "F1073",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the purpose of K is just to traverse the output array from left to right.",
    "output": "Kの目的は出力の配列をただ左から右に辿るだけ。"
  },
  {
    "index": "F1074",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's the order we're gonna populate it. Currently looking at position I, and the first array of position J and the second array.",
    "output": "今、最初の配列のi番目と二番目の配列のj番目を見ているとする。"
  },
  {
    "index": "F1075",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We look at which one has the current smallest, and we copy the smallest one over.",
    "output": "どっちが最小か見る。そしてその最小の方をコピー。"
  },
  {
    "index": "F1076",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So if the, if, the entry in the i position of A is smaller, we copy that one over.",
    "output": "配列Aのi番目が小さければ、そっちをコピーする。"
  },
  {
    "index": "F1077",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Of course, we have to increment i.",
    "output": "もちろんiをインクリメントもする。"
  },
  {
    "index": "F1078",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We probe one deeper into the list A, and symmeterically for the case where the current position in B has the smaller element.",
    "output": "Aのリストをもう1段潜る。Bの現在地の方が小さい要素なら、対称的にやる。"
  },
  {
    "index": "F1079",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now again, I'm being a little bit sloppy, so that we can focus on the forest, and not sort of, And not get bogged down with the trees.",
    "output": "ここでもちょっとさぼって森を見る事に集中していて、木々の中には立ち入らない。終条件を無視してる。"
  },
  {
    "index": "F1080",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "I'm ignoring some end cases, so if you really wanted to implement this, you'd have to add a little bit, to keep track of when you fall off, either, either A or B.",
    "output": "だから本当に実装したければ、もうちょっと足さないとダメ。AかBからはみ出ないように。"
  },
  {
    "index": "F1081",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Because you have additional checks for when i or j reaches the end of the array, at which point you copy over all the remaining elements into C.",
    "output": "その為にiとjは終端に来ているか、のチェックをして、そこまで行ったら残った要素を全部Cにコピーする。"
  },
  {
    "index": "F1082",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Alright, so I'm gonna give you a cleaned up version, of, that pseudo-code so that you don't have to tolerate my questionable handwriting any longer than is absolutely necessary.",
    "output": "オーライ、擬似コードの清書版をお見せする。もはやどうしても必要な時以外は私の怪しい手書きに耐える必要はない。"
  },
  {
    "index": "F1083",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This again, is just the same thing that we wrote on the last slide, okay?",
    "output": "これは直前のスライドに書いたものと全く同じものだ。オーケー?"
  },
  {
    "index": "F1084",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The pseudo-code for the merge step.",
    "output": "マージステップの擬似コード。"
  },
  {
    "index": "F1085",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, so that's the Merge Sort algorithm.",
    "output": "すなわちマージソートのアルゴリズムだ。"
  },
  {
    "index": "F1086",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now let's get to the meaty part of this lecture, which is, okay, so merge sort produces a sorted array.",
    "output": "この講義の素晴らしい部分、マージソートがソートされた配列を出力するところを見よう。"
  },
  {
    "index": "F1087",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "What makes it, if anything, better than much simpler non divide and conquer algorithms, like say, insertion sort?",
    "output": "なぜもっと単純な分割統治ではないアルゴリズム、例えば挿入ソートよりむしろ良いといえるのか?"
  },
  {
    "index": "F1088",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Other words, what is the running time of the merge sort algorithm?",
    "output": "別の言い方をするとマージソートの実行時間はどうなのか?"
  },
  {
    "index": "F1089",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now I'm not gonna give you a completely precise definition, definition of what I mean by running time and there's good reason for that, as we'll discuss shortly.",
    "output": "完全で正確な定義はしないが、少しだけ話そう。"
  },
  {
    "index": "F1090",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But intuitively, you should think of the running time of an algorithm, you should imagine that you're just running the algorithm in a debugger.",
    "output": "しかし直観的にはアルゴリズムの実行時間は、アルゴリズムをデバッガで動かすことを思えばよい。"
  },
  {
    "index": "F1091",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Then, every time you press enter, you advance with one line of the program through the debugger.",
    "output": "つまり、デバッガで毎回エンターキーを押してプログラムを一行ずつ進める。"
  },
  {
    "index": "F1092",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then basically, the running time is just a number of operations executed, the number of lines of code executed.",
    "output": "そして基本的には、実行時間はちょうど実行された操作の数、実行されたコードの行数になる。"
  },
  {
    "index": "F1093",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the question is, how many times you have to hit enter on the debugger before the, program finally terminates.",
    "output": "そこで問題になるのが、プログラムが最終的に停止するまでに何回エンターキーを押す必要があるのかということだ。"
  },
  {
    "index": "F1094",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So we're interested in how many such, lines of code get executed for Merge Short when an input array has n numbers.",
    "output": "知りたいのは、いったい何行のコードが入力配列の長さがNのとき、マージソートで実行されるかそれはかなり、込み入った質問だ。"
  },
  {
    "index": "F1095",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So let's start with a more modest school.",
    "output": "だからもっと穏健な学派から始めよう。"
  },
  {
    "index": "F1096",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Rather than thinking about the number of operations executed by Merge Sort, which is this crazy recursive algorithm, which is calling itself over and over and over again.",
    "output": "MergeSort、このクレージーに再帰的なアルゴリズム、自分自身を呼んで呼んでよびまくる物の、実行されるオペレーションの数を考えるのではなく、2つのソートされたサブ配列を一回マージするのにかかるオペレーションの数だけを数えてみよう。"
  },
  {
    "index": "F1097",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That seems like it should be an easier place to start.",
    "output": "開始の場所としてはこっちの方が簡単そう。"
  },
  {
    "index": "F1098",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So let me remind you, the pseudo code of the merge subroutine, here it is.",
    "output": "思い出す為に、偽コードのマージのサブルーチンをここに示す。"
  },
  {
    "index": "F1099",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So let's just go and count up how many operations that are gonna get used.",
    "output": "ではいくつのオペレーションが使われているか数えて行こう。"
  },
  {
    "index": "F1100",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So let's say that I'm gonna charge us one operation for each of these two initializations.",
    "output": "2つの初期化に1オペレーションずつかかるとしよう。"
  },
  {
    "index": "F1101",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So let's call this two operations, just set i equal to one and j equal to one then we have this four loop executes a total number of end times so each of these in iterations of this four loop how many instructions get executed, well we have one here we have a comparison so we compare A(i) to B(j) and either way the comparison comes up we then do two more operations, we do an assignment.",
    "output": "ではこのforループの各繰り返しの中で幾つの命令が実行されるか?ここに一つ、A(i)とB(j)を比較して、比較の結果がどちらであれ、もう2つの命令、代入をする。"
  },
  {
    "index": "F1102",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Here or here.",
    "output": "ここかここ。"
  },
  {
    "index": "F1103",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then we do an increment of the relevent variable either here or here.",
    "output": "そして関連する方の変数をインクリメント。ここかここ。"
  },
  {
    "index": "F1104",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So for each of these N iterations of the four loop we're gonna do four operations.",
    "output": "だからこれらN回のforループの繰り返しで毎回4オペレーションする事になる。"
  },
  {
    "index": "F1105",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So putting it all together, what do we have is the running time for merge.",
    "output": "全部まとめて、マージにかかる時間が分かる。"
  },
  {
    "index": "F1106",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the upshot is that the running time of the merge subroutine, given an array of M numbers, is at most four M plus two.",
    "output": "では上限を見てみよう。マージのサブルーチンの実行時間の条件は、M個の数の配列が与えられた時には、たかだか4M+2。"
  },
  {
    "index": "F1107",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So a couple of comments.",
    "output": "コメントを少々。"
  },
  {
    "index": "F1108",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "First of all, I've changed a letter on you so don't get confused.",
    "output": "まず、文字を変えました。混乱しないように注意。"
  },
  {
    "index": "F1109",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In the previous slide we were thinking about an input size of N.",
    "output": "前のスライドでは入力の大きさをNとした。"
  },
  {
    "index": "F1110",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "See I've changed the name of the variable to M.",
    "output": "ここでは見ての通り名前を変えてMにした。"
  },
  {
    "index": "F1111",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's gonna be convenient once we think about merge sort, which is recursing on smaller sub-problems.",
    "output": "MergeSortについて考えるならそっちの方が便利だから。それはより小さなサブルーチンに再帰するからね。"
  },
  {
    "index": "F1112",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But it's exactly the same thing and, and whatever.",
    "output": "しかし全く前と同じ事だから。"
  },
  {
    "index": "F1113",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So an array of M entries does as most four M plus two. Lines of code.",
    "output": "だからM要素の配列はせいぜい4M+2行のコードでやる。"
  },
  {
    "index": "F1114",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The second thing is, there's some ambiguity in exactly how we counted lines of code on the previous slide.",
    "output": "2つ目、前のスライドで正確に、どうコードの行数を数えたかにはある程度の曖昧さがある。"
  },
  {
    "index": "F1115",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So maybe you might argue that, you know, really, each loop iteration should count as two operations, not just one.'Cause you don't just have to increment K, but you also have to compare it to the, upper bound of N.",
    "output": "たとえばループの繰り返しは一つじゃなくて2つのオペレーションと数えるべきだ、と言いたいかもしれない。"
  },
  {
    "index": "F1116",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Would have been 5M+2 instead of 4M+2. So it turns out these small differences in how you count up.",
    "output": "何故ならkをインクリメントするだけじゃなくて、Nという上限と比較しないといかないから。"
  },
  {
    "index": "F1117",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The number of lines of code executed are not gonna matter, and we'll see why shortly.",
    "output": "これらの、どう実行されるコードを数えるかによる小さな違いは大して問題にならない、というのがすぐに分かる。"
  },
  {
    "index": "F1118",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, amongst friends, let's just agree, let's call it 4M plus two operations from merge, to execute on array on exactly M entries.",
    "output": "ここではとりあえず納得しといてくれ。マージには4M+2命令かかる、ちょうどM要素の配列に実行するのに。"
  },
  {
    "index": "F1119",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, let me abuse our friendship now a little bit further with an, an inequality which is true, but extremely sloppy.",
    "output": "ここで諸兄の親愛の想いをもうちょっと乱用して、正しいんだかひどかやる気の無い不等式を適用しよう。"
  },
  {
    "index": "F1120",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But I promise it'll make our lives just easier in some future calculations.",
    "output": "でも我々の将来の生活がこれで楽になる、と約束する。"
  },
  {
    "index": "F1121",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Because m is at least one. Okay, you have to admit it's true, 6MO is at least 4M plus two.",
    "output": "何故ならMは少なくとも1だから、認めざるをえなかろう。"
  },
  {
    "index": "F1122",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's very sloppy, these numbers are not anything closer to each other for M large but, let's just go ahead and be sloppy in the interest of future simplicity.",
    "output": "これらの数はちっとも大きなMと近く無い。でも先に進む。"
  },
  {
    "index": "F1123",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay.",
    "output": "オーケー。"
  },
  {
    "index": "F1124",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now I don't expect anyone to be impressed with this rather crude upper bound, the number of lines of code that the merge subroutine needs to finish, to execute.",
    "output": "マージのサブルーチンが実行し終わるのに必要なコード行の総数なんて物には。"
  },
  {
    "index": "F1125",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The key question you recall was how many lines of code does merge sort require to correctly sort the input array, not just this subroutine.",
    "output": "キーとなる質問を思い出すと、入力の配列をソートし終えるのに、マージソートは何行のコードが必要なのか、だ。このサブルーチンだけのじゃない。"
  },
  {
    "index": "F1126",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And in fact, analyzing Merge Sort seems a lot more intimidating, because if it keeps spawning off these recursive versions of itself.",
    "output": "実際、MergeSortの分析はもっと怖い感じ。何故ならこの再帰バージョンの自分自身を生み出し続けるから。"
  },
  {
    "index": "F1127",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the number of recursive calls, the number of things we have to analyze, is blowing up exponentially as we think about various levels of the recursion.",
    "output": "再帰の総数、分析しなくてはならない全ての事の総数は、再帰のいろいろなレベルを考えると吹き上がってしまうから。"
  },
  {
    "index": "F1128",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, if there's one thing we have going for us, it's that every time we make a recursive call.",
    "output": "今、一つの我々に有利な事としては、再帰呼び出しをする都度、それを呼んでる所よりも入力はかなり小さくなってる、という事。"
  },
  {
    "index": "F1129",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's on a quite a bit smaller input then what we started with, it's on an array only half the size of the input array.",
    "output": "入力の配列はたった半分になってる。"
  },
  {
    "index": "F1130",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So there's some kind of tension between on the one hand explosion of sub problems, a proliferation of sub problems and the fact that successive subproblems only have to solve smaller and smaller subproblems.",
    "output": "だからある種の緊張関係がある。"
  },
  {
    "index": "F1131",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And resolute resolving these two forces is what's going to drive our analysis of Merge Short.",
    "output": "一方ではサブの問題が発散、増殖していて、後続のサブ問題はどんどんより小さなサブ問題だけを解けば良くなる。"
  },
  {
    "index": "F1132",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, the good news is, is I'll be able to show you a complete analysis of exactly how many lines of code Merge Sort takes.",
    "output": "これらの2つの力に断固として立ち向かうのが、我らのMergeSortの分析を進める。"
  },
  {
    "index": "F1133",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And I'll be able to give you, and, in fact, a very precise upper bound.",
    "output": "いいニュースは、MergeSortが正確に何行かかるか、という完全な分析を私はお見せ出来る、という事。"
  },
  {
    "index": "F1134",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so here's gonna be the claim that we're gonna prove in the remainder of this lecture.",
    "output": "そしてとても詳細な上限をあなたにお届け出来る。ここに、このレクチャーの残り使って証明する主張(クレーム)がある。"
  },
  {
    "index": "F1135",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the claim is that Merge Short never needs than more than six times N.",
    "output": "その主張とは、MergeSortは決して6N掛けるlog2底のNに追加で6Nのオペレーション以上はかからない、N要素の配列をソートするのに。"
  },
  {
    "index": "F1136",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Times the logarithm of N log base two if you're keeping track plus an extra six N operations to correctly sort an input array of N numbers, okay so lets discuss for a second is this good is this a win, knowing that this is an upper bound of the number of lines of code the merger takes well yes it is and it shows the benefits of the divide and conquer paradigm.",
    "output": "このマージは最大でもその程度の行数のコードしかかからないという知識の元で。"
  },
  {
    "index": "F1137",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In the simpler sorting methods that we briefly discussed like insertion sort, selection sort, and bubble sort, I claimed that their performance was governed by the quadratic function of the input size.",
    "output": "軽く議論したよりシンプルなソート、挿入ソートとか、選択ソートとかバブルソートとか、そこでは私はそれらのパフォーマンスは入力サイズの二次関数で支配されている、と主張したのを思い出してくれ。"
  },
  {
    "index": "F1138",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That is they need a constant times in the squared number of operations to sort an input array of length N.",
    "output": "つまりそれらは定数掛ける入力サイズの二乗のオペレーションが長さNの入力配列をソートするのにかかる。"
  },
  {
    "index": "F1139",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Merge sort by contrast needs at most a constant times N times log N, not N squared but N times log N lines of code to correctly sort an input array.",
    "output": "一方MergeSortはせいぜい定数掛けるN掛けるlogN程度。Nの二乗じゃなくてNlogN行のコードで入力の配列を正しくソート出来る。"
  },
  {
    "index": "F1140",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So to get a feel for what kind of win this is let me just remind you for those of you who are rusty, or for whatever reason have lived in fear of a logarithm, just exactly what the logarithm is.",
    "output": "どのくらい勝ちかを感覚でつかむ為、さびついてるか何らかの理由で対数に恐れて暮らしている人の為、対数とは一体どんな物だったかを思い出させよう。"
  },
  {
    "index": "F1141",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So. The way to think about the logarithm is as follows.",
    "output": "対数の考え方はこうだ。"
  },
  {
    "index": "F1142",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So you have the X axis, where you have N, which is going from one up to infinity.",
    "output": "X軸があるとする。"
  },
  {
    "index": "F1143",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And for comparison let's think about just the identity function, okay?",
    "output": "そしてNがあるとして、1から無限大までいくとする。"
  },
  {
    "index": "F1144",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, the function which is just. F(n)=n.",
    "output": "比較の為、アイデンティティ関数を考える、つまりF(n)=n。"
  },
  {
    "index": "F1145",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay, and let's contrast this with a logarithm. So what is the logorithm?",
    "output": "で、これを対数と比較する。"
  },
  {
    "index": "F1146",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the log of n, log base 2 of n is, you type the number N into your calculator, okay? Then you hit divide by two.",
    "output": "logN、つまりlog2底のNは、Nを電卓に打って、割る2を打つ。"
  },
  {
    "index": "F1147",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then you keep repeating dividing by two and you count how many times you divide by two until you get a number that drops below one okay.",
    "output": "そしてその2で割るのを繰り返し、何回2で割ったかを数えるその数字が1になるまで。"
  },
  {
    "index": "F1148",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So if you plug in 32 you got to divide five times by two to get down to one.",
    "output": "もし32なら5回割ると1になる。"
  },
  {
    "index": "F1149",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You put in 1024 you have to divide by two, ten times till you get down to one.",
    "output": "もし1024なら10回割らないと1にならない。"
  },
  {
    "index": "F1150",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So log base two of 1024 is ten and so on, okay. So the point is you already see this if a log of a 1000 roughly is something like ten then the logarithm is much, much smaller than the input.",
    "output": "つまり2を底とした1024の対数は10となるいいかな、ここで肝心なのは、約1000の対数が10といったあたりで、入力に対して対数はとてもとても小さいってことだなので図に描くと対数はこんな感じになる曲線はNが大きくなるにつれ、急速に水平になる。"
  },
  {
    "index": "F1151",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So F(n) being log base 2 of n.",
    "output": "それがF(n)がlog2底のnって事。"
  },
  {
    "index": "F1152",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And I encourage you to do this, perhaps a little bit more precisely on the computer or a graphing calculator, at home.",
    "output": "家で、今やった事やもうちょっと詳細にコンピュータやグラフつき電卓でやってみる事を勧める。"
  },
  {
    "index": "F1153",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But log is running much, much, much slower than the identity function.",
    "output": "とにかく、logはアイデンティティ関数よりずっとずっと遅く進む。"
  },
  {
    "index": "F1154",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And as a result, sorting algorithm which runs in time proportional to n times log n is much, much faster, especially as n grows large, than a sorting algorithm with a running time that's a constant times n squared.",
    "output": "結果として、NlogNと比例した進み方のソートアルゴリズムはずっと速い。特にNが大きくなると。"
  },
  {
    "index": "F1155",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, in this video, we'll graduate beyond the domain of just vanilla binary search trees, like we've been talking about before, and we'll start talking about balanced binary search trees.",
    "output": "このビデオでは、ただの二分探索は既にお話しので、次のお話に進みたいと思います。それはバランスされた二分木探索です。"
  },
  {
    "index": "F1156",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "These are the search trees you'd really want to use when you want to have real time guarantees on your operation time.",
    "output": "これらがリアルタイム性を行たい操作に保証したい時にあなたが実際に必要とする探索木です。"
  },
  {
    "index": "F1157",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Cuz they're search trees which are guaranteed to stay balanced, which means the height is guaranteed to stay logarithmic, which means all of the operations search trees support that we know and love, will also be a logarithmic in the number of keys that they're storing.",
    "output": "それは高さが対数的であることが保証されているということです。つまり、二分探索木において私たちが学び、愛した全ての操作について保持するキーの数に対して対数的に処理されるということです。"
  },
  {
    "index": "F1158",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, let's just quickly recap.",
    "output": "じゃあ、簡単に振り返りましょう。"
  },
  {
    "index": "F1159",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "What is the basic structure tree property?",
    "output": "ツリー構造の基本的な性質ってなんだったでしょうか?"
  },
  {
    "index": "F1160",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It should be the case that at every single node of your search tree, if you go to the left, you'll only see keys that are smaller than where you started and if you go to the right you only see keys that are bigger than where you started.",
    "output": "探索木の全てのノードについて、もし左にいくとしたら、その先のツリーのデータには元のデータよりも小さいものしかありません。右に行けば、大きなものしかありません。"
  },
  {
    "index": "F1161",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And a really important observation, which is that, given a set of keys, there's going to be lot and lots of legitimate, valid, binary search trees with those keys.",
    "output": "また本当に大事なポイントは、あるキーの集合があるときそのキーについての正当な探索木はたくさんあることです。"
  },
  {
    "index": "F1162",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, we've been having these running examples where the keys one, two, three, four, five.",
    "output": "この例として1,2,3,4,5というキーがあるとします。"
  },
  {
    "index": "F1163",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "On the one hand, you can have a nice and balanced search tree that has height only two, with the keys one through five.",
    "output": "一方では、ちゃんとバランスされた探索木があります。高さは2で、1から5までのキーがあります。"
  },
  {
    "index": "F1164",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "On the other hand, you can also have these crazy chains, basically devolved to link lists where the heights for, and elements could be as high as N - 1.",
    "output": "一方では、無茶苦茶な連鎖を持ち、連結リストに退化してしまい、高さも要素数N-1と同じになってしまいます。"
  },
  {
    "index": "F1165",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, in general, you could have an exponential difference in the height.",
    "output": "一般論として、高さについて指数的な差が生まれます。"
  },
  {
    "index": "F1166",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It can be as small, in the best case, as logarithmic and as big, in the worst case, as linear.",
    "output": "コストは最良の場合には対数的と小さいですが、最悪な場合は線形なほど大きくなります。"
  },
  {
    "index": "F1167",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, this obviously motivates search trees that have the additional property that you never have to worry about their height.",
    "output": "というわけで、高さについては何にも心配しなくてもよくなるような性質を持つ探索木が望まれます。"
  },
  {
    "index": "F1168",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You know they're going to be well balanced.",
    "output": "そういう木はうまくバランスされることがわかっています。"
  },
  {
    "index": "F1169",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You're never worried about them having this really lousy linear height.",
    "output": "高さがアルゴリズム的に決まることもわかります皆さんはもう、うんざりするような線形の高さになるのかと心配することもなくなります。"
  },
  {
    "index": "F1170",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Remember, why it's so important to have a small height?",
    "output": "繰り返しですが、高さが低いことがなぜそれほど重要なんでしょうか?"
  },
  {
    "index": "F1171",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's because the running time of all of the operations of search trees depends on the height.",
    "output": "なぜなら探索木の操作の実行時間はすべて、木の高さに依存するからです。"
  },
  {
    "index": "F1172",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You want to do search, you want to insertions, you want to find predecessors or whatever, the height is going to be what governs the running time of all those properties.",
    "output": "そして、探索木についての一番大事なアイデアは皆さんがすでにお考えの通りのものです。つまり、高さは保持するものの数の対数よりは決して良くならないということです。"
  },
  {
    "index": "F1173",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, the high level idea behind balanced search trees is really exactly what you think, which is that, you know, because the height can't be any better than logarithmic in the number of things you're storing, that's because the trees are binary so the number of nodes can only double each level so you need a logarithmic number of levels to accommodate everything that you are storing.",
    "output": "なぜなら、木は二分されるので、どのレベルでも倍にしかならず、保持しているすべての数に到達するには対数量が必要になるからです。"
  },
  {
    "index": "F1174",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But it's got to be logarithmic, lets make sure it stays logarithmic all the time, even as we do insertions and deletions.",
    "output": "さらに、対数的になったとしたら、どんな場合でも対数的に留まるということも仮定しましょう。挿入や削除をしてもです。"
  },
  {
    "index": "F1175",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If we can do that, then we get a very rich collection of supported operations all running in logarithmic time.",
    "output": "そうしたらすべて対数時間で行える豊かな操作群を利用できます。"
  },
  {
    "index": "F1176",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "As usual, n denotes, the number of keys being stored in the tree. There are many, many, many different balanced search trees.",
    "output": "同じように、保持されるキーの数に対して平衡探索木には物凄くたくさんの種類があります。"
  },
  {
    "index": "F1177",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "They're not super, most of them are not super different from each other.",
    "output": "それらは、ほとんどの場合、それほど互いには大きくは違いません。"
  },
  {
    "index": "F1178",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "I'm going to talk about one of the more popular ones which are called Red Black Trees.",
    "output": "ここでは、その中で一番有名な、赤黒木についてお話します。"
  },
  {
    "index": "F1179",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "These were not the first balanced binary search tree data structures, that honor belongs to AVL trees, which again are not very different from red black trees, though the invariants are slightly different.",
    "output": "それはAVL木です。赤黒木とそれほど大きな違いがあるわけではありませんが、満たす性質が少しことなります。"
  },
  {
    "index": "F1180",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Another thing you might want to look up and read about is a very cool data structure called splay trees, due to Sleator and Tarjan, These, unlike red black trees and AVL trees, which only are modified on insertions and deletions, which, if you think about it, is sort of what you'd expect.",
    "output": "もう一つ知っておくとよいこととしては、スプレー木という面白いアイディアがSleatorとTarjanによって考え出されました。赤黒木やAVL木では、挿入や削除のときにしか変化しません。"
  },
  {
    "index": "F1181",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Splay trees modify themselves, even when you're doing look ups, even when you're doing searches.",
    "output": "スプレー木では、自分自身を変更します。探索の場合でも、検索だけをしているときでもです。"
  },
  {
    "index": "F1182",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, they're sometimes called self-adjusting trees for that reason.",
    "output": "このため、自己調節木と呼ばれることもあります。"
  },
  {
    "index": "F1183",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And it's super simple, but they still have kind of amazing guarantees.",
    "output": "それにとてもシンプルで、驚くような性質を保証します。"
  },
  {
    "index": "F1184",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then finally, going beyond the, just the binary tree paradigm many of you might want to look up examples of B trees or also B+ trees.",
    "output": "また最後には、二分木の枠組みを越えて、B木とB+木も見ておいたほうがよいでしょう。"
  },
  {
    "index": "F1185",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Here what the idea is, in a given node you're going to have not just one key but many keys and from a node, you have multiple branches that you can take depending where you're searching for falls with respect to the multiple keys that are at that node.",
    "output": "ここでのアイディアは、あるノードについて唯一のキーではなく多くのキーを持ち、ノードからは持っているキーの数に応じて多数の枝が出ます。"
  },
  {
    "index": "F1186",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The motivation in a database context for going beyond the binary paradigm, is to have a better match up with the memory hierarchy.",
    "output": "二分木の枠組みを超えたデータベースにおける動機はメモリの階層構造にうまくあった構造を持つことです。"
  },
  {
    "index": "F1187",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that's also very important, although a little bit out of the scope here.",
    "output": "これは非常に重要なことですが、この講義の範囲を越えます。"
  },
  {
    "index": "F1188",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That said, what we discuss about red-black trees, much of the intuition will translate to all of these other balance tree data structures, if you ever find yourself in a position where you need to learn more about them.",
    "output": "つまり、ここでお話するのは赤黒木についてで、もっと学ぶ必要があり、学ぶべき場所がわかればここで得られた洞察の多くはほかの平衡木構造に置き換えて考えられるでしょう。"
  },
  {
    "index": "F1189",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, red black trees are just the same as binary search trees, except they also always maintain a number of additional invariants.",
    "output": "赤黒木はただの二分探索木と同じです。ただし、新しく幾つかの不変条件を維持しています。"
  },
  {
    "index": "F1190",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so, what I'm going to focus on in this video is, first of all, what the invariants are, and then how the invariants guarantee that the height will be logarithmic.",
    "output": "このビデオではじめに説明するのは、どんな不変条件があるかということ、またどのようにしてその不変条件から、高さが対数的になることを保証するかです。"
  },
  {
    "index": "F1191",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Time permitting, at some point, there will be optional videos more about the guts, more about the implementations of red black trees namely how do you maintain these invariants under insertions and deletions.",
    "output": "時間が許せば、どこかの時点で、補助的なビデオで核心となる赤黒木の実装がどのようにして、挿入や削除のもとでこうした不変条件を維持するのか説明するかもしれません。"
  },
  {
    "index": "F1192",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's quite a bit more complicated, so that's appropriate for, for optional material.",
    "output": "この話はとても込み入っているので、オプショナルな資料にするほうがよいと思います。"
  },
  {
    "index": "F1193",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But understanding what the invariants are and what role they play in controlling the height is very accessible, and it's something I think every programmer should know.",
    "output": "ただし、不変条件とはなにか、不変条件が高さの制御にどのような役割を持つかということは、あらゆるプログラマが知っておくべきことだと私は思います。"
  },
  {
    "index": "F1194",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, there, I'm going to write down four invariants and really, the bite comes from the second two, okay, from the third and the fourth invariant.",
    "output": "では4つの不変条件を書き出します。そのうち重要なものは後半ふたつ、つまり3つめと4つめによります。"
  },
  {
    "index": "F1195",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, the first one we're going to store one bit of information additionally at each node, beyond just the key and we're going call this bit as indicating whether it's a red or a black node.",
    "output": "最初のものとして、各ノードに、キーに加えて余計に1ビットの情報を保存します。このビットによって、あるノードが赤か黒かを決めます。"
  },
  {
    "index": "F1196",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You might be wondering, you know, why red black?",
    "output": "たぶん、なぜ赤と黒なのか、疑問に思うでしょう。"
  },
  {
    "index": "F1197",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Well, I asked my colleague, Leo Guibas about that a few years ago.",
    "output": "いや、私も数年前、同じことを同僚のLeoGuibasに聞きました。"
  },
  {
    "index": "F1198",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And he told me that when he and Professor Sedgewick were writing up this article the journals were, just had access to a certain kind of new printing technology that allowed very limited color in the printed copies of the journals.",
    "output": "教えてくれたところによると、彼とSedgewick教授がその論文を書き上げたとき、論文誌では限られた印刷技術しか使うことができず、出版するには限られた種類の色しか使えませんでした。"
  },
  {
    "index": "F1199",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so, they were eager to use it, and so they named the data structure red black, so they could have these nice red and black pictures in the journal article.",
    "output": "だから単にその色を使い、データ構造に赤黒木と名付け、論文でもちゃんと赤と黒の絵を使えたというわけです。"
  },
  {
    "index": "F1200",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Unfortunately, there was then some snafu, and at the end of the day, that technology wasn't actually available, so it wasn't actually printed the way they were envisioning it but the name has stuck.",
    "output": "残念ながらその後混乱があり、そうした印刷技術は結局使えませんでした。なので論文は彼らが思い描いていた通りには印刷されませんでしたが、名前は残ったというわけです。"
  },
  {
    "index": "F1201",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that's the rather idiosyncratic reason why these data structures got the name that they did, red black trees.",
    "output": "これが、このデータ構造がどうしてこのような名前になったかという面白い理由です。"
  },
  {
    "index": "F1202",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, secondly we're going to maintain the invariant that the roots of the search tree is always black, it can never be red.",
    "output": "次に二番目の不変条件ですが、探索木のルートノードは常に黒です。赤にはなりません。"
  },
  {
    "index": "F1203",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, with the superficial pair of invariants out of the way, let's go to the two main ones.",
    "output": "では、表面的な不変条件がわかったところで、残りの2つの主要な条件について見てみましょう。"
  },
  {
    "index": "F1204",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "By which, I mean, if you have a red node in the search tree, then its children must be black.",
    "output": "まずはじめに、赤ノードが並ぶことはありません。つまり、赤ノードがツリーにあれば、その子ノードは必ず黒です。"
  },
  {
    "index": "F1205",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If you think about for a second, you realize this also implies that if a notice red, and it has a parent, then that parent has to be a black node.",
    "output": "もうちょっと考えてみればおわかりでしょうが、つまり赤ノードがあれば、それは必ず親を持ち、また親は必ず黒ノードになります。"
  },
  {
    "index": "F1206",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, in that sense, there are no two red nodes in a row anywhere in the tree.",
    "output": "そういう意味で、ツリーのどこででも赤ノードが並ぶことはありません。"
  },
  {
    "index": "F1207",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And the final invariant which is also rather severe is that every path you might take from a root to a null pointer, passes through exactly the same number of black nodes.",
    "output": "最後の不変条件も厳しく、ルートノードから先端まで取ることのできるどんな経路を取っても正確に同じ数の黒ノードがなければいけません。"
  },
  {
    "index": "F1208",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, to be clear on what I mean by a root null path, what you should think about is an unsuccessful search, right?",
    "output": "ルートからの経路という意味を明確にしましょう。考えるべきは失敗した探索ですよね?"
  },
  {
    "index": "F1209",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, what happens in an unsuccessful search, you start at the root depending on whether you need to go smaller or bigger, you go left or right respectably.",
    "output": "失敗した探索では、ルートからはじめて、大きいか小さいかに応じて右か左かに行きます。"
  },
  {
    "index": "F1210",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You keep going left right as appropriate until eventually you hit a null pointer.",
    "output": "右か左かにたどっていって、nullポインタに到達します。"
  },
  {
    "index": "F1211",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, I want you to think about the process that which you start at the root and then, eventually, fall off the end of the tree.",
    "output": "つまり皆さんに考えてみてほしいのは、ルートからはじめて、最後にはツリーの末端まで行き着く処理です。"
  },
  {
    "index": "F1212",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In doing so, you traverse some number of nodes.",
    "output": "そうするなかで、ある数のノードを調べることになります。"
  },
  {
    "index": "F1213",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Some of those nodes will be black some of those nodes will be red.",
    "output": "そのうち一部は黒ノードで、一部は赤ノードでしょう。"
  },
  {
    "index": "F1214",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And I want you to keep track of the number of black nodes and the constraints that a red black tree, by definition, must satisfy, is that no matter what path you take through the tree starting from the root terminating at a null pointer, the number of black nodes traversed, has to be exactly the same.",
    "output": "そして黒ノードの数を考えてみましょう。赤黒木の条件では、定義上、どんな経路をたどってルートからnullポインタまでたどっても、たどる黒ノードの数は全く同じになる、という条件を満たさないといけません。"
  },
  {
    "index": "F1215",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It cannot depend on the path, it has to be exactly the same on every single root null path.",
    "output": "経路によって変わってはいけません。同じルートからは完全に同じです。"
  },
  {
    "index": "F1216",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Let's move on to some examples.",
    "output": "いくつか例を見てみましょう。"
  },
  {
    "index": "F1217",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, here's a claim.",
    "output": "こういうことです。"
  },
  {
    "index": "F1218",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And this is meant to, kind of, whet your appetite for the idea that red black trees must be pretty balanced.",
    "output": "赤黒木がうまくバランスしなければならないという考え方を示します。"
  },
  {
    "index": "F1219",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "They have to have height, basically logarithmic.",
    "output": "高さは、基本的には対数的でなければなりません。"
  },
  {
    "index": "F1220",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, remember, what's the most unbalanced search tree?",
    "output": "考えてみましょう。一番バランスしてないツリーは何でしょう?"
  },
  {
    "index": "F1221",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, the claim is, even a chain with three nodes can not be a red black tree.",
    "output": "つまり、言いたいのは3ノードのチェインであっても赤黒木ではないということです。"
  },
  {
    "index": "F1222",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, what's the proof?",
    "output": "その証明は?"
  },
  {
    "index": "F1223",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, maybe, with the key values one, two and three.",
    "output": "仮に、キーを1,2,3とします。"
  },
  {
    "index": "F1224",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, the question that we're asking is, is there a way to color the node, these three nodes, red and black so that all four of the invariants are satisfied.",
    "output": "すると問題は、この3つのノードを赤か黒に色をつけ4つの不変条件を満たすような方法はあるだろうか、ということです。"
  },
  {
    "index": "F1225",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, we need to color each red or black.",
    "output": "ノードを赤か黒にわけます。"
  },
  {
    "index": "F1226",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, we have four possibilities for how to use the color two and three.",
    "output": "2と3の色分けについては、4通りの可能性があります。"
  },
  {
    "index": "F1227",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But really, because of the third invariant, we only have three possibilities.",
    "output": "ですが条件3により、3つの可能性しかありません。"
  },
  {
    "index": "F1228",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We can't color two and three both red, cuz then we'd have two reds in a row.",
    "output": "2と3をどちらも赤にしてはいけません。"
  },
  {
    "index": "F1229",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, we can either make two red, three black, two black, three red, or both two and three black.",
    "output": "そこで2が赤で3が黒、2が黒で3が赤、両方とも黒、という可能性があります。"
  },
  {
    "index": "F1230",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And all of the cases are the same.",
    "output": "このどれも同じです。"
  },
  {
    "index": "F1231",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Just to give one example, suppose that we colored the node two, red, and one and three are black.",
    "output": "一例として、2が赤で3が黒としましょう。"
  },
  {
    "index": "F1232",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The claim is invariant four has been broken and invariant four is going to be broken no matter how we try to color two and three red and black.",
    "output": "ここでは条件4が破られています。実は条件4は2と3をどのように色分けしても破られます。"
  },
  {
    "index": "F1233",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It says, really on any unsuccessful search, you pass through the same number of black nodes.",
    "output": "どんな失敗する探索でも、全く同じ数の黒ノードを通るということです。"
  },
  {
    "index": "F1234",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so, one unsuccessful search would be, you search for zero.",
    "output": "失敗する探索のひとつは、たとえば0です。"
  },
  {
    "index": "F1235",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And if you search for a zero, you go to the root, you immediately go left to hit a null pointer.",
    "output": "0を探索すると、ルートを見て左に行き、nullポインタに到達します。"
  },
  {
    "index": "F1236",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, you see exactly one black node.",
    "output": "つまり1つの黒ノードに到達します。"
  },
  {
    "index": "F1237",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "On the other hand, suppose you searched for four, then you'd start at the root, and you'd go right, and you go to two, you'd go right, and you go to three, you'd go right again, and only then will you get a null pointer.",
    "output": "一方、4を探索したとしましょう。ルートからはじめて右へ行き、2に行き、さらに右へ、3に行き、さらに右へ、そしてnullポインタに到達します。"
  },
  {
    "index": "F1238",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And on that, unsuccessful search, you'd encounter two black nodes, both the one and the three.",
    "output": "この場合、失敗した探索で2つの黒ノードにぶつかります。1と3です。"
  },
  {
    "index": "F1239",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, it's a violation of the fourth invariant, therefore, this would not be a red black tree.",
    "output": "つまり不変条件4が破られています。したがって、これは赤黒木ではありません。"
  },
  {
    "index": "F1240",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "I'll leave that for you to check, that no matter how you try to code two and three red or black, you're going to break one of the invariants.",
    "output": "どのように2と3を塗り分けてもどれかの不変条件が破られるという確認は自分で確認してみてください。"
  },
  {
    "index": "F1241",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If they're both red, you'd break the third invariant. If at most one is red, you'd break the fourth invariant.",
    "output": "少なくとも1つが赤なら、条件4は破られます。"
  },
  {
    "index": "F1242",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that's a non-example of a red-black tree.",
    "output": "つまりこれは赤黒木ではないという例です。"
  },
  {
    "index": "F1243",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, let's look at an example of a red-black tree.",
    "output": "では赤黒木の例も見てみましょう。"
  },
  {
    "index": "F1244",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "One, a search tree where you can actually color the nodes red or black so that all four invariants are maintained.",
    "output": "ある探索木が、実際にノードを赤と黒に塗り分け、全ての4つの不変条件が満たされるようなものです。"
  },
  {
    "index": "F1245",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, one search tree which is very easy to make red black is a perfectly balanced one.",
    "output": "赤黒木のとても簡単な例は、完全にバランスした木です。"
  },
  {
    "index": "F1246",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, for example, let's consider this three nodes search tree has the keys three, five, and seven and let's suppose the five is the root.",
    "output": "たとえば、このように3つのノードがあって、3,5,7のキーがあり5がルートになっているとします。"
  },
  {
    "index": "F1247",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, it has one child on each side, the three and the seven.",
    "output": "両側に子ノードがひとつずつあります。3と7です。"
  },
  {
    "index": "F1248",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, can this be made a red black tree?",
    "output": "これは赤黒木でしょうか?問題は何だったでしょうか?"
  },
  {
    "index": "F1249",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's asking can we color theses three nodes some combination of red and black so that all four of the invariants are satisfied?",
    "output": "この3つのノードを赤か黒に塗り分けて、4つの不変条件を全て満たすような方法はあるか?ということです。"
  },
  {
    "index": "F1250",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If you think about it a little bit, you realize, yeah, you can definitely color these nodes red or black to make and satisfy for the invariants.",
    "output": "ちょっと考えてみると、そう、たしかにこのノードを塗り分けて条件を満たすことができることがわかるでしょう。"
  },
  {
    "index": "F1251",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In particular, suppose we color all three of the nodes, black.",
    "output": "とくに、全部のノードを黒だとしましょう。"
  },
  {
    "index": "F1252",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We've satisfied variant number one, we've colored all the nodes.",
    "output": "すべてのノードには色がついています。条件2も満たされます。"
  },
  {
    "index": "F1253",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We've satisfied variant number two, and particularly, the root is black.",
    "output": "ルートノードは黒です。条件3も満たされます。"
  },
  {
    "index": "F1254",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And, if you think about it, we've satisfied invariant four because this tree is perfectly balanced.",
    "output": "そして、考えてみると、条件4も満たされます。なぜなら、ツリーは完全にバランスしているからです。"
  },
  {
    "index": "F1255",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "No matter what you unsuccessfully search for, you're going to encounter two black nodes.",
    "output": "どういう探索で失敗しても、必ず2つの黒ノードを通過します。"
  },
  {
    "index": "F1256",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If you search for, say, one, you're going to encounter three and five.",
    "output": "たとえば1を検索すると、3と5を通ります。"
  },
  {
    "index": "F1257",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If you search for, say, six, you're going to encounter five and seven.",
    "output": "6を検索すれば、5と7を通ります。"
  },
  {
    "index": "F1258",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, all root null paths have exactly two black nodes and variant number four is also satisfied.",
    "output": "つまり、ルートからのあらゆる経路は正確に2つの黒ノードを持ち、第4の不変条件も満たされます。"
  },
  {
    "index": "F1259",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that's great.",
    "output": "素晴らしい。"
  },
  {
    "index": "F1260",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But, of course, the whole point of having a binary search tree data structure is you want to be dynamic.",
    "output": "ですがもちろん、二分探索木のポイントは、動的にしたいということです。"
  },
  {
    "index": "F1261",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You want to accommodate insertions and deletions.",
    "output": "挿入や削除に対応できないといけません。"
  },
  {
    "index": "F1262",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Every time you have an insertion or a deletion into a red black tree, you get a new node.",
    "output": "挿入や削除のたびに、赤黒木に新しいノードができます。"
  },
  {
    "index": "F1263",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Let's say, an insertion, you get a new node, you have to color it something.",
    "output": "たとえば挿入の場合、新しいノードができて色を決めねばなりません。"
  },
  {
    "index": "F1264",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And now, all of a sudden, you got to worry about breaking one of these four invariants.",
    "output": "すると突然、4つの不変条件のどれも破られないか心配になってきますね。"
  },
  {
    "index": "F1265",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, let me just show you some easy cases where you can accommodate insertions without too much work.",
    "output": "では、あまり大変なことをしなくても挿入できるような、簡単な場合を見てみます。"
  },
  {
    "index": "F1266",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Time permitting we will include some optional videos with the notion of rotations which do more fundamental restructuring of search trees so that they can maintain the four invariants, and stay nearly perfectly balanced.",
    "output": "またの機会に、オプショナルなビデオでツリーの回転によって、もっと根本的な探索木の再構築を行い、4つの不変条件を維持してバランスした状態を保つための解説をします。"
  },
  {
    "index": "F1267",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, if we have this red black tree where everything's black, and we insert, say, six, that's going to get inserted down here.",
    "output": "では、ここに赤黒木があって、全部のノードが黒だとします。そして例えば6を挿入します。"
  },
  {
    "index": "F1268",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, if we try to color it black, it's no longer going to be a red black tree.",
    "output": "ここでもし、これを黒にすると、もう赤黒木ではありません。"
  },
  {
    "index": "F1269",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And that's because, if we do an unsuccessful search now for, say, 5.5, we're going to encounter three black nodes, where if we do an unsuccessful search for one, we only encounter two black nodes.",
    "output": "なぜなら、たとえば5.5を探索すると、3つの黒ノードに遭遇することになるからです。ここで1を探索すると、2つの黒ノードにしか遭遇しません。"
  },
  {
    "index": "F1270",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But the way we can fix it is instead of coloring the six black, we color it red.",
    "output": "ですが6を黒にするかわりに、赤にするとうまくいきます。"
  },
  {
    "index": "F1271",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And now, this six is basically invisible to invariant number four.",
    "output": "この場合、6は条件4からは無関係になります。"
  },
  {
    "index": "F1272",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, because you have two black nodes in all roots in all paths before, before the six was there, that's still true now that you have this red six.",
    "output": "元のツリーではどのパスでも2つの黒ノードがあるのでした。6が来る前は。"
  },
  {
    "index": "F1273",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, all four invariants are satisfied once you insert the six and color it red.",
    "output": "そして、6が赤ならこれは変わりません。つまり、6を挿入しても赤くすれば4つの条件は全て満たされます。"
  },
  {
    "index": "F1274",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If we then insert, say, an eight, we can pull exactly the same trick, we can call it an eight red.",
    "output": "次に、たとえば8を挿入しましょう。全く同じやり方が使えます。"
  },
  {
    "index": "F1275",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Again, it doesn't participate in invariant four at all so we haven't broken it.",
    "output": "同じく、このノードは条件4には参加しません。なので破られません。"
  },
  {
    "index": "F1276",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Moreover, we still don't have two reds in a row, so we haven't broken invariant number three either.",
    "output": "さらに言えば、2つの赤ノードは並んでいないので、条件3も破られていません。"
  },
  {
    "index": "F1277",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, this is yet another red black tree.",
    "output": "というわけで、これも赤黒木です。"
  },
  {
    "index": "F1278",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In fact, this is not the unique way to color the nodes of this search tree, so that it satisfies all four of the invariants.",
    "output": "実は、この赤黒木を4つの条件を満たしつつ塗り分けるのはこれだけではありません。"
  },
  {
    "index": "F1279",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If we, instead, recolor six and eight black, but at the same time, recolor the node seven, red, we're also golden.",
    "output": "たとえば、6と8を黒に変更します。ただ同時に、7を赤に塗り分けます。"
  },
  {
    "index": "F1280",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Clearly, the first three invariants are all satisfied.",
    "output": "明らかに最初の3つの不変条件は満たされます。"
  },
  {
    "index": "F1281",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But also, in pushing the red upward, consolidating the red at six and eight, and putting it at seven instead, we haven't changed the number of black nodes on any given path.",
    "output": "また、6と8の赤を合併して上に押し上げ、7を赤にすることで、黒ノードの数は、どんな経路でもかわりません。"
  },
  {
    "index": "F1282",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Any black, any path that previously went through six, went through seven, anything that went through eight, went through seven so there's exactly the same number of red and black nodes on each such path as there was before.",
    "output": "6を通ったパスは7を通りますし、8を通った経路も7を通ります。だから、これまでと同じく、正確に同じ数の赤と黒のノードが、どちらの経路でも存在します。"
  },
  {
    "index": "F1283",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, all paths still have equal number of black nodes and invariant four remains satisfied.",
    "output": "つまり、全ての経路が同じ数の黒ノードを持ち、条件4は満たされます。"
  },
  {
    "index": "F1284",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "As I said, I've shown you here only simple examples, where you don't have to do much work on an insertion to retain the red black properties.",
    "output": "ここでは、ごく単純な例だけをお見せしています。挿入の際、赤黒の性質を守るために大したことは必要ありません。"
  },
  {
    "index": "F1285",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In general, if you keep inserting more and more stuff and certainly if you do the deletions, you have to work much harder to maintain those four invariants.",
    "output": "一般に、もっとたくさんのものを挿入したり削除すると、4つの不変条件を維持するために大変なことをしなければいけなくなります。"
  },
  {
    "index": "F1286",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Time permitting, we'll cover just a taste of it in some optional videos.",
    "output": "時間が許せば、オプショナルなビデオでそのさわりを説明します。"
  },
  {
    "index": "F1287",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, what's the point of these seemingly arbitrary four invariants of a red black tree?",
    "output": "ところで、赤黒木に足された一見適当な条件の要点は何でしょうか?"
  },
  {
    "index": "F1288",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Well, the whole point is that if you satisfy these four invariants in your search tree, then your height is going to be small.",
    "output": "実は4つの不変条件を全て満たすようにすると、高さが小さくなるというのが要点です。"
  },
  {
    "index": "F1289",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And because your height's going to be small, all your operations are going to be fast.",
    "output": "そして高さが小さくなるので、全ての操作が速くなるのです。"
  },
  {
    "index": "F1290",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, let me give you a proof that if a search tree satisfies the four invariants, then it has super small height.",
    "output": "では、4つの不変条件を満たすと、高さがとても小さくなることを証明します。"
  },
  {
    "index": "F1291",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In fact, no more than double the absolute minimum that we conceivably have, almost two times log base two of N.",
    "output": "実は、考えうる最小値の倍ほぼlog2(N)の2倍を超えません。2(N+1)となります。"
  },
  {
    "index": "F1292",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And what's clear about this proof is it's very obvious the role played by this invariants three and four.",
    "output": "証明しましょう。この証明についてはっきりしているのは、不変条件3と4の果たす役割です。"
  },
  {
    "index": "F1293",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Essentially, what the invariants guarantee is that, a red black tree has to look like a perfectly balanced tree with at most a sort of factor two inflation.",
    "output": "本質的に、この不変条件が保証するのは、赤黒木は完全平衡木にある係数の増加を加えたようになります。"
  },
  {
    "index": "F1294",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, let's see exactly what I mean.",
    "output": "どういう意味か見てみましょう。"
  },
  {
    "index": "F1295",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, let's begin with an observation.",
    "output": "とある考え方から始めます。"
  },
  {
    "index": "F1296",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And this, this has nothing to do with red black trees.",
    "output": "ここでは、赤黒木には何もしません。色のことはいったん忘れてください。"
  },
  {
    "index": "F1297",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Forget about the colors for a moment, and just think about the structure of binary trees.",
    "output": "二分木の構造だけを考えます。"
  },
  {
    "index": "F1298",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And let's suppose we have a lower bound on how long root null paths are in the tree.",
    "output": "そして、ツリーの中のルートノードからの経路の長さに下限があるとします。"
  },
  {
    "index": "F1299",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, for some parameter k, and go ahead and think of k as, like, ten if you want.",
    "output": "これをkとしましょう。kを、たとえば10とでも考えてみてください。"
  },
  {
    "index": "F1300",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Suppose we have a tree where if you start from the root, and no matter how it is you navigate left and right, child pointers until you terminate in a null pointer.",
    "output": "あるツリーがあってルートからはじめ、左右のどのように経路をたどってnullポインタまで到達しても、どう選んでも、少なくともk個のノードはたどることになります。"
  },
  {
    "index": "F1301",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If that hypothesis is satisfied, then if you think about it, the top of this tree has to be totally filled in.",
    "output": "もしこの仮定が満たされるなら、考えてみてください、このツリーの上位は完全に埋まっています。"
  },
  {
    "index": "F1302",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, the top of this tree has to include a perfectly balanced search tree, binary tree of depth k - 1.",
    "output": "このツリーの上位は完全平衡木になっています。高さk-1の二分木です。"
  },
  {
    "index": "F1303",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, let me draw a picture here of the case of k = three.",
    "output": "では、k=3となるようなツリーを描いてみます。"
  },
  {
    "index": "F1304",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, if no matter how you go from the root to a null pointer, you have to see at least three nodes along the way.",
    "output": "ルートからnullポインタまでどのように移動しても、必ず最低3つのノードを見るということです。"
  },
  {
    "index": "F1305",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That means the top three levels of this tree have to be full.",
    "output": "孫ノードは全部で4つ。この考え方を、背理法で証明します。"
  },
  {
    "index": "F1306",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, you have to have the root.",
    "output": "実際、上位k階層のノードのどれかが欠けていたとすると、k個のノードをたどる前にnullポインタに到達する経路が存在します。"
  },
  {
    "index": "F1307",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The proof of this observation is by contradiction. If, in fact, you were missing some nodes in any of these top k levels.",
    "output": "ここでのポイントは、この下限から、ツリー内のノード数の下限が、ルートからnullまでの経路の長さの関数として与えられるということです。"
  },
  {
    "index": "F1308",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, what's the point is, the point is this gives us a lower bound on the population of a search tree as a function of the lengths of its root null paths.",
    "output": "ツリーの大きさNは深さk-1の完全平衡木のノード数、つまり2のk乗-1を含みます。"
  },
  {
    "index": "F1309",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, the size N of the tree must include at least the number of nodes in a perfectly balanced tree of depth k - 1 which is 2^k - 1, So, for example, when k = 3, it's 2^3 (two cubed) - 1, or 7 that's just a basic fact about trees, nothing about red black trees.",
    "output": "たとえばk=3なら2の3乗-1の7です。"
  },
  {
    "index": "F1310",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, let's now combine that with a red black tree invariant to see why red black trees have to have small height.",
    "output": "ではこれと赤黒木の不変条件を組み合わせて、なぜ赤黒木が低くなるか考えましょう。"
  },
  {
    "index": "F1311",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So again, to recap where we got to on the previous slide.",
    "output": "また、前のスライドの結論を振り返りましょう。"
  },
  {
    "index": "F1312",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The size N, the number of nodes in a tree, is at least 2^k - 1, where k is the fewest number of nodes you will ever see on a root null path.",
    "output": "ツリーのノード数Nは、少なくとも2のk乗-1はあります。ここでkは、ルートからnullまでの経路の一番小さい値です。"
  },
  {
    "index": "F1313",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, let's rewrite this a little bit and let's actually say, instead of having a lower bound on N in terms of k, let's have an upper bound on k in terms of N.",
    "output": "このことを少し書き換えて、kに対してNに制約を与えるのではなく、Nからkの上限を決めましょう。"
  },
  {
    "index": "F1314",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, the length of every root null path, the minimum length of every root null path is bounded above by log base two of quantity N + 1.",
    "output": "つまり、ルートからのあらゆる経路の長さの最小値は、log2(N+1)より大きくなることはありません。"
  },
  {
    "index": "F1315",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This is just adding one to both sides and taking the logarithm base two.",
    "output": "これは単に両辺に1を足して2を底とした対数を取るだけです。"
  },
  {
    "index": "F1316",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, what does this buy us?",
    "output": "では、これの何がいいんでしょうか?"
  },
  {
    "index": "F1317",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Well, now, let's start thinking about red black trees.",
    "output": "では赤黒木について考えましょう。"
  },
  {
    "index": "F1318",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So now, red black tree with N nodes.",
    "output": "ノード数Nの赤黒木です。"
  },
  {
    "index": "F1319",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "What does this say?",
    "output": "何が言えるでしょうか?"
  },
  {
    "index": "F1320",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This says that the number of nodes, forget about red or black, just the number of nodes on some root null path has to be the most log base two of N + 1.",
    "output": "赤黒木と関係なくあるルートからnullまでの経路のノードの数は、たかだかlog2(N+1)です。最善の場合で。"
  },
  {
    "index": "F1321",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Maybe some of them are red, but in the, in, the maximum case, all of them are black.",
    "output": "いくらかは赤ノードですが、最大の場合では、全てが黒ノードです。"
  },
  {
    "index": "F1322",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, we can write in a red black tree with N nodes, there is a root null path with at most log base two of N + 1, black nodes.",
    "output": "つまり、Nノードの赤黒木について次のことが言えます。ルート-null経路には、最大でもlog2(N+1)の黒ノードしか含まれない。"
  },
  {
    "index": "F1323",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This is an even weaker statement than what we just proved.",
    "output": "これは、証明したことよりは弱い主張です。"
  },
  {
    "index": "F1324",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We proved that it have some, somehow must have at most log based two, n + 1 total nodes.",
    "output": "証明したのは、log2(N+1)ノードを必ず持つということですから。"
  },
  {
    "index": "F1325",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, certainly, that path has the most log base two of N + 1 black nodes.",
    "output": "黒ノードを持つことがわかりました。"
  },
  {
    "index": "F1326",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, let's, now let's apply the two knockout punches of our two invariants.",
    "output": "では2つの不変条件から2つのノックアウトパンチを繰り出しましょう。"
  },
  {
    "index": "F1327",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Alright, so fundamentally, what is the fourth invariant telling us?",
    "output": "そもそも、4つの不変条件は何を言っていたでしょうか?"
  },
  {
    "index": "F1328",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's telling us that if we look at a path in our red black tree, we go from the root, we think about, let's say, that's an unsuccessful search, we go down to a null pointer.",
    "output": "言っていたのは赤黒木の経路を見た時、ルートからはじめて失敗した探索を考えました。nullポインタまでたどります。"
  },
  {
    "index": "F1329",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It says, if we think of the red nodes as invisible, if we don't count them in our tally, then we're only going to see log, basically a logarithmic number of nodes.",
    "output": "そして、赤ノードが見えないとして、全然数えないとすると、経路には対数的な数のノードしかないということです。"
  },
  {
    "index": "F1330",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But when we care about the height of the red black tree, of course, we care about all of the nodes, the red nodes and the black nodes.",
    "output": "もちろん、赤黒木の高さについて考えるときは、すべてのノードを考えます。赤ノードと黒ノードを。"
  },
  {
    "index": "F1331",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, so far we know, that if we only count black nodes then we're good, We only have log base two of N + 1 nodes that we need to count. So, here's where the third invariant comes in.",
    "output": "これまでのところ、黒ノードしか考えないと、うまくいって、log2(N+1)個のノードだけしかないということです。"
  },
  {
    "index": "F1332",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It says, well actually, black nodes are a majority of nodes in the tree.",
    "output": "この条件は実は、ツリーでは黒ノードが多数派だと言っています。"
  },
  {
    "index": "F1333",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In a strong sense, there are no two reds in a row, on any path.",
    "output": "もともとは、どんな経路でも赤ノードが並ばないということです。"
  },
  {
    "index": "F1334",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, if we know the number of black nodes is small, then because you can't have two reds in a row, the number of total nodes on the path is at most twice as large.",
    "output": "もし黒ノードの数が少なければ、赤ノードを並べることはできないので、経路上のノード数も2倍にしかなりません。"
  },
  {
    "index": "F1335",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In the worst case, you have a black route, then red, then black, then red, then black, then red, then black, et cetera.",
    "output": "最悪の場合で、黒のルートノードがあり、赤ノード、次に黒、次に赤黒、赤、黒、などとなります。"
  },
  {
    "index": "F1336",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "At the worst case, the number of red nodes is equal to the number of black nodes, which doubles the length of the path once you start counting the red nodes as well.",
    "output": "最悪の場合でも赤ノードの数は黒ノードの数と等しくなります。経路の長さは、赤ノードを考えた時、倍になります。"
  },
  {
    "index": "F1337",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And this is exactly what it means for a tree to have a logarithmic depth.",
    "output": "そして、これはまさしく、ツリーの高さが対数的になるということです。"
  },
  {
    "index": "F1338",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, this, in fact, proves the claim, if the search trees satisfies the invariants one through four, in particular if there's no two reds in a row and all root null paths have an equal number of black nodes, then, knowing nothing else about this search tree, it's got to be almost balanced.",
    "output": "実際、これはもしツリーが4つの不変条件を満たすなら、とくに赤ノードが並ばないというのと、黒ノードの経路上の数が等しいというなら、ツリーのことは他に何も知らなくても、ツリーはバランスされるという主張が証明されます。"
  },
  {
    "index": "F1339",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's perfectly balanced up to a factor of two.",
    "output": "2を底として完全にバランスされます。"
  },
  {
    "index": "F1340",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And again, the point then is that operations in a search tree and the search trees are going to run in logarithmic time, because the height is what governs the running time of those operations.",
    "output": "また、ポイントとしては、探索木の操作も対数時間で実行されます。なぜなら、高さがこうした操作の実行時間を支配するからです。"
  },
  {
    "index": "F1341",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, in some sense, I've only told you the easy part which is if it just so happens that your search tree satisfies these four invariants, then you're good.",
    "output": "さて、ある意味では、簡単な部分はお話しました。探索木が4つの不変条件を満たすなら、それでうまく行く。"
  },
  {
    "index": "F1342",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Clearly that's exactly what you want from this data structure.",
    "output": "明らかにこれが、このデータ構造から欲しかったことです。"
  },
  {
    "index": "F1343",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But for the poor soul who has to actually implement this data structure, the hard work is maintaining these invariants even as the data structure changes.",
    "output": "ただ、このデータ構造を実際に実装しないといけない哀れな者どもは、データ構造が変化しても不変条件を維持するための労力をかけることになります。"
  },
  {
    "index": "F1344",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Remember, the point here is to be dynamic, to accommodate insertions and deletions.",
    "output": "ここでの問題は動的であること、挿入と削除に対応することです。"
  },
  {
    "index": "F1345",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And searches and deletions can disrupt these four invariants and then one has to actually change the code to make sure they're satisfied again, so that the tree stays balanced, has low height, even under arbitrary sequences of insertions and deletions.",
    "output": "挿入と削除は4つの不変条件を台なしにするかもしれないので、コードを書き換えて条件を満たすようにすることで、ツリーを平衡に保ち、どんな挿入と削除の順番でも高さを保つ必要があります。"
  },
  {
    "index": "F1346",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, we're not going to cover that in this video.",
    "output": "この部分は、このビデオでは扱いません。"
  },
  {
    "index": "F1347",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It can be done, without significantly slowing down any of the operations.",
    "output": "操作のどれも明らかに遅くすることなしに実現できます。"
  },
  {
    "index": "F1348",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's pretty tricky, takes some nice ideas.",
    "output": "これはとても複雑で、面白いアイデアを使います。"
  },
  {
    "index": "F1349",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "There's a couple well-known algorithms textbooks that cover those details.",
    "output": "有名なアルゴリズムがいくつかあり、教科書に詳しく書いてあります。"
  },
  {
    "index": "F1350",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Or if you look at open source and limitations of balanced search trees, you can look at code that does that implementations.",
    "output": "もしくは、オープンソースで平衡探索木のコードを探せば、実装するコードを読むこともできます。"
  },
  {
    "index": "F1351",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But, because it can be done in a practical way and because Red Black Tree supports such an original array of operations, that's why you will find them used in a number practical applications.",
    "output": "ともあれ、現実的に実現でき、しかも赤黒木は豊富な操作をサポートするので、数学アプリケーションでよく見かけます。"
  },
  {
    "index": "F1352",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Well, we're almost done with our discussion of symmetric encryption.",
    "output": "さて、対称暗号についてほどんど議論しつくしたが、次の話題に移る前に議論しておきたいちょっとしたものが少しある。"
  },
  {
    "index": "F1353",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "There are just a couple of odds and ends that I'd like to discuss before we move on to the next topic.",
    "output": "まず最初に言っておきたいことは、私たちがどのようにある鍵から小さな鍵をつくっていくかについてだ。"
  },
  {
    "index": "F1354",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the first thing I'd like to mention is how we derive many keys from one key.",
    "output": "そしてこの問題は実際にいつもつきまとう問題なんだ。だからみんながこの問題にどう正しく対処したらよいか、明らかにしておきたい。"
  },
  {
    "index": "F1355",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And it, actually, this comes up all the time in practice, so I'd like to make sure you know how to do this correctly.",
    "output": "どのような設定にしようか?"
  },
  {
    "index": "F1356",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So what's the setting that we're looking at? Well, imagine we have a certain source key that's generated by one of, a number of methods.",
    "output": "よし、色んな方法で作成されたある元となるキーがあるとしよう。"
  },
  {
    "index": "F1357",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Imagine the source key is generated by a hardware random number generator or perhaps is generated by a key exchange protocol which we're going to discuss later.",
    "output": "そのあるキーはPRGによって作成されたか、またはあとで話す鍵交換プロトコルというものから作成されたとする。"
  },
  {
    "index": "F1358",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But anyhow, there are a number of ways in which a source key might be generated between Alice and Bob, such that the attacker doesn't know what the source key is.",
    "output": "まあいずれにせよ、アリスとボブの間で作成されるキーの作り方はたくさんある。"
  },
  {
    "index": "F1359",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But now, as we said, in many cases, we actually need many keys to secure a session, not just one single source key.",
    "output": "攻撃者に知られていない鍵がね。"
  },
  {
    "index": "F1360",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "For example, if you remember, in TLS there were unidirectional keys and we needed keys in each direction.",
    "output": "さて、言ったようにさまざまな場合で、セッションを安全なものにするためには実際あるひとつの鍵ではなく、たくさんの鍵が必要なんだが、たとえば、もし覚えているなら、TLSは1方向の鍵が必要で、それが両方向に必要だった。"
  },
  {
    "index": "F1361",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And in fact, in each direction, we needed multiple keys. We needed a MAC key, we needed an encryption key.",
    "output": "実際、どちらの方向でも複数の鍵が必要で、MAC用の鍵、暗号化用の鍵、IVが必要などなど。"
  },
  {
    "index": "F1362",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so, the question is, how do we use the one source key that we just derived, either from a hardware process or by key exchange, and generate a bunch of keys from it that we could then use to secure our session.",
    "output": "そこで、問題は私たちがどのように導出した鍵を使うかということだ。それはハードウェアから生成したものでも、鍵交換で手に入れたものでもよい。"
  },
  {
    "index": "F1363",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The way that's done, is using a mechanism called a key derivation function, KDF. And I want to talk a little bit about how KDF's are constructed.",
    "output": "その鍵でたくさんの新しい鍵の束を作成してセッションを安全なものにすることができる。"
  },
  {
    "index": "F1364",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So first of all, suppose we have a secure PRF, that happens to have key space K.",
    "output": "今行ったのは鍵導出関数KDFという仕組みで、もうすこしKDFがどのように構築されるかを話したい。"
  },
  {
    "index": "F1365",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And now, suppose that it so happens that our source key SK is uniform in the key K.",
    "output": "まず、安全なPRFがあるとして、鍵空間はKとする。"
  },
  {
    "index": "F1366",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In this case, the source key is, in fact, a uniform random key for the secure PRF F.",
    "output": "私たちがもっている鍵はSKとする。SKは鍵空間で一様とする。"
  },
  {
    "index": "F1367",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So in this case, the KDF is really simple. The key derivation function would just work as follows.",
    "output": "実際安全なPRFでは、元となる鍵は一様ランダム鍵だ。"
  },
  {
    "index": "F1368",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It would take as input the source key.",
    "output": "そして、この鍵をセッションを安全にする鍵の生成にそのまま使える。"
  },
  {
    "index": "F1369",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It would take an input, a parameter context, which I'm gonna describe in just a minute.",
    "output": "この場合、KDFはほんとに単純で、KDFは次のように働く。"
  },
  {
    "index": "F1370",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then what it will do is it will basically evaluate the PRF on zero.",
    "output": "よし、KDFが何をするかというと、基本的には0についてPDFを評価する。"
  },
  {
    "index": "F1371",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Then it will evaluate the PRF on two, up until L.",
    "output": "それから、1について、2について、と行っていき、Lまで行う。"
  },
  {
    "index": "F1372",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And I will talk about what this context is in just a second.",
    "output": "コンテキストについて話そう。基本的にはセッション。"
  },
  {
    "index": "F1373",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then, basically, you would use as many bits of the output as you would need to generate all the keys for the session. So, if you need unidirectional keys you would generate, you know, one key in each direction where each key might include an encryption key and a MAC key.",
    "output": "あなたが必要な場合は、方向キーを生成するだろう必要がありますので、あなた各キーが、暗号化キーおよびmacが含まれます1つキーレス方向を知っています。"
  },
  {
    "index": "F1374",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so, you would basically generate as many bits as you need and then finally cut off the output at the time when you've generated enough keys to secure your session.",
    "output": "キー。ので、基本的に必要なビットを生成するし、最後に出力オフときにセキュリティで保護するには、十分なキーを生成した時にカットをセッション。"
  },
  {
    "index": "F1375",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay so this is a fairly straight forward mechanism it's basically using the secure PRF as a pseudo random generator.",
    "output": "わかりましたので、これは基本的にを使用してはかなりまっすぐ進むメカニズムです、セキュリティで保護されたPRFは擬似乱数生成器として。"
  },
  {
    "index": "F1376",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And the only question is what is its context string.",
    "output": "唯一の問題は何ですのコンテキスト文字列です。"
  },
  {
    "index": "F1377",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Well, I'll tell you that the context string is basically a unique string that identifies the application.",
    "output": "まあ、コンテキスト文字列が基本的には、一意であることよアプリケーションを識別する文字列。"
  },
  {
    "index": "F1378",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So in fact you might have multiple applications on the same system that's trying to establish multiple secure keys.",
    "output": "だから実際には、複数を必要があります。複数のセキュリティで保護されたキーを確立しようとしては、同じシステム上のアプリケーション。"
  },
  {
    "index": "F1379",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Maybe you have SSH running as one process, you have a web server running as another process, IPsec as a third process and all three need to have secret keys generated.",
    "output": "たぶん1つのプロセスとしては、あなたを実行するwebサーバーがあるSSHをある別プロセス、および3番目としてのipアドレスを処理し、すべての3つの秘密キーが必要生成されました。"
  },
  {
    "index": "F1380",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And this context variable basically tries to separate the three of them.",
    "output": "このコンテキスト変数は基本的に3つの別々にそれら。"
  },
  {
    "index": "F1381",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, let me ask you, more precisely, what do you think the purpose of this context variable is?",
    "output": "だから、私に聞いてより正確に、何これの目的と思うコンテキスト変数ですか?"
  },
  {
    "index": "F1382",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So I guess I've given it away and this context variable is supposed to basically separate applications, so that even if, for example, the three services that we just talked about, SSH, web server, and IPsec, if they all happen to obtain the same source key from the hardware random number generator then the context since it's different for the three apps will make sure that they still get three independent strings that they can then use to secure the sessions.",
    "output": "例では、我々だけ3つのサービス、SSH、話をサーバー、およびIPの設定Web、彼らはすべて同じソースキーからハードウェア乱数を取得するが起こる場合ジェネレーターは、3つのアプリを異なるのでコンテキスト[になります。彼らはまだ彼ら[セキュリティで保護することができる3つの独立した文字列を得ることを確認してセッション。"
  },
  {
    "index": "F1383",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "I just want you to remember that, even though this is actually fairly straightforward, and we discussed this before, the context string is actually important, and it does need to be specific to the application, so that each application gets its own session keys, even if multiple applications happen to sample the same SK.",
    "output": "これは実際にはかなりですが、ことを覚えていて欲しいだけ簡単なとコンテキスト文字列を実際には前に話し合った重要なとは、アプリケーションを特定する必要がので、それぞれアプリケーションでは、独自のセクションのキーを取得します。"
  },
  {
    "index": "F1384",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The next question is, what do we do if the source key actually isn't uniform?",
    "output": "次の質問は、何行う場合ソースキーは実際に均一ではないです。"
  },
  {
    "index": "F1385",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Well, now we got a problem.",
    "output": "我々は問題になりました。"
  },
  {
    "index": "F1386",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If the source key is not a uniform key for the pseudo random function then we can no longer assume that the output of the pseudo random function is indistinguishable from random.",
    "output": "ソースキーでない場合は、制服の擬似ランダム関数キーはもはやと仮定することができ、擬似ランダム関数の出力がランダムから区別されます。"
  },
  {
    "index": "F1387",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In fact, if we just use the KDF that we just described then the output might not look random to the adversary and then he might be able to anticipate some of the session keys that we'll be using and thereby break the session.",
    "output": "実際には場合、使用するだけですし、出力がランダムに見えるかもしれませんが、先ほど述べたKDF敵、彼はいくつかのセッションキーが予期することができる可能性があります。"
  },
  {
    "index": "F1388",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So then we have a problem.",
    "output": "だから、我々は問題があります。"
  },
  {
    "index": "F1389",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now why would this source key not be uniform?",
    "output": "今なぜこのソースキー制服ないだろうか?"
  },
  {
    "index": "F1390",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Well there are many reasons why this happened.",
    "output": "多くの理由はなぜこの起こった。"
  },
  {
    "index": "F1391",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "For example if you use a key exchange protocol, it so happens typically that key exchange protocols will generate a high entropy key.",
    "output": "たとえば通常はたまたま、鍵交換プロトコルを使用してキー交換プロトコル高en-トリッパキーが生成されます。"
  },
  {
    "index": "F1392",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So it's not going to be a uniform string.",
    "output": "だからそれか均一な文字列にはないだろう。"
  },
  {
    "index": "F1393",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It will be uniform in some subset of a larger set, And we'll see examples of that as soon as we talk about key exchange protocols.",
    "output": "サブセット。大規模なのとすぐに我々の語ることの例を見るキー交換プロトコル。"
  },
  {
    "index": "F1394",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so KDFs have to kind of accommodate for the fact that key exchange protocols actually don't generate uniform bit strings.",
    "output": "KDFs種の事実のために対応するので、キー交換プロトコルは実際に均一ビット文字列を生成しないでください。"
  },
  {
    "index": "F1395",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The other problem is, that, in fact, the hardware random number generator you're using might actually produce biased outputs.",
    "output": "その他問題は、実際には、使用しているハードウェア乱数ジェネレーターかもしれないこと、実際に偏りのある出力を生成します。"
  },
  {
    "index": "F1396",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We don't wanna rely on the non bias of the hardware random number generator.",
    "output": "ハードウェアの非バイアスに依存する必要はありません。乱数ジェネレーター。"
  },
  {
    "index": "F1397",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so all we want to assume is that it generates a high entropy string, but one that might be biased.",
    "output": "だから、すべての我々と仮定する必要がある高を生成することエントロピーの文字列が1つは、偏りがある場合があります。"
  },
  {
    "index": "F1398",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In which case, we have to somehow clean this bias.",
    "output": "場合は、私たち必要がなんとかしてあります。"
  },
  {
    "index": "F1399",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so this introduces this, this paradigm for building KDFs.",
    "output": "そして、これは、このパラダイムを紹介しますKDFsを構築します。"
  },
  {
    "index": "F1400",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This is called the extract-then-expand paradigm, where the first step of the KDF is to extract a pseudo random key from the actual source key.",
    "output": "これは、抽出と呼ばれるし、どこの最初のステップのパラダイムを展開KDFは、実際のソースキーから疑似ランダムキーを抽出することです。"
  },
  {
    "index": "F1401",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So in a picture you can think about it like this.",
    "output": "そうでは画像をこのように考えることができます。"
  },
  {
    "index": "F1402",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In some sense these are the different possible values of the source key.",
    "output": "ある意味でこれらが異なっています。ソースキーの値。"
  },
  {
    "index": "F1403",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This is the horizontal line and the vertical axis is basically the probability of each one of these values, and you can see that this is a kind of a bumpy function which would say that the source key is not uniformly distributed in the key space.",
    "output": "これは、水平線と垂直軸のです。基本的に、これらの値のそれぞれの確率と見ることができますは、このソースキーが一様でないことを言うだろうでこぼこ関数の一種です。"
  },
  {
    "index": "F1404",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "What we do in this case is we use what's called an extractor.",
    "output": "この場合は我々を使用すると呼ばれるものです、エクストラクター。"
  },
  {
    "index": "F1405",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So an extractor is something that takes a bumpy distribution and makes it into a uniform distribution over the key space.",
    "output": "抽出でこぼこの分布を作るものですのでそれは、鍵空間を均一な分布に。我々の場合に実際にだけなのです。"
  },
  {
    "index": "F1406",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In our case we're actually just gonna be using what are called computational extractors, namely extractors that don't necessarily produce uniform distribution at the end but they generated distribution that's indistinguishable from uniform.",
    "output": "計算の抽出器と呼ばれるものを使用しようとしました。すなわち必ずしもが最後に一様分布を生成しない抽出器彼らは制服から区別のつかない分布を生成しました。"
  },
  {
    "index": "F1407",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now extractors typically take as input something called a salt, and a salt just like in a salad, it kind of adds flavor to things, what it does is basically kind of jumbles things around, so that no matter what the input distribution is, the output distribution is still going to be indistinguishable from random.",
    "output": "今エクストラクターを通常取るとしてと呼ばれるものを塩と塩だけを入力サラダ、それ種類の味を足すように、それは何基本的のようなものです。どの入力分布の関係なく、出力は、物事をまぜこぜ分布はまだランダムから見分けがつかないことになります。"
  },
  {
    "index": "F1408",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So a salt basically, what is it?",
    "output": "だから、塩基本的には、それは何ですか?"
  },
  {
    "index": "F1409",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's a non-secret string, so it's publicly known.",
    "output": "それが公に知られているので、非秘密の文字列です。"
  },
  {
    "index": "F1410",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It doesn't matter if the adversary knows what the salt is, and it's fixed forever.",
    "output": "それdoesn'tします。どのような塩、敵を知っている場合は、問題とそれが永久に固定されます。"
  },
  {
    "index": "F1411",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The only point is that when you chose it, you chose one at random.",
    "output": "唯一ポイントは、あなたがそれを選んだときに、ランダム選択ことです。"
  },
  {
    "index": "F1412",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then the hope is that the funny distribution that you're trying to extract from kinda doesn't inherently depends on the salt that you chose and hence as a result using your salt, you will actually get a distribution that looks indistinguishable from random.",
    "output": "その後、希望はちょっとから抽出しようとしている面白い分布を本質的にしません。上に塩を選んだしたがって、結果として、塩を使用によって異なります、ランダムからと見分けがつきません分布は実際に取得します。"
  },
  {
    "index": "F1413",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So essentially the salt, you know, you can just bang it the keyboard a couple of times when you generate it but it just needs to be something that's random initially but then it's fixed forever, and it's fine if the adversary knows what it is and nevertheless the extractor is able to extract the entropy and output a uniformly random string K.",
    "output": "とき、それがちょうど生成回ランダムで何かをする必要があります。当初は最後の研究者が何を知っている場合、固定永遠と罰金それし、それにもかかわらず、抽出、エントロピーと出力を抽出することです、一様乱数文字列キー。"
  },
  {
    "index": "F1414",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In some sense the salt is only there to defend against adversarially bad distributions that might mess up our extractor.",
    "output": "いくつかの塩だけを守るには敵対の悪い分布が私たちの抽出を混乱可能性があります。"
  },
  {
    "index": "F1415",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay, so now that we have extracted a pseudo random key.",
    "output": "わかりました、そう今は擬似ランダムキーを抽出しました。"
  },
  {
    "index": "F1416",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, we might as well just use it in a KDF that we just saw using a secure pseudo random function to expand the key into as many bits as we need to actually secure the session.",
    "output": "今、私たちにもちょうどそれをKDF使用可能性があります。我々は安全関数を使用して、キーを展開する見た我々は実際には、セッションを保護する必要がある同じビット数に。"
  },
  {
    "index": "F1417",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay, so there are these two steps.",
    "output": "わかりましたはそこでください。これら2つの手順。"
  },
  {
    "index": "F1418",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The first one is we extract a pseudo-random key, and then once we have a pseudo-random key we already know how to extend it into as many keys as we need using a pseudo-random function.",
    "output": "最初の1つ私たちは擬似乱数キーをし、1回の抽出我々は我々として、多くのキーに拡張する方法を既に知っている擬似乱数キーがあります。我々は、擬似ランダム関数を使用する必要があります。"
  },
  {
    "index": "F1419",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the standardized way of doing this is called HKDF.",
    "output": "私たちがやっている、標準化、これです。"
  },
  {
    "index": "F1420",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This is a KDF, a key derivation function that's built from HMAC.",
    "output": "これは、H-MACから組み込まれているKDFリビジョン関数です。"
  },
  {
    "index": "F1421",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And here HMAC is used both as the PRF for expanding and an extractor for extracting the initial pseudo-random key.",
    "output": "ここでHMACが拡大PRFと抽出抽出ツールの両方として使用されます。初期の擬似キーです。"
  },
  {
    "index": "F1422",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So let me explain how this works.",
    "output": "ので、どのようにこの作品を説明させてください。"
  },
  {
    "index": "F1423",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So in the extract step, we're gonna use our salt which you remember is a public value just happened to be generated at random at the beginning of time.",
    "output": "ので、抽出ステップ、私たちつもりの解決を使用する公共のメンバーを撤回した値だけが起こったランダム時間の先頭が生成されます。"
  },
  {
    "index": "F1424",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And we use this salt as the HMAC key.",
    "output": "この解決としてHMACを使用してキー。"
  },
  {
    "index": "F1425",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then the source key we're gonna use as the HMAC data.",
    "output": "ソースキーはHMACデータとして使用するつもりです。"
  },
  {
    "index": "F1426",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So we're kind of using a public value as a key.",
    "output": "だから我々のようなものにしていますパブリック値をキーとして使用します。"
  },
  {
    "index": "F1427",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And nevertheless, one can argue that HMAC has extraction properties, such that, when we apply HMAC, the resulting key is going to look indistinguishable from random, assuming that the source key actually has enough entropy to it.",
    "output": "私たちがHMacを適用した場合などは、抽出のプロパティ結果のキーになります。一見ランダムなから、実際のソースキーを持つと仮定すると区別がつかない十分なエントロピーは。"
  },
  {
    "index": "F1428",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And now that we have the pseudo random key we're simply going to use HMAC as a PRF to generate a session key of you know as many bits as we need for the session keys.",
    "output": "今は私たちは擬似ランダムキー私たち単につもりです。HMacとしてのPRFを使用して生成するセッションキーを知って、多くのベースとして我々セッションキーを必要があります。"
  },
  {
    "index": "F1429",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay.",
    "output": "わかりました。"
  },
  {
    "index": "F1430",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So that basically concludes our discussion of HKDF.",
    "output": "だから基本的には我々の議論を結論します。HQDF。"
  },
  {
    "index": "F1431",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And I just want you to remember that, once you obtain a source key, either from hardware or from a key exchange protocol, the way you convert it into session keys is not by using that sample directly.",
    "output": "か、元のキーを取得した後、覚えてほしいだけハードウェアやキー交換プロトコルから、道に換算します。セッションキーはないそのサンプルを使用して直接です。"
  },
  {
    "index": "F1432",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You would never use a source key directly as a session key in a protocol.",
    "output": "あなたは決してソースキーを使用しません。直接プロトコル内のセッションキーとして。"
  },
  {
    "index": "F1433",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "What you would do is you will run the source key through a KDF.",
    "output": "だろうと何かを実行、ソースキー、KDFを介して。"
  },
  {
    "index": "F1434",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And the KDF would give you all the keys and output that you need, for, the randomness, for the random keys to be used in your protocol.",
    "output": "KDFのすべてのキーと出力を与えるだろう使用するランダムキーの偶発性のために必要なお客様プロトコル。"
  },
  {
    "index": "F1435",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And a typical KDF to use is HKDF, which is actually getting quite a bit of traction out there.",
    "output": "ありを使用する典型的なKDFHKDFは、実際になっている、非常にそこのトラクションのビットです。"
  },
  {
    "index": "F1436",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay.",
    "output": "わかりました。"
  },
  {
    "index": "F1437",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The last topic I wanna talk about in this segment is, how do you extract keys from passwords.",
    "output": "このセグメントで話したい最後のトピックパスワードからキーを抽出する方法。"
  },
  {
    "index": "F1438",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The problem here is that passwords have relatively low entropy.",
    "output": "ここでの問題はパスワード比較的低があります。"
  },
  {
    "index": "F1439",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In fact, we're gonna talk about passwords later on in the course when we talk about user authentication.",
    "output": "実際には、私たちの後、コースのパスワードについて話をするつもりだとはユーザー認証についての話します。"
  },
  {
    "index": "F1440",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so, I'm not gonna say too much here.",
    "output": "あまりここで言うつもりはないので。"
  },
  {
    "index": "F1441",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "I'll just say passwords generally have very little entropy estimated on the order of twenty bits of entropy, say.",
    "output": "私はちょうどよパスワードは、一般的に20程度推定非常に少しのエントロピーが言うエントロピーのビットを言います。"
  },
  {
    "index": "F1442",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And as a result, there is simply not enough entropy to generate session keys out of a password.",
    "output": "その結果、ない単に十分なエントロピーパスワードからセッションキーを生成します。"
  },
  {
    "index": "F1443",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And yet we still need to do it very frequently.",
    "output": "まだ我々はまだ非常にする必要があります。"
  },
  {
    "index": "F1444",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We still need to derive encryption keys and MACs and so on out of passwords, so the question is how to do it.",
    "output": "頻繁に。我々はまだ暗号化キーとMacのうち派生する必要では、どのようにパスワード。"
  },
  {
    "index": "F1445",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The first thing is, you know, for this kind of purpose, don't use HKDF.",
    "output": "最初は、知っている、このためです。種類の目的は、HKDFを使用しないでください。"
  },
  {
    "index": "F1446",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's not what it's designed for.",
    "output": "起こる右のキーは実際に何かと呼ばれる脆弱性が存在することです。"
  },
  {
    "index": "F1447",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "What will happen is that the derived keys will actually be vulnerable to something called a dictionary attack, which we're gonna talk about much later in the course when we talk about user authentication.",
    "output": "私たちずっと後に、コースについて話をするつもりは、辞書攻撃はときに、我々はユーザーの認証について話します。"
  },
  {
    "index": "F1448",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, the way PBKDFs defend against this low entropy problem that results in a dictionary attack is by two means.",
    "output": "だから、この低エントロピーに対する方法pbkdsを守る辞書攻撃とは結果が問題によって2つの手段です。"
  },
  {
    "index": "F1449",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "First of all, as before they use a salt, a public, random value that's fixed forever.",
    "output": "まず、としてを使用する前に、国民は、ランダムな値の固定永遠に。"
  },
  {
    "index": "F1450",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But in addition, they also use what's called a slow hash function.",
    "output": "しかしでさらに、彼らは使用しても何の遅いハッシュ関数と呼ばれます。"
  },
  {
    "index": "F1451",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And let me describe kind of the standard approach to deriving keys from passwords.",
    "output": "説明させてください。パスワードからキーを派生する、標準的なアプローチのような。"
  },
  {
    "index": "F1452",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This is called PKCS#5, and in particular, the version I'll describe is what's called PBKDF1.",
    "output": "これはPKCS5と呼ばれる、何PBKDF1と呼ばれるが、特に、このスクライブのバージョンです。"
  },
  {
    "index": "F1453",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And I should say that this mechanism is implemented in most crypto libraries so you shouldn't have to implement this yourself.",
    "output": "私はこのメカニズムはので、最もcryptalライブラリに実装されていることを言う必要があります。あなた自身で実装する必要はありません。"
  },
  {
    "index": "F1454",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "All you would do, you know, you would call a function, you know, derived key from password.",
    "output": "すべての場合、あなたが知っているだろう、関数を呼び出すと、あなたは、パスワードから派生キーを知っています。"
  },
  {
    "index": "F1455",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You would give the password in as input, and you would get a key as output.",
    "output": "あなたを与えるだろう、パスワードを入力とあなたとしてのキー出力としてなるでしょう。"
  },
  {
    "index": "F1456",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But you should be aware of course that this key is not going to have high entropy so in fact it will be guessable.",
    "output": "しかし、あなたが知っておくべきこのキーは、実際にはなりますので高エントロピーがあるつもりはないコースデシベル。"
  },
  {
    "index": "F1457",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "What these PBKDFs try to do is make the guessing problem as hard as possible.",
    "output": "これらの鉛KDFsがやろうとして推測の問題としては難しいです。"
  },
  {
    "index": "F1458",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay.",
    "output": "わかりました。"
  },
  {
    "index": "F1459",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the way they work, first of all, is, as we said, they basically hash, the concatenation of the password and the salt.",
    "output": "私たちが言ったように、彼らが働く、まず第一に、方法、ので彼ら基本的にはハッシュは、パスワードとsaltの連結。"
  },
  {
    "index": "F1460",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then the hash itself is designed to be a very slow hash function.",
    "output": "して、ハッシュ自体は非常に遅いハッシュ関数をように設計されています。"
  },
  {
    "index": "F1461",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And the way we build a slow hash function is by taking one particular hash function, say, SHA-256, and we iterate it many, many times, C times.",
    "output": "低速ハッシュを構築する方法関数は1つの特定のハッシュ関数と言う56と私たちによってです。それ多くは、多くの場合、反復処理C回。"
  },
  {
    "index": "F1462",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So you can imagine 1000 times, perhaps even a million times.",
    "output": "1000回を想像することができます、おそらくでも、100万回。"
  },
  {
    "index": "F1463",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And what do I mean by iterating it?",
    "output": "そしてそれを反復することで何を意味するか。"
  },
  {
    "index": "F1464",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, well, we take the password and the salt.",
    "output": "だから、まあ、私たちを取る、パスワードは、塩。"
  },
  {
    "index": "F1465",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And we put them inside of one input to the hash function.",
    "output": "1つの入力、ハッシュ関数の内部入れます。"
  },
  {
    "index": "F1466",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then we apply the hash function, oops, let me write it like this.",
    "output": "我々はハッシュ関数適用おっと、それがこのような書き込みさせてください。"
  },
  {
    "index": "F1467",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then we apply the hash function and we get an output, and then we apply the hash function again and we get another output.",
    "output": "そして私たちハッシュ関数を適用し、出力を取得し、我々ハッシュを適用関数をもう一度、私たちは、別の出力を取得します。"
  },
  {
    "index": "F1468",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And we do this again and again and again maybe a thousand times or a million times depending on how fast your processors are and then finally we get the final output that we actually output as, as the key output of this key derivation function.",
    "output": "我々は再び、もう一度、もう一度これを行うたぶん千回は100万回によってどのように高速あなたのプロセッサか最後に私たちは実際には、キーとして出力として、最終的な出力を取得します。このキー導出関数の出力。"
  },
  {
    "index": "F1469",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now what is the point here?",
    "output": "今ここでのポイントは何でしょうか。"
  },
  {
    "index": "F1470",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Iterating a function 10,000 times or even a million times is going to take very little time on a modern CPU, and as a result, it doesn't really affect the user's experience.",
    "output": "関数10,000回または100万倍も非常に少し時間を取るつもりです。現代のCPUと結果として、それは本当に、ユーザーの経験に影響しません。"
  },
  {
    "index": "F1471",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The user types in his password, it gets hashed a million times and then it gets output.",
    "output": "は彼のパスワードでは、ユーザーの種類は100万回ハッシュを取得し、出力を取得します。"
  },
  {
    "index": "F1472",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And maybe that could even take, you know a tenth of a second and the user wouldn't even notice it.",
    "output": "たぶんそれも取ることができる2番目の10分の1を知っているし、ユーザーwouldn'tそれに気づきます。"
  },
  {
    "index": "F1473",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "However the attacker, all he can do is he can try all the passwords in the dictionary, because we know people tend to pick passwords in dictionaries, and so he could just try them one by one, remember the SALT is public, so he knows what the SALT is.",
    "output": "しかし、攻撃者が、彼は彼のすべてのパスワードを試すことができます。我々は知っているので、辞書では、人々パスワード辞書で選ぶ傾向がある、彼が1つずつにしようと、思い出して塩を彼は知っているので公開ですどのような塩です。"
  },
  {
    "index": "F1474",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so he can just try this hash one by one.",
    "output": "彼はちょうど一つずつこのハッシュを試すことができます。"
  },
  {
    "index": "F1475",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "However because the hash function is slow, each attempt is gonna take him a tenth of second.",
    "output": "しかしのでハッシュ関数は遅い、各試行が彼が2番目の10分の1を取るつもりです。"
  },
  {
    "index": "F1476",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So if he needs to run through a dictionary, you know, with, with a 200 billion passwords in it, because the hash function is slow, this is gonna take quite awhile.",
    "output": "だから彼は必要がある場合辞書を介して、ご存知のように、実行すると、2000億のパスワードには、ハッシュ関数は低速であるため、これはかなり時間がかかるつもりです。"
  },
  {
    "index": "F1477",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And by doing that, we slow down the dictionary attack, and we make it harder for the attacker to get our session keys.",
    "output": "することによって我々は辞書攻撃ダウンが遅いし、我々が、攻撃者には難しく、私たちのセッションキーを取得します。"
  },
  {
    "index": "F1478",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Not impossible, just harder.",
    "output": "不可能ではない、ただ困難。"
  },
  {
    "index": "F1479",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's all this is trying to do.",
    "output": "すべてこれはしようとしているです。"
  },
  {
    "index": "F1480",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay, so this is basically what I wanted to say about password based KDFs.",
    "output": "さて、基本的に何を言ってみたいので、このパスワードはKDFsに基づきます。"
  },
  {
    "index": "F1481",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "As I said, this is not something you would build yourself.",
    "output": "私としてこれを自分で構築するない何か。"
  },
  {
    "index": "F1482",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And you would just call the appropriate function to convert a password into a key, and then use the resulting key.",
    "output": "あなただけを呼び出すと、パスワードをキーに変換し、結果を使用して適切な関数キー。"
  },
  {
    "index": "F1483",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay, in the next segment, we're gonna see how to use symmetric encryption in a way that allows us to search on the cipher texts.",
    "output": "さて、次のセグメントでは、対称暗号化を使用する方法を参照してください俺たち方法では、私たちの暗号テキストを検索することができます。"
  },
  {
    "index": "F1484",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This is our online course Algorithms developed by myself and Kevin Wayne here at Princeton. We're gonna start with an overview discussion of why you might want to study algorithms and a little bit of discussion about the resources that you need to take this course.",
    "output": "はじめましてプリンストン大コンピュータ・サイエンス教授のボブ・セジウイックですこの「アルゴリズム」のオンラインコースはプリンストン大のケヴィン・ウェインと共に開発しましたまずなぜアルゴリズムを学習するのかを簡単に説明しこのコースに必要なリソースをお話ししますこのコースは「アルゴリズムとは何か?"
  },
  {
    "index": "F1485",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We're going to concentrate on programming and problem solving in the context of real applications, and our focus is going to be on two things, Algorithms which are methods for solving problems and data structures which store the information associated in problem, with a problem and go hand in hand with algorithms.",
    "output": "」を学ぶ中級レベルのコースです実際の場面で使えるプログラミングや問題解決の手順を中心に特に次の2点に重点を置いて学びます問題を解決する手順である「アルゴリズム」と問題に関するデータを格納する「データ構造」でこれはアルゴリズムと切り離すことはできませんこの2つの基本的なトピックを2つのパートに分けて説明しますパート1ではデータタイプやソート(並べ替え)やサーチ(検索)を学びますここで紹介する様々なデータ構造とアルゴリズムはスタック、キュー、バッグ、プラオリティキューなどの理解に不可欠です次に定番の並べ替えに使われるソート・アルゴリズム--クイックソート、マージソート、ヒープソート、基数ソートを勉強しますまた、定番のサーチアルゴリズム--二分探索木や赤黒木やハッシュテーブルを紹介しますパート2ではさらに高度なアルゴリズム--グラフやグラフ探索のアルゴリズムや最小全域木と最短経路アルゴリズムを検討します。"
  },
  {
    "index": "F1486",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We'll consider a number of data structures and algorithms that are basic to all the methods we consider including stacks, queues, bags and priority queues. Then we'll consider classic algorithms for sorting, putting things in order.",
    "output": "文字列を処理するアルゴリズムについても検討し、正規表現やデータ圧縮などを扱います。"
  },
  {
    "index": "F1487",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then some advanced algorithms that make use of the basic algorithms that we developed earlier in the course.",
    "output": "さらに、いくつかの複雑なアルゴリズムについても取り扱い、コースの前半で開発した基本的なアルゴリズムを利用するものになっています。"
  },
  {
    "index": "F1488",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, why should one study algorithms?",
    "output": "さて、なぜアルゴリズムを学ぶ必要があるのでしょうか?"
  },
  {
    "index": "F1489",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Well, their input, impact is very broad and far-reaching.",
    "output": "その影響はとても広くさまざま分野に及んでいます。"
  },
  {
    "index": "F1490",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "From the internet to biology to, commercial computing, computer graphics, security, multimedia, social networks, and scientific applications, algorithms are all around us.",
    "output": "インターネットから生物学、商用コンピューティング、コンピュータグラフィック、セキュリティ、マルチメディア、ソーシャルネットワーク、科学利用まで、アルゴリズムは身の回りのいたるところにあるのです。"
  },
  {
    "index": "F1491",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "They're used for movies and video games, for particle collision simulation, they're used to study the genome, and all manner of other applications.",
    "output": "映画やビデオゲーム、粒子衝突シミュレーションに利用され、ゲノムの研究にも利用され、他のあらゆる分野に適用されています。"
  },
  {
    "index": "F1492",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that's one important reason to study algorithms, their impact is broad and far-reaching.",
    "output": "アルゴリズムを学ぶひとつの重要な理由は、このように影響が非常に広い分野に及んでいるためです。"
  },
  {
    "index": "F1493",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Algorithms are also interesting to study, because they, they have ancient roots.",
    "output": "アルゴリズムの研究自身もとても面白いもので、古くからの起源を持っています。"
  },
  {
    "index": "F1494",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now the first algorithm we studied goes back to 300 B.C., dating at least to Euclid.",
    "output": "最初のアルゴリズムは紀元前300年にさかのぼり、ユークリッドの時代です。"
  },
  {
    "index": "F1495",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The concept of an algorithm was formalized actually here at Princeton, by Church and Turing, in the 1930s.",
    "output": "アルゴリズムの概念が厳密に定式化されたのは、ここ、プリンストンで、チャーチとチューリングによって、1930年代に行われました。"
  },
  {
    "index": "F1496",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But most algorithms that we consider, were discovered in recent decades.",
    "output": "しかし、私たちが検討するアルゴリズムの大部分は、比較的最近発見されたものです。"
  },
  {
    "index": "F1497",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In fact, some were discovered by undergraduates in a course, course like this.",
    "output": "実際、そのうちのいくつかは、このコースや類似のコースの学生によって発見されたものです。"
  },
  {
    "index": "F1498",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And there's plenty of other algorithms waiting to be discovered by students like you.",
    "output": "まだ多くのアルゴリズムがあなた方学生によって発見されるのを待っているのです。"
  },
  {
    "index": "F1499",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The main reason that people study algorithms, is to be able to solve problems that it could not otherwise be addressed.",
    "output": "アルゴリズムを学ぶ一番の理由は、他の方法では対応することができない問題の解決を可能にすることです。"
  },
  {
    "index": "F1500",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "For example, in the first lecture, we're going to talk about the network connectivity problem, where the problem is, given a large set of items that are connected together pairwise is there a way to get from one to another with a path through the connections.",
    "output": "最初の講義でその一例としてお話しするのは、ネットワークコネクティビティの問題です。この問題は、ペアとしてつながっている要素の集合に対して、その接続をたどって、ある要素から他の要素へと通じる経路があるかどうかを確かめるものです。"
  },
  {
    "index": "F1501",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "As you can see from this example, it's not clear whether or not there's such a path, we need a computer program to do it, in fact, we need an efficient algorithm to do it.",
    "output": "この例からわかるように、そのような経路が存在するかどうかは明らかではありません。このような場合、コンピュータプログラムが必要になり、実際、そのための効率的なアルゴリズム必要になります。"
  },
  {
    "index": "F1502",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In this case the answer is that there is such a path.",
    "output": "この場合は、答えはそのような経路が存在することになります。"
  },
  {
    "index": "F1503",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Another reason to study algorithms is for intellectual stimulation.",
    "output": "アルゴリズムを学ぶもうひとつの理由は思考実験となるためです。"
  },
  {
    "index": "F1504",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Algorithms are very interesting objects to study.",
    "output": "アルゴリズムはとても面白い研究対象です。"
  },
  {
    "index": "F1505",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Don Knuth who wrote several books on, on algorithms and was a pioneer in the field said that, \"An algorithm must be seen to be believed.\" You can't just think about an algorithm you have to work with it.",
    "output": "」アルゴリズムをただ利用するだけのものと考えてはいけません。また、フランシス・サリバンはこのようにも言っています。"
  },
  {
    "index": "F1506",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Another quote from Francis Sullivan, says, \"The great algorithms are the poetry of computation.\" Just like verse, they can be terse, elusive, dense, and even mysterious.",
    "output": "「偉大なアルゴリズムは計算の詩である。」韻文詩のように簡潔で、難解で、濃密で、神秘的でさえあります。"
  },
  {
    "index": "F1507",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But once unlocked, they cast a brilliant new light on some aspect of computing.",
    "output": "しかし、一度その鍵を開けることができれば、計算のいくつかの面に眩い新しい光を当てることになるのです。"
  },
  {
    "index": "F1508",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Another reason many people study algorithms and I suspect many of you, is it's necessary to understand good algorithms, efficient algorithms, a good data structures in order to be a proficient programmer.",
    "output": "多くの人々がアルゴリズムを研究するもうひとつの理由、そして、皆さんの多くの人もそうだと思いますが、それは、良いアルゴリズム、効率的なアルゴリズム、良いデータ構造を理解し、優秀なプログラマになるためです。"
  },
  {
    "index": "F1509",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Linus Torvalds, who created lin, Linux, says that the difference between a bad programmer and a good one is whether he considers his code or his data structures more important.",
    "output": "リナス・トーバルズは、Linuxを開発したのですが、こう言っています。悪いプログラマと良いプログラマの違いは、コードやデータ構造のどちらに重きを置いているかだと。"
  },
  {
    "index": "F1510",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Bad programmers worry about the code, good programmers worry about data structures, and their relationships.",
    "output": "駄目なプログラマはコードばかりを気にしていて、優秀なプログラマはデータ構造と、データ構造とコードの関係を大事にしている。"
  },
  {
    "index": "F1511",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And, I might add, the algorithms that process them.",
    "output": "さらに私はそれらを扱うアルゴリズムを付け加えたいと思う。"
  },
  {
    "index": "F1512",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Niklaus Wirth, another pioneer in computer science, wrote a famous book called Algorithms + Data Structures = Programs.",
    "output": "もう一人のコンピュータサイエンス分野のパイオニアの、二クラウス・ワースは、アルゴリズム+データ構造=プログラムと呼ばれている有名な本を書いている。"
  },
  {
    "index": "F1513",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Another reason nowadays to study algorithms is that, they have become a common language for understanding, nature.",
    "output": "今日、アルゴリズムを研究する別な理由は、アルゴリズムが自然を理解するための共通言語であるためです。"
  },
  {
    "index": "F1514",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Algorithms are computational models, and algorithmic models are replacing mathematical models in scientific inquiry.",
    "output": "アルゴリズムは計算モデルであり、科学的な疑問に対して、アルゴリズム的なモデルが数理モデルに置き換わってきているのです。"
  },
  {
    "index": "F1515",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In the twentieth century, math, scientists developed mathematical models to try to understand natural phenomenon.",
    "output": "20世紀は、数理科学者が数理モデルを開発し、自然現象を理解しようとしていました。"
  },
  {
    "index": "F1516",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It soon became clear that those mathematical models were difficult to solve.",
    "output": "しかし、まもなく、このような数理モデルでは、それを解決することが困難であるということが明らかになってきました。"
  },
  {
    "index": "F1517",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It was difficult to create solutions, to be able to test hypotheses against natural phenomenon.",
    "output": "解答を出すのが困難なのは、自然現象に対する仮定を検証する必要があるためです。"
  },
  {
    "index": "F1518",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, more and more and more now a days people are developing computational models, where they attempt to simulate what might be happening in nature in order to try to better understand it.",
    "output": "そのため、今日では数多くの人々がコンピュテーショナルモデルを作り、それを使って自然界で何が起きているのかシミュレーションし、より深い理解をしようとしているのです。"
  },
  {
    "index": "F1519",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Algorithms play an extremely important role in this process.",
    "output": "アルゴリズムはこのプロセスの中で極めて重要な役割を果たしているのです。"
  },
  {
    "index": "F1520",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And we'll see some examples of this in this course.",
    "output": "私たちもこのコースの中でいくつかの例を見ていくことにしましょう。"
  },
  {
    "index": "F1521",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Another important reason is that if you know effect, how to effectively use algorithms and data structures you're going to have a much better chance at interviewing for a job in the technology industry then if you don't.",
    "output": "もう一つの大切な理由は、効果、つまり、アルゴリズムとデータ構造の効率的な使い方を知っていれば、テクノロジー業界では就職面接でよりよいチャンスを得ることができることです。"
  },
  {
    "index": "F1522",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, here's a bunch of reasons that I just went through for studying algorithms.",
    "output": "このようにアルゴリズムを学ぶのには沢山の理由があるのです。"
  },
  {
    "index": "F1523",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Their impact's broad and far-reaching, they have old roots and present new opportunities, they allow us to solve problems that could not otherwise be addressed, you can use them for intellectual stimulation to become a proficient programmer.",
    "output": "アルゴリズムの影響は広く、至る所にいきわたっており、古い起源を持ち、最近の新しい機会も提供してくれます。他の方法では対処することができない問題を解決することができ、思考実験を通じて優秀なプログラマになることができるのです。"
  },
  {
    "index": "F1524",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "They might unlock the secrets of life in the universe, and they're good for fun and profit.",
    "output": "世界中の生命の秘密の鍵を解き、楽しみや得になるものなのです。"
  },
  {
    "index": "F1525",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In fact, a pr ogrammer might ask, why study anything else?",
    "output": "実際、プログラマは尋ねることでしょう。なぜ他のことを学ぶのかと。"
  },
  {
    "index": "F1526",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Well, there's plenty of good reasons to study other things, but I'll submit there's no good reason not to study algorithims.",
    "output": "そう、他のことを学ぶのにもそれぞれ多くの理由がありますが、アルゴリズムを勉強しない理由はないと、自身を持って言うことができます。"
  },
  {
    "index": "F1527",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, for this course we have two resources that I want to talk about and make sure that people are familiar with before entering into the content.",
    "output": "このコースのために、私たちは2つの材料を用意したので、その話をしましょう。コンテンツに入る前に、よく理解しておくようにしてください。"
  },
  {
    "index": "F1528",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This is a publishing model that Kevin Wayne and I developed and have been using for many years, and we think it's a very effective way to support the, kinds of lectures that we're going to be giving in this course.",
    "output": "これは、出版モデルでケヴィン・ウェインと私が開発し、長年使ってきたものです。このコースで提供する予定の講義のようなものを支援するとても効率的な方法だと思っています。"
  },
  {
    "index": "F1529",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Down at the bottom, and it's optional for this course, we have a text book.",
    "output": "最後には、このコースでは必ずしも必要ではありませんが、テキストブックもあります。"
  },
  {
    "index": "F1530",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's a traditional, text book that extensively covers the topics in the course, in fact many more topics than we can present in lecture.",
    "output": "伝統的なテキストブックでコースのトピックを広くカバーしています。"
  },
  {
    "index": "F1531",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then supporting that textbook, is free online material that we call the book site.",
    "output": "さらに、テキストをサポートする無料のオンライン教材もあり、ブックサイトと呼んでいます。"
  },
  {
    "index": "F1532",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You can go to books, the book site to see the lecture slides.",
    "output": "テキストやブックサイトで講義のスライドを見ることができます。"
  },
  {
    "index": "F1533",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But more important, there's code, there's exercises, tere's a great deal of information there.",
    "output": "しかし、より重要なのは、コードや練習問題、多くの情報がそこにはあるのです。"
  },
  {
    "index": "F1534",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In fact, maybe ten times what's in the book, including a summary of the content.",
    "output": "事実、本にあるものの、約10倍にもなり、コンテンツの要約も含んでいます。"
  },
  {
    "index": "F1535",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, during this course you'll be referring to the book site frequently while working online.",
    "output": "したがって、このコースの受講中は、頻繁にブックサイトを参照し、オンラインでの作業をすることになります。"
  },
  {
    "index": "F1536",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We're assuming that people who take this course know how to program, and know the basics of loops, arrays, functions.",
    "output": "受講条件についての質問も良く受けます。このコースではプログラミングができることを前提としており、基本的なループ処理や配列、関数について知っていることが必要です。"
  },
  {
    "index": "F1537",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "They have some exposure to object oriented programming and recursion.",
    "output": "オブジェクト指向プログラミングや再帰についての知識が必要となるときもあります。"
  },
  {
    "index": "F1538",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We use the Java language, but we don't dwell on details of Java, we mostly use it as an expository language.",
    "output": "Javaを使いますが、Javaについて詳しく触れることはしません。例示のためのプログラミング言語として使用するだけです。"
  },
  {
    "index": "F1539",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We do some math, but not advanced math.",
    "output": "数学も使いますが、発展的なものではありません。"
  },
  {
    "index": "F1540",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If you want to review the material that we think is prerequisite for the material in this course, you can do a quick review by looking at sections 1.1 and 1.2 of the book.",
    "output": "このコースの前提としている事項を復習しておきたい場合は、本のセクション1.1と1.2を見ておくと良いでしょう。"
  },
  {
    "index": "F1541",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Either at the book site or in the text book.",
    "output": "ブックサイトでも、テキストブックでもどちらでもよいです。"
  },
  {
    "index": "F1542",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If you want an in depth review, we have a full text book called, An Introduction to Programming in Java: An Interdisciplinary Approach.",
    "output": "詳しく復習しておきたい場合には、完全なテキストも用意しています。“IntroductiontoProgramminginJava:AnInterdisciplinaryApproach\"です。"
  },
  {
    "index": "F1543",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "There is a book site and text book as well.",
    "output": "同様に、ブックサイトとテキストブックがあります。"
  },
  {
    "index": "F1544",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But, the bottom line is, you should be able t o program, and the quick exercise to get ready is, to write a java program on your computer perhaps using a programming model, as described on the book site.",
    "output": "しかし、ボトムラインは、プログラムが書けることであり、準備ができているかどうか確認するには、自分のコンピュータでプログラムを書いてみることで、ブックサイトに載っているプログラミングモデルを使ってみるといいでしょう。"
  },
  {
    "index": "F1545",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We will provide much more detail information on that as we get into the assignments.",
    "output": "さらに詳しい情報を提供する予定です。それで宿題にも対応できるようになるでしょう。"
  },
  {
    "index": "F1546",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You can use your own programming environment if your comfortable with one or you download ours.",
    "output": "そのほうがよければそれでよいですし、私たちのものをダウンロードして使うこともできます。"
  },
  {
    "index": "F1547",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We have instructions on the web on how to do that.",
    "output": "ウェブサイトに利用方法を載せてあります。"
  },
  {
    "index": "F1548",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Welcome back to algorithms. Today, we're going to talk about the union find problem.",
    "output": "今日お話するのは、はunionfind問題いわゆる動的接続問題を解くアルゴリズムのことです。"
  },
  {
    "index": "F1549",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "A set of algorithms for solving the so-called dynamic connectivity problem. We'll look at two classic algorithms.",
    "output": "まず、二つの古典的なアルゴリズムから始めます。"
  },
  {
    "index": "F1550",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Quick Find and Quick Union, and some applications and improvements of those algorithms.",
    "output": "QuickFIndとQuickUnionです。適用例を紹介し、これらのアルゴリズムの改良を考えてみます。"
  },
  {
    "index": "F1551",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The subtext of today's lecture really is to go through the steps that we'll follow over and over again to develop a useful algorithm.",
    "output": "本日の講義のサブテキストは使えるアルゴリズムを開発するためにこれから紹介する手順を繰り返し実施するということです。"
  },
  {
    "index": "F1552",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The first step is to model the problem.",
    "output": "最初のステップは問題のモデル化です。"
  },
  {
    "index": "F1553",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Try to understand, basically, what are the main elements of the problem that need to be solved.",
    "output": "基本的には解決すべき問題の主な要素がなんであるかを理解する必要があります。"
  },
  {
    "index": "F1554",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Then we'll find some algorithm to solve the problem.",
    "output": "すると問題を解決するアルゴリズムをいくつか発見するようになります。"
  },
  {
    "index": "F1555",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In many cases, the first algorithm we come up with would be fast enough and maybe it fits in memory and, we'll go ahead and use it, and be off and running.",
    "output": "多くの場合、多くの場合は最初に見つけたアルゴリズムが十分に高速で、メモリにも収まるものと思います。その場合は、どんどん先に進み、それを使っていけばよいでしょう。"
  },
  {
    "index": "F1556",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But in many other cases maybe it's not fast enough, or there's not enough memory.",
    "output": "しかし、他の多くの場合は、十分な速度を得られなかったり、メモリが不足したりします。"
  },
  {
    "index": "F1557",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, what we do is try to figure out why, find a way to address whatever's causing that problem, find a new algorithm and iterate until we're satisfied.",
    "output": "そのようなときに、私たちがやるべきことは、原因を突き止め、問題の原因となっているものへの対処を検討し、新しいアルゴリズムを見つけ、満足できるまでこれを繰り返すのです。"
  },
  {
    "index": "F1558",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This is the scientific approach to designing and analyzing algorithms, where we build mathematical models to try and understand what's going on, and then we do experiments to validate those models and help us improve things.",
    "output": "これはアルゴリズムを設計、分析するときの科学的なアプローチです。そこでは、数理モデルを構築し、何が起きているのか理解し、モデルの確からしさを検証し、物事を改善する役に立つのです。"
  },
  {
    "index": "F1559",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, first we'll talk about the dynamic connectivity problem, the model of the problem for union find.",
    "output": "まず最初に動的接続問題について、次にunion-findの問題のモデルついての話をします。"
  },
  {
    "index": "F1560",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, here's the idea.",
    "output": "さて、次のように考えてみましょう。"
  },
  {
    "index": "F1561",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Doesn't really matter what they are.",
    "output": "それらが何かは問題ではありません。"
  },
  {
    "index": "F1562",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We're going to use the numbers, zero through N to model our objects.",
    "output": "数字のゼロからnを使って、それらをモデル化します。"
  },
  {
    "index": "F1563",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then, we have the idea of a connection between two objects.",
    "output": "次に2つの間の接続について考えてみます。"
  },
  {
    "index": "F1564",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And, we'll, postulate that there's going to be a command that says, connect two objects.",
    "output": "何かの命令が存在すると考えて、2つをつなぐことにするのです。"
  },
  {
    "index": "F1565",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Given two objects, provide a connection between them.",
    "output": "2つのものがあり、それらの間に接続を考えるのです。"
  },
  {
    "index": "F1566",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then key part of the problem is find query or the connected query, which just asks, is there a path connecting the two objects.",
    "output": "そして、問題の重要な部分はクエリー、あるいは、一連のクエリーを見つけることで、そのクエリを使って、2つのものの間の経路があるかどうかを答えることができるのです。"
  },
  {
    "index": "F1567",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So for example, in this set of ten objects, we performed already, a bunch of union commands, connecting four and three, three and eight, six and five, nine and four, two and one.",
    "output": "例えば、この集合は10個の要素があり、既に多くのunion命令を実行して、4と3を、3と8を、6と5を、9と4を、2と1を接続しています。"
  },
  {
    "index": "F1568",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And now we might have a connected query that says, is zero connect ed to seven?",
    "output": "ここで、クエリを発行し、0と7が接続されているかを問い合わせてみます。"
  },
  {
    "index": "F1569",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Well, in this case, there is no connection, so we say no.",
    "output": "この場合は接続はありませんので、Noを答えることになります。"
  },
  {
    "index": "F1570",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But if we ask is eight connected to nine? We are going to say yes, even no we don't have a direct connection between eight and nine.",
    "output": "しかし、8と9の接続を問い合わせられたら、Yesを答えることになります。"
  },
  {
    "index": "F1571",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "There is a path from eight to three to four to nine.",
    "output": "8と9の間には直接の接続はありませんが、8から3へ、そして4へ、次に9へという経路が存在しているのです。"
  },
  {
    "index": "F1572",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that's our problem, to be able to officially support these two commands for given set of objects.",
    "output": "これが今回の問題で、与えられた集合に対してこれら二つの命令に公式に対応することなのです。"
  },
  {
    "index": "F1573",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, let's say we add a union five, zero.",
    "output": "ここで、5と0のunionを追加します。"
  },
  {
    "index": "F1574",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that creates a connection between five and zero.",
    "output": "5と0の間の接続をつくります。"
  },
  {
    "index": "F1575",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Seven and two creates a connection between seven and two.",
    "output": "7と2の間の接続を構築し、6と1の間の接続を構築します。"
  },
  {
    "index": "F1576",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, now if we ask our zero connected to seven, well one and zero we can do that too.",
    "output": "ここで、0と7は接続されているでしょうか?そうですね1と0もつなげることができます。"
  },
  {
    "index": "F1577",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And that's a redundant connection.",
    "output": "これは冗長な接続ですね。"
  },
  {
    "index": "F1578",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And now, if we ask is zero connected to seven we're going to answer yes.",
    "output": "ここで0が7と接続されているかどうか質問されたら、答えはYesとなりますね。"
  },
  {
    "index": "F1579",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So that's our problem, intermix union, commands and connected queries and we need to be able to officially support those commands for a large number of objects.",
    "output": "そう、これが今回の問題で、union命令と接続のクエリを組み合わせで、多数のものに対して、これらの命令を明確にサポートすること必要があるのです。"
  },
  {
    "index": "F1580",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, here's a much bigger example.",
    "output": "ここにより大きな例があります。"
  },
  {
    "index": "F1581",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And you can see that we're going to need efficient algorithms for this.",
    "output": "これに対しては効率的なアルゴリズムが必要となるのはわかりますね。"
  },
  {
    "index": "F1582",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "First of all, you can see we're going to need a computer for this.",
    "output": "まず最初に、コンピュータが必要ですね。"
  },
  {
    "index": "F1583",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It would take quite, quite some time for a human to figure out whether there's a connection.",
    "output": "接続があるかどうかを人間が確かめるには、相当の時間かかります。"
  },
  {
    "index": "F1584",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In this case there is a connection.",
    "output": "この場合は接続が存在します。"
  },
  {
    "index": "F1585",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, the algorithms that we're looking at today are not going to actually give the path connecting the two objects.",
    "output": "さて、アルゴリズムは、私たちが今日見るものですが、それは、2つのものを接続する経路を実際に与えるものではありません。"
  },
  {
    "index": "F1586",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's just going to be able to answer the question, is there a path?",
    "output": "ただ、問い合わせに答えるだけです。経路があるかどうかいうね。"
  },
  {
    "index": "F1587",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In part two of the course, we'll consider algorithms that explicitly find paths.",
    "output": "コースの第2部では、経路を明示的に発見するアルゴリズムを検討する予定です。"
  },
  {
    "index": "F1588",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "They're not as efficient as union find because they have more work to do.",
    "output": "それらはunionfindほどは効率的なものではありません。なぜなら、やらないといけないことが多いですから。"
  },
  {
    "index": "F1589",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, applications of these, these algorithms involve objects of all types.",
    "output": "このアルゴリズムはいろんな種類のものに対して適用することができます。"
  },
  {
    "index": "F1590",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "These are used for digital photos, where the objects are pixels they're used for networks, where the objects are computers, social networks, where it's people, or computer chips, where it's circuit elements or abstract things like variable names in a program, or elements in a mathematical set, or physical things like metallic sites in a composite system.",
    "output": "抽象的なものにも使われます、プログラムの変数名や数学の集合の要素などですね。複合材料の金属部位のような物理的なものにも使われます。"
  },
  {
    "index": "F1591",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, all different types of objects for, but for programming we're going to associate each object with a name and we'll just name the objects with a number, integers from zero to N-1.",
    "output": "そのため、どんな種類のものに対しても、プログラミングのためには、それぞれの対象に対する名前をつける必要があります。ここでは対象を数字、0からN-1までの整数で識別することにします。"
  },
  {
    "index": "F1592",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's a very convenient initial starting point for our programs because we can use integers as an index into an array then, and then quickly access information relevant to each object.",
    "output": "プログラミングの最初の出発点としてはとても便利です。整数を配列のインデックスとして使うことができますから、すると、各対象に関連する情報に簡単にアクセスすることができますね。"
  },
  {
    "index": "F1593",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And it also just supresses a lot of details that are not relevant to union find.",
    "output": "また、unionfindに関係ない詳細な事項を省略することができます。"
  },
  {
    "index": "F1594",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In fact, to make this mapping from an object name to the integer zero through N - one is to find application of a symbol table or a searching algorithm, which is one of the things that we'll be studying later in this course algorithms and data structures for solving that problem.",
    "output": "実際、対象の名前から0からN-1の整数に対するマッピングは、シンボルテーブルや探索アルゴリズムへの応用にみることができます。探索アルゴリズムはこのコースでも後ほど問題を解くためのアルゴリズムやデータ構造について学習する予定です。"
  },
  {
    "index": "F1595",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, the connections, well, we need, a few abstract properties that these connections have to satisfy.",
    "output": "さて、接続は満たすべき2,3の抽象的な性質があります。"
  },
  {
    "index": "F1596",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And they're all quite natural and intuitive.",
    "output": "みな、自然で直観的なものばかりです。"
  },
  {
    "index": "F1597",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So we assume that is connected to is an equivalence relation.",
    "output": "\"接続されている\"というのは同値関係と仮定します。"
  },
  {
    "index": "F1598",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That is, every object's connected to itself, it's symmetric.",
    "output": "つまり、すべての対象は自分自身と接続されています。対称であるとします。"
  },
  {
    "index": "F1599",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If P's connected to Q, then Q's connected to P, and it's transitive.",
    "output": "つまり、PがQと接続されているならば、QはPと接続されているということです。また、推移的です。"
  },
  {
    "index": "F1600",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If P's connected to Q, and Q's connected to R, then P's connected to R.",
    "output": "PとQが接続され、QとRが接続されているなら、PとRは接続されているということです。"
  },
  {
    "index": "F1601",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now these properties are very intuitive.",
    "output": "これらの性質はとても直観的ですね。"
  },
  {
    "index": "F1602",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But it's worthwhile to state them explicitly and make sure that our algorithms maintain them.",
    "output": "しかし、それらを明示して、われわれのアルゴリズムがそれを満たしていることを保証するのは重要なことです。"
  },
  {
    "index": "F1603",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "When we have an equivalence relation a set of objects and connections divide into subsets called connected components.",
    "output": "同値関係があれば、対象と接続の集合が接続コンポーネントという部分集合に分割することができます。"
  },
  {
    "index": "F1604",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "For example in this small example here, there's three connected components.",
    "output": "たとえば、ここに簡単な例を挙げましょう。3つの接続コンポーネントがありますね。"
  },
  {
    "index": "F1605",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "One consisting of just object zero, second one objects one, four and five.",
    "output": "1つ目は、対象0しかありません。2つ目は1と4と5があります。"
  },
  {
    "index": "F1606",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And third one the other four objects.",
    "output": "3つ目には、残りの4つの対象があります。"
  },
  {
    "index": "F1607",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And these components have the property that if any two objects in them are connected and there is no object outside that is connected to those objects, that's connected components.",
    "output": "これらのコンポーネントはそこに含まれるどの2つの対象も接続されていて、外側にはこれらの対象に接続されている対象がないとき、接続されたコンポーネントであるといいます。"
  },
  {
    "index": "F1608",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Our algorithms will gain efficiency by maintaining connected components and using that knowledge to efficiently answer the query that's, that they're presented with.",
    "output": "今回のアルゴリズムは接続コンポーネントを維持して、効率性を確保する予定であり、その知識を利用して、提示されたクエリに効率的に答えを返すことができるのです。いいですね。"
  },
  {
    "index": "F1609",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay, so to implement the operations, we have to find query and the union command.",
    "output": "では、この操作を実装するためには、クエリコマンドとunionコマンドを見つける必要があります。"
  },
  {
    "index": "F1610",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so we're going to mai ntain the connected components.",
    "output": "また、接続コンポーネントを維持する必要があるのです。"
  },
  {
    "index": "F1611",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The find is going to have to check if two objects are in the same component and the union command is going to have to replace components containing two objects with their union.",
    "output": "findコマンドは2つのオブジェクトが同じコンポーネントに入っているかどうかをチェックする必要があり、unionコマンドは2つのオブジェクトを含むコンポートをその合併、union、で置換するのです。"
  },
  {
    "index": "F1612",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, for example, if we have these components, and we get the command to union connect, two and five.",
    "output": "例えば、このようなコンポーネントで、2と5を接続するunionコマンドが発行されたとしています。"
  },
  {
    "index": "F1613",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Essentially, we need to merge the connected components containing the one containing two or the one containing five to get a big connected components and now we have only two connected components.",
    "output": "このときには必ず、2を含む接続コンポーネントと5を含む接続コンポーネントを併合して、1つの接続コンポーネントにします。そうして、接続コンポーネントを2つだけにします。"
  },
  {
    "index": "F1614",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "All of that leads up to, in a programming world to specifying, a data type which is simply specification of the methods that we are want to going to implement in order to solve this problem.",
    "output": "これで、プログラミングで必要となる、データ型をきめて、問題を解くために実装する必要があるメソッドの仕様を考えることができるようになりました。"
  },
  {
    "index": "F1615",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So you know, typical Java model, what we will do is create a class called UF that contains two methods, one to implement union, the other one to implement connected, which returns a boolean.",
    "output": "典型的なJavaモデルでは、まず最初に、UFというクラスを作り、そこに2つのメソッド、1つはunionメソッドを実装し、もう一つは、bool値を返すconnectedメソッドを実装します。"
  },
  {
    "index": "F1616",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The constructor, takes SR unit, the number of objects, so that it can build data structure based on the number of objects.",
    "output": "コンストラクターは、SR単位をとり、対象の数を表すものですが、対象の数を応じたデータ構造を構築します。"
  },
  {
    "index": "F1617",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, and we have to, bear in mind, as we're building our logarithms, that both the number of objects can be huge, but also, the number of operations.",
    "output": "ここで、対数オーダーで構築するように気をつける必要があります。対象の数が多くなることもありますし、操作の数についても同様です。"
  },
  {
    "index": "F1618",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We can have a, a very large number, of union and connected, operations and our algorithms are going to have to be efficient, under those conditions.",
    "output": "unionやconnectedのオペレーションは非常に多くなることがありますので、このアルゴリズムは、このような状況でも効率的である必要があるのです。"
  },
  {
    "index": "F1619",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "One of the practices that will follow often in this course is to check our API design before getting too far into dealing with the problem, by building a client that is going to use the data type that we develop.",
    "output": "このコースでよく従うプラクティスの一つが、APIの設計をチェックすることです。問題に深く入りこむ前に、クライアントプラグラムを作って、開発しているデータ型を使ってみるのです。"
  },
  {
    "index": "F1620",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, for this example, we've got a client that, Will read information from standard input.",
    "output": "今回の例では、標準入力から情報を読み取るクライアントを作りました。"
  },
  {
    "index": "F1621",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "First, an integer which is the number of objects that are going to be processed.",
    "output": "最初に、整数、これは処理すべき対象の数を表します。"
  },
  {
    "index": "F1622",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then a series of pairs of object names.",
    "output": "次に、一連の対象の名前のペアを処理します。"
  },
  {
    "index": "F1623",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And what the client does is it, it'll, first it'll read the integer from standard input, and create a, a UF object.",
    "output": "クライアントプログラムがやることは、まず、整数を標準入力からリードして、UFオブジェクトを生成します。"
  },
  {
    "index": "F1624",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then as long as standard input is not empty, it's going to read two integers from the input. And if they're not connected, then it'll connect them and print them out.",
    "output": "次に標準入力が空になるまで、入力から2つの整数を読み込み、次に、それらが接続されていなければ、それらを接続し、プリントアウトします。"
  },
  {
    "index": "F1625",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If they are connected it'll ignore.",
    "output": "接続されている場合は、無視します。"
  },
  {
    "index": "F1626",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that's our test client and that's a fine test client to make sure that any implementation does what we expect that it will.",
    "output": "これがテストクライアントプログラムで、このテストクライアントでどのような実装でも期待するように動作することを確認することができるのです。"
  },
  {
    "index": "F1627",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We've described the operations we want to implement all the way down to code and we have client code that we're going to have to be able to service with our",
    "output": "これで準備はできました。プログラムとして実装したいことはすべて説明し、実装が機能するかどうかを確認するクライアントプログラムも作ることができます。"
  },
  {
    "index": "F1628",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now we'll look at our first implementation of an algorithm for solving the dynamic connectivity problem, called Quick-find.",
    "output": "動的接続問題を解くアルゴリズムの最初の実装を見てみましょう。"
  },
  {
    "index": "F1629",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This is a so called eager algorithm, for solving kind activity problem.",
    "output": "これはいわゆる欲張りアルゴリズムで、接続問題をとくことが出来ます。"
  },
  {
    "index": "F1630",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The data structure that we're going to use to support the algorithm is simply an integer array indexed by object.",
    "output": "アルゴリズムで使っているデータ構造は対象でインデックス化された整数配列です。"
  },
  {
    "index": "F1631",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The interpretation is the two objects, P and Q are connected if and only if, their entries in the array are the same.",
    "output": "PとQの2つの対象が接続されているということは、配列の中の2つのエントリが同じであり、かつ、そのときに限ると考えることが出来ます。"
  },
  {
    "index": "F1632",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So for example in this example with our ten objects the idea array that describes the situation after seven connections is illustrated in the middle of the slide.",
    "output": "今回の10個の対象の例では、配列idで7つの接続が出来た後の状況を示しており、スライドの中央に示しています。"
  },
  {
    "index": "F1633",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So that, after the, at this point zero, five, and six are all in the same connected component, because they have the same array entry, zero.",
    "output": "で、ここでは、0、5、6はすべて同じ接続コンポーネントに含まれています。なぜなら、それらは同じ配列のエントリ、0になっているからです。"
  },
  {
    "index": "F1634",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And three, four, eight, and nine all have entry eight.",
    "output": "1、2、7も皆、エントリが1で、3、4、8、9はすべてエントリが8になっています。"
  },
  {
    "index": "F1635",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So that representation is, shows that they're connected.",
    "output": "つまり、このようにして、接続されていることを示しているのです。"
  },
  {
    "index": "F1636",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And clearly, that's going to support a quick implementation of the find operation.",
    "output": "また明らかに。findの操作に対する高速な実装をサポートすることができます。"
  },
  {
    "index": "F1637",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We just check the array entries to see if they're equal.",
    "output": "配列のエントリをチェックして、それらが等しいかどうかを見ればよいですね。"
  },
  {
    "index": "F1638",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Check if P and Q have the same ID.",
    "output": "PとQが同じIDを持っているのかをチェックするのです。"
  },
  {
    "index": "F1639",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, six and one have different IDs.",
    "output": "そう、6と1は違うIDになっています。"
  },
  {
    "index": "F1640",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "One has ID one, six has ID zero.",
    "output": "1のIDは1で6のIDは0です。"
  },
  {
    "index": "F1641",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "They're not in the same connected component.",
    "output": "この2つは同じ接続コンポーネントの中には含まれていないということです。"
  },
  {
    "index": "F1642",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Union is more difficult in order to merge the components, containing two given objects.",
    "output": "unionはもう少し難しく、与えられた2つの対象を含むコンポーネントを併合する必要があります。"
  },
  {
    "index": "F1643",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We have to change all the entries, whose ID is equal to one of them to the other one.",
    "output": "エントリがどちらかのIDに等しいID場合は、もう片方のIDniすべて変更する必要があるのです。"
  },
  {
    "index": "F1644",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And arbitrarily we choose to change the ones that are the same as P to the ones that are same as Q.",
    "output": "そのときにはPと同じものをすべてQと同じになるように変更する必要があります。"
  },
  {
    "index": "F1645",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So if we're going to union six and one, then we have to change entries zero, five, and six.",
    "output": "6と1を連結するときは、0、5、6のエントリを変更する必要があります。"
  },
  {
    "index": "F1646",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Everybody in the same connected component as six.",
    "output": "6と同じ接続コンポーネントにあるもの全部です。"
  },
  {
    "index": "F1647",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "From zero to one.",
    "output": "0から1に変更します。"
  },
  {
    "index": "F1648",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And this is, as we'll see, this is a bit of a problem when we have a huge number of objects, because there's a lot of values that can change.",
    "output": "これは、皆さんもわかると思いますが、対象の数が非常に大きくなるときには、ちょっと問題になります。"
  },
  {
    "index": "F1649",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But still, it's easy to implement, so that'll be our starting point.",
    "output": "なぜかというと、たくさんの値を変更することになるからです。"
  },
  {
    "index": "F1650",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So we'll start with a, a demo of how this works.",
    "output": "しかし、それでも簡単に実装できるので、これを最初のスタート地点にします。"
  },
  {
    "index": "F1651",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, initially, we set up the ID array, with each entry, equal to its index.",
    "output": "そう、最初は、配列idを準備して、各エントリはそのインデックスと等しくなっています。"
  },
  {
    "index": "F1652",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so all that says is that all the objects are independent.",
    "output": "こらは、すべての対象が独立であるということです。"
  },
  {
    "index": "F1653",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "They're in their own connected component.",
    "output": "皆、自分自身の接続コンポーネントに入っているということですね。"
  },
  {
    "index": "F1654",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, when we get a union operation.",
    "output": "さあ、ここでunionオペレーションを受け取ると、そうですね、4が3と接続されるとします。"
  },
  {
    "index": "F1655",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Then we're going to change, all entries, whose ID is equal to the first ID to the second one.",
    "output": "すると、すべてのエントリ、IDが1番目のIDと同じIDのものをすべて、2番目のIDに変更します。"
  },
  {
    "index": "F1656",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So in this case, we'll change the, connect three and four means that we need to change the four to a three.",
    "output": "この場合は、3と4を接続するということは、4を3に変更する必要があります。そして、もう少し続けてみましょう。"
  },
  {
    "index": "F1657",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And we'll continue to do a few more so you'll get an idea of how it works.",
    "output": "するとどのようにしているのかを理解するようになってきます。"
  },
  {
    "index": "F1658",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So three and eight now so to connect three and eight now three and four have to be connected to eight.",
    "output": "3と83と8を接続するために、こんどは3と4を8と接続する必要があります。"
  },
  {
    "index": "F1659",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So both of those entries have to change to eight.",
    "output": "これらのエントリをすべて8に変更する必要があります。"
  },
  {
    "index": "F1660",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay?",
    "output": "いいですか?"
  },
  {
    "index": "F1661",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So now, what about six and five?",
    "output": "今度は、6と5はどうでしょう?"
  },
  {
    "index": "F1662",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So again, we change the first one to match the second one.",
    "output": "今度も1番目のエントリを変更して、2番目と会わせる必要があります。"
  },
  {
    "index": "F1663",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So to connect six and five, we change the six to a five.",
    "output": "そうです、6と5を接続するには、6を5に変更します。"
  },
  {
    "index": "F1664",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "What about nine and four?",
    "output": "9と4はどうでしょうか?"
  },
  {
    "index": "F1665",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, now we have to change the, to connect nine and four, we have to change, 9's entry to be the same as 4's.",
    "output": "今度も変更する必要がありますね、9と4を接続するのですから、9のエントリを4と同じにする必要があります。"
  },
  {
    "index": "F1666",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So now we have three, four, eight, and nine.",
    "output": "これで、3、4、8、9ができました。"
  },
  {
    "index": "F1667",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "All have entries eight.",
    "output": "皆、エントリが8になっています。"
  },
  {
    "index": "F1668",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "They're all on the same connected component.",
    "output": "同じ接続コンポーネントに入っていることになりますね。"
  },
  {
    "index": "F1669",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Two and one means that we connect two and one by changing the 2201.",
    "output": "2と1についても、2を1に変更して接続します。"
  },
  {
    "index": "F1670",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Eight and nine are already connected.",
    "output": "8と9は、もう接続されています。"
  },
  {
    "index": "F1671",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "They have the same, entries in the idea array.",
    "output": "配列idのエントリがもう同じですから。"
  },
  {
    "index": "F1672",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that connected query, that find says, true, they're already connected.",
    "output": "接続のクエリ、findは真を返します。既に接続されています。"
  },
  {
    "index": "F1673",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And five and zero have different entries.",
    "output": "5と0のエントリは違っています。"
  },
  {
    "index": "F1674",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "They're not connected, so we'd return false, in that case, not connected.",
    "output": "接続されていないということですから、この場合は偽を返します。接続されていないということです。"
  },
  {
    "index": "F1675",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then, if we want to connect five and zero. Then, as usual we'll connect, the entry corresponding to both five and six to zero.",
    "output": "もし、5と0を接続したいのであれば、同じように、5と6の両方の対応するエントリを0に変更すればよいですね。"
  },
  {
    "index": "F1676",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Seven and two, union seven and two.",
    "output": "7と2は、7と2を接続しましょう。"
  },
  {
    "index": "F1677",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's an easy one.",
    "output": "これは簡単ですね。"
  },
  {
    "index": "F1678",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And union, six and one so there is three entries that have to get changed.",
    "output": "6と1を接続してみます。今度は3つのエントリを変更する必要があります。"
  },
  {
    "index": "F1679",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "All those zeros have to get changed to ones.",
    "output": "すべて0になっているのを1に変更する必要があります。"
  },
  {
    "index": "F1680",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that's a quick demo of Quick-find.",
    "output": "quickfindのデモを見てみました。"
  },
  {
    "index": "F1681",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now next we'll look at the code for implementating that.",
    "output": "今度は、これを実装したプログラムを見てみましょう。"
  },
  {
    "index": "F1682",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay, with this concrete demo in mind then moving to coding up this algorithim is pretty straight forward.",
    "output": "デモを頭に浮かべておくと、このアルゴリズムをプログラミングするのはきっと単純だと思います。"
  },
  {
    "index": "F1683",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Although it's an interesting programming exercise that a lot of us would get wrong the first time.",
    "output": "とても面白いプログラミングの練習で、最初は多くの人が間違えます。"
  },
  {
    "index": "F1684",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So let's start with the constructor, well we have a, a private integer array.",
    "output": "では、コンストラクターからはじめます。プライベートな整数配列があります。"
  },
  {
    "index": "F1685",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's our ID array.",
    "output": "これが、id配列です。"
  },
  {
    "index": "F1686",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's the data structure that's going to support this implementation.",
    "output": "このデータ構造を使って、実装を進めることになります。"
  },
  {
    "index": "F1687",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The constructor has to create the array and then go through and set the value corresponding to each index I to I.",
    "output": "コンストラクターは配列を生成し、配列のインデックスに対応した値をセットしていきます。i番目の配列にはiをセットします。"
  },
  {
    "index": "F1688",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The find operation, or connected operation.",
    "output": "findオペレーション、あるいは、connectedオペレーションです。"
  },
  {
    "index": "F1689",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's the easy one .",
    "output": "これは簡単ですね。"
  },
  {
    "index": "F1690",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This is the Quick-find algorithm.",
    "output": "これが、quickfindアルゴリズムです。"
  },
  {
    "index": "F1691",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So it simply takes its two arguments, P and Q, and checks whether their ID entries are equal, and returns that value.",
    "output": "2つの引数、PとQをとって、id配列のエントリが等しいかどうかをチェックして、その結果を返します。"
  },
  {
    "index": "F1692",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If they're equal, it returns true. If they're not equal, it returns false.",
    "output": "等しければ、真を返し、異なるときは偽を返します。"
  },
  {
    "index": "F1693",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The more complicated operation implement is a union.",
    "output": "複雑なオペレーションを実装しているのはunionです。"
  },
  {
    "index": "F1694",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And there, we find first the ID corresponding with the first argument, and then the ID corresponding to the second argument.",
    "output": "そこでは、まず、一番目の引数に対応するidを見つけ、次に二番目の引数に対応するidを見つけます。"
  },
  {
    "index": "F1695",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then we go through the whole array, and looking for the entries whose IDs are equal to the ID of the first argument, and set those to the ID of the second argument.",
    "output": "次に、すべての配列を探索して、一番目の引数のidと等しいidのエントリを探し、そこに二番目の引数のidをセットするのです。"
  },
  {
    "index": "F1696",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's a pretty straightforward implementation.",
    "output": "これはちょっと愚直な実装ですね。"
  },
  {
    "index": "F1697",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And I mentioned that a lot of us would get us wrong.",
    "output": "多くの人が間違いをおかすといいましたね。"
  },
  {
    "index": "F1698",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The mistake we might make is to put ID of P here rather than first picking out, that value.",
    "output": "ここで犯しやすい間違いは、ここに、一番目に取り出した値でなく、Pのidをセットしまうことです。"
  },
  {
    "index": "F1699",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And you can think about the implications of that. That's an insidious bug.",
    "output": "さて、これがquickfindの実装です。"
  },
  {
    "index": "F1700",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that's a fine implementation of QuickFind so the next thing to decide is how effective or efficient that algorithm is going to be and we'll talk in some detail about how to do that but for this it's sufficient to just think about the number of times the code has to access the array.",
    "output": "次に考えるのは、アルゴリズムがどれくらい効率的であるかということです。"
  },
  {
    "index": "F1701",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "As we saw when doing the implementation, both the initialized and union operations involved the for-loop that go through the entire array.",
    "output": "実行してわかるのは、初期化とunion操作の両方がforループを含んでいて、配列をすべて走査しています。"
  },
  {
    "index": "F1702",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So they have to touch in a constant proportional to n times after touching array entry.",
    "output": "したがって、配列のエントリにアクセスした後、一定のn倍の比率でアクセスする必要があります。"
  },
  {
    "index": "F1703",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Find Operation is quick, it's just to a constant number of times check array entries.",
    "output": "findオペレーションは高速で、配列のエントリに対するチェックは、コンスタントな回数です。"
  },
  {
    "index": "F1704",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And this is problematic because the union operation is too expensive.",
    "output": "これは問題で、union操作のコストが大きすぎるのです。"
  },
  {
    "index": "F1705",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In particular if you just have N union commands on N objects which is not unreasonable.",
    "output": "特にn個の対象に対して、n個のunionコマンドがあるときは、合理的でないことが明らかです。"
  },
  {
    "index": "F1706",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "They're either connected or not then that will take quadratic time in squared time.",
    "output": "それぞれが接続されているか、そうでないかのいずれかで平方的な時間という二次関数的な時間が必要になるのです。"
  },
  {
    "index": "F1707",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And one of the themes that we'll go through over and over in this course is that quadratic time is much to slow.",
    "output": "このコースを通して、繰り返し登場するテーマの一つが、二次関数的な時間は非常に遅いということです。"
  },
  {
    "index": "F1708",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And we can't accept quadratic time algorithms for large problems.",
    "output": "大規模な問題では、二次関数時間のアルゴリズムは適用することはできません。"
  },
  {
    "index": "F1709",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The reason is they don't scale.",
    "output": "なぜなら、スケールしないからです。"
  },
  {
    "index": "F1710",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "As computers get faster and bigger, quadratic algorithms actually get slower.",
    "output": "コンピュータがより高速に、大規模なものになっても、二次関数的なアルゴリズムは実際はどんどん遅くなるのです。"
  },
  {
    "index": "F1711",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, let's just talk roughly about what I mean by that.",
    "output": "簡単に私が意図していることをお話しておきます。"
  },
  {
    "index": "F1712",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "A very rough standard, say for now, is that people have computers that can run billions of operations per second, and they have billions of entries in main memory.",
    "output": "非常にラフな基準ですが、コンピュータは毎秒何十億もの命令を実行することができ、メモリには何十億ものエントリを格納することができます。"
  },
  {
    "index": "F1713",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that means that you could touch everything in the main memory in about a second.",
    "output": "つまり、メモリ上のすべてのエントリに約1秒以内でアクセスすることができます。"
  },
  {
    "index": "F1714",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's kind of an amazing fact that this rough standard is really held for 50 or 60 years.",
    "output": "このような不思議なことに、このような基準が50~60年もの間用いられてきました。"
  },
  {
    "index": "F1715",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The computers get bigger but they get faster so to touch everything in the memory is going to take a few seconds.",
    "output": "コンピューターはより大きくなりましたが、同時により高速にもなったので、メモリを全部アクセスするのに2、3秒ですむというものです。"
  },
  {
    "index": "F1716",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now it's true when computers only have a few thousand words of memory and it's true now that they have billions or more.",
    "output": "メモリ上にあるのが数千ワードのであれば正しいですし、数十億、それ以上の場合でも大丈夫です。"
  },
  {
    "index": "F1717",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So let's accept that as what computers are like.",
    "output": "ですからコンピューターはこのようなものだとしましょう。"
  },
  {
    "index": "F1718",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, that means is that, with that huge memory, we can address huge problems.",
    "output": "これは、巨大なメモリ空間があれば、巨大な問題を解決することができるということです。"
  },
  {
    "index": "F1719",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So we could have, billions of objects, and hope to do billions of union commands on them.",
    "output": "数十億の対象がある場合も、そこで数十億のunionコマンドを実行することは期待できるでしょう。"
  },
  {
    "index": "F1720",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And, but the problem with that quick find algorithm is that, that would take ten^18th operations, or, say array axises or touching memory.",
    "output": "しかし、問題はquickfindアルゴリズムで、10の18乗のオペレーション、あるいは、配列への操作やメモリアクセスが必要になるのです。"
  },
  {
    "index": "F1721",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And if you do the math, that works out to 30 some years of computer time.",
    "output": "簡単な計算で、三十数年もの計算時間となることがわかります。"
  },
  {
    "index": "F1722",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Obviously, not practical to address such a problem on today's computer.",
    "output": "現在のコンピューターでこのような問題を解くことは現実的ではないですね。"
  },
  {
    "index": "F1723",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And, and the reason is, and the problem is that quadratic algorithms don't scale with technology.",
    "output": "また、理由、問題は二次関数的なアルゴリズムが技術に対してスケールしないことです。"
  },
  {
    "index": "F1724",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You might have a new computer that's ten times as fast but you could address a problem that's ten times as big.",
    "output": "十倍の速さの新しいコンピュータがあれば、十倍の大きさの問題を解決しようとします。"
  },
  {
    "index": "F1725",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And with a quadratic algorithm when you do that. It's going to be ten times as slow.",
    "output": "しかし、二次関数的なアルゴリズムを使うと、十倍遅くなってしまうのです。"
  },
  {
    "index": "F1726",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's the kind of situation we're going to try to avoid by developing more efficient algorithms for solving problems like this.",
    "output": "このような状況を回避するために、より効率的なアルゴリズムを開発し、このような問題を解く必要があるのです。"
  },
  {
    "index": "F1727",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "All right so QuickFind is too slow for huge problems.",
    "output": "さて、高速findは巨大な問題には遅すぎます。"
  },
  {
    "index": "F1728",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, how are we going to do better?",
    "output": "では、どうやってより良く実行しましょうか?"
  },
  {
    "index": "F1729",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Our first attempt is an alternative called, Quick-union.",
    "output": "最初に、高速unionと呼ばれる代替案を試します。"
  },
  {
    "index": "F1730",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This is so called lazy approach to algorithm design where we try to avoid doing work until we have to.",
    "output": "これは、いわゆる遅延評価のアプローチで、する必要があるまで仕事をしないでおくというものです。"
  },
  {
    "index": "F1731",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It uses the same data structure or array ID with size M but now it has a different interpretation.",
    "output": "このアルゴリズムでは、サイズMの同じデータ構造、配列IDを使いますが、今度は異なる解釈をします。"
  },
  {
    "index": "F1732",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We are going to think of that array as representing a set of trees that's called a forest as depicted at right.",
    "output": "私たちは、この配列をフォレストと呼ばれる木の集合として解釈します。"
  },
  {
    "index": "F1733",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, each entry in the array is going to contain a reference to its parent in the tree.",
    "output": "スライドの右に示したようなものです。"
  },
  {
    "index": "F1734",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, for example, 3's parent is four, 4's parent is nine.",
    "output": "配列の各要素は、木の親への参照を含んでいます。たとえば、3の親は4で、4の親は9です。"
  },
  {
    "index": "F1735",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now each entry in the array has associated with it a root.",
    "output": "ここで、配列の各要素はルートに関連付けられています。"
  },
  {
    "index": "F1736",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's the root of its tree.",
    "output": "各要素の木のルートです。"
  },
  {
    "index": "F1737",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Elements that are all by themselves in just, in their own connected component, point to themselves, so one points to itself but also nine points to itself.",
    "output": "要素は、すべてそれ自体が自分につながったコンポーネントなので、自分自身を指しています。ですので1は1を指しています。"
  },
  {
    "index": "F1738",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's the root of the tree, containing two, four and three.",
    "output": "これは木のルートであり、2と4と3を含んでいます。"
  },
  {
    "index": "F1739",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, from this data structure we can associate with each item a root, which is representative, say, of it's connected component.",
    "output": "つまり、このデータ構造から、各要素とルートとを関連付けることができます。"
  },
  {
    "index": "F1740",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So that's the root of three is nine, going up that root.",
    "output": "接続されたコンポーネントを代表するのがルートと言うことですね。ですので、3のルートは9です。"
  },
  {
    "index": "F1741",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, once we can calculate these roots, then we can implement the find operation just by checking whether the two items that we're supposed to check with are connective where they have the same root.",
    "output": "さて、いったんルートが計算できればfind操作は実装できます。接続されているか確かめようとしている2要素が同じルートを持っているかを確かめれば良いだけです。"
  },
  {
    "index": "F1742",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's equivalent to saying, are they in the same connective component?",
    "output": "これは、同じ接続コンポーネントを持っているか、というのと同じことです。"
  },
  {
    "index": "F1743",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So that's some work, going to find the roots of each item but the union operation is very easy.",
    "output": "各要素のルートを探すのは少し作業がいりますが、unionはとても簡単です。"
  },
  {
    "index": "F1744",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Two items that are in different components. All we do is set the ID of P's route to the ID of Q's route.",
    "output": "2つの異なる要素を含んだコンポーネントを結合するには、ここでの2要素は異なるコンポーネントと考えられますが、PのルートIDをQのルートIDに設定するだけで良いです。"
  },
  {
    "index": "F1745",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Let's make P's tree point to Q.",
    "output": "ではPの木をQを指すようにしましょう。"
  },
  {
    "index": "F1746",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So in this case, we would change the entry of nine to be six to merge three and five.",
    "output": "この場合では、9のエントリを6にすることで、3と5とを結合します。"
  },
  {
    "index": "F1747",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The components containing three and five.",
    "output": "この木は3と5を含んでいますので。"
  },
  {
    "index": "F1748",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And with just changing one value in the array we get the two large components emerged together.",
    "output": "そして、配列内の1つの値を変更するだけで2つの大きなコンポーネントを結合できます。"
  },
  {
    "index": "F1749",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's the Quick-union algorithm.",
    "output": "これが高速unionアルゴリズムです。"
  },
  {
    "index": "F1750",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Because a union operation only involves changing one entry in the array.",
    "output": "なぜなら、union操作が配列内の1要素を変更するだけで良いからです。"
  },
  {
    "index": "F1751",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Find operation requires a little more work.",
    "output": "find操作は少し作業が必要です。"
  },
  {
    "index": "F1752",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So let's look at the Implementation, a demo of that one in operation first.",
    "output": "それでは実装を見てみましょう。まず1つの操作例をデモで見てみます。"
  },
  {
    "index": "F1753",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So again we, we start out the same way but now the idea array entry really means that every one of these things is a little tree where the one node each everyone pointing to itself.",
    "output": "ここでは、繰り返しになりますが、同じ方法で開始しますが、配列の要素の考え方はそれぞれの要素が小さな木になっており、ノードは自分自身を指していると考えます。"
  },
  {
    "index": "F1754",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's the root of it's own tree so now if we have to put four and three in the same component, then all we do is we take the root, of the component containing the first item and make that a child of the root of the component, component containing the second item.",
    "output": "自分自身の木のルート、ということです。ここで、4を3を同じコンポーネントに入れる必要があれば1番目の要素の入ったコンポーネントのルートを取り出し、これを2番目の要素の入ったコンポーネントのルートの子とすれば良いだけです。"
  },
  {
    "index": "F1755",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In this case we just make four as parent three.",
    "output": "この場合では、4の親を3とするだけです。"
  },
  {
    "index": "F1756",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So now three and eight.",
    "output": "それから3と8。"
  },
  {
    "index": "F1757",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So again, we take the first item and make it a child of the root of the tree containing the second item.",
    "output": "ここでも繰り返しますが、最初の要素を取り出し、それを2番目の要素を含んだ木のルートの子とします。"
  },
  {
    "index": "F1758",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So now three, four, and eight are in the same component.",
    "output": "ですので、3,4,8が同じコンポーネント内にあることになります。"
  },
  {
    "index": "F1759",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Six and five six goes below five.",
    "output": "6と5ですね。"
  },
  {
    "index": "F1760",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Nine and four, So now four is the root of the tree containing four is eight.",
    "output": "6が5の下に付きます。"
  },
  {
    "index": "F1761",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And the root of tree containing nine is nine. And so we make nine a child of eight.",
    "output": "ここで、4は4を含んだ木のルートは8で、9を含んだ木のルートは8ですので、9を8の子とします。"
  },
  {
    "index": "F1762",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Two and one, that's an easy one.",
    "output": "2と1ですね。これは簡単です。"
  },
  {
    "index": "F1763",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now if we get our, our eight and nine connected, we just checked that they have the same root and they both have the same root eight and so they're connected.",
    "output": "ここで、8と9が接続されているかチェックを受ければ、それらが同じルートを持つかどうかだけチェックします。"
  },
  {
    "index": "F1764",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Five and four 4's root is eight.",
    "output": "5と4の場合、4のルートは8です。"
  },
  {
    "index": "F1765",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "5's root is five.",
    "output": "5はルートが5ですから違います。"
  },
  {
    "index": "F1766",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Five and zero.",
    "output": "5と0ですね。"
  },
  {
    "index": "F1767",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Five goes to be a child of zero.",
    "output": "5が0の子になります。"
  },
  {
    "index": "F1768",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Seven and two seven goes to be a child of 2's root which is one.",
    "output": "7が2のルートである1の子になります。"
  },
  {
    "index": "F1769",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Six and one.",
    "output": "6と1ですね。"
  },
  {
    "index": "F1770",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "6's route is zero 1's its own route, so zero becomes a child of one.",
    "output": "6のルートは0で1は自分がルートなので、0がその子になります。"
  },
  {
    "index": "F1771",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Each one of these union operations just involves changing one entry in the array.",
    "output": "union操作の1つ1つが単純に配列の1要素を変更するだけです。"
  },
  {
    "index": "F1772",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And finally, seven and three.",
    "output": "最後に7と3ですね。"
  },
  {
    "index": "F1773",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So seven's root is one, three's root is eight, one becomes a child of eight.",
    "output": "7のルートは1で3のルートは8ですので、1が8の子となります。"
  },
  {
    "index": "F1774",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay and now we have one connected component with all the items together.",
    "output": "これで1つのコンポーネントを得、すべての要素がつながりました。"
  },
  {
    "index": "F1775",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Alright, so now let's look at the code for implementing Quick-union.",
    "output": "では高速unionの実装コードを見てみましょう。"
  },
  {
    "index": "F1776",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The constructor is the same as the other one.",
    "output": "コンストラクタは同じです。"
  },
  {
    "index": "F1777",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We create the array and then set each element to be it's own root.",
    "output": "配列を作り、各要素が自分自身をルートに設定します。"
  },
  {
    "index": "F1778",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now we have a private method that implements this process of finding the root by chasing parent pointers until we get to the point where I is equal to ID of I, and if it's not equal, we just move I up one level in the tree, set I equals ID of I and return it.",
    "output": "iがiのID値と等しくなるまで親への参照を追いかけます。等しくなければ、iを木の一段上に移動させます。"
  },
  {
    "index": "F1779",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So starting at any node, you just follow ID equals ID of I until they're equal and then you're at a root and that's a private method that we can use to implement the find operation or the connected operation.",
    "output": "ですので、どのノードから始めてもID値がiのID値と等しいものになるまで追いかけ、つまりルートにたどり着きます。これはprivateメソッドでありfindおよびconnected操作の実装に使用します。"
  },
  {
    "index": "F1780",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You just find the root of P and the root of Q and if you check if they're equal.",
    "output": "同じかどうかのチェックには、PのルートとQのルートを見つければよいだけです。"
  },
  {
    "index": "F1781",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then the union operation is simply find the two roots I and then set the idea the first one could be the second one.",
    "output": "union操作は簡素化しており、2つの要素のルートを探し、第1引数のIDを第2引数のそれに設定するだけです。"
  },
  {
    "index": "F1782",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Actually less code than for Quick Find, no fore loops.",
    "output": "高速findよりコード量は少ないです。forループがありません。"
  },
  {
    "index": "F1783",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "There's this one wild loop that we have to worry about a little bit.",
    "output": "少し心配する必要のあるwhileループが一個ありますが。"
  },
  {
    "index": "F1784",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But that's a quick and elegant implementation of code to solve the dynamic connectivity problem called Quick-union.",
    "output": "しかし、これは高速でエレガントなコード実装で、動的接続問題を解くものです。高速unionと呼ばれます。"
  },
  {
    "index": "F1785",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So now we're going to have to look at can this code be effective for large problems?",
    "output": "それでは、このコードが大きな問題に対して効率的かを見ていきましょう。"
  },
  {
    "index": "F1786",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Well unfortunately Quick-union is faster but it's also too slow.",
    "output": "まぁ、残念ながら高速unionは速いのですが、同時に遅すぎるのです。"
  },
  {
    "index": "F1787",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And it's a little different kind of too slow then for Quick Find, there's times when it could be fast, but there's also times when it could be too slow.",
    "output": "数倍速いこともありますが、数倍遅すぎることもあるのです。"
  },
  {
    "index": "F1788",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And the defect for Quick-union is that the trees can get too tall.",
    "output": "高速unionの欠点は、木がとても高くなってしまうことがあることです。"
  },
  {
    "index": "F1789",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Which would mean that the find operation would be too expensive.",
    "output": "これはつまり、find操作がとても高くついてしまうということです。"
  },
  {
    "index": "F1790",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Of each object just pointing to next and then to do a find operation for object at the bottom would involve going all the way through the tree.",
    "output": "各オブジェクトは次の要素を指しているだけですから底にあるオブジェクトに対するfind操作は木をすべて上っていく処理になります。"
  },
  {
    "index": "F1791",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Costing involving in the ray axises just to do the find operation and that's going to be too slow if you have a lot of operations.",
    "output": "コストは、単にfind操作を行うだけで配列のアクセス量が増えてしまいます。たくさん操作をすれば遅すぎるでしょう。"
  },
  {
    "index": "F1792",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay.",
    "output": "良いでしょう。"
  },
  {
    "index": "F1793",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, we've looked at the quick union and quick find algorithms.",
    "output": "私たちは高速なUnionおよびFindアルゴリズムを見てきました。"
  },
  {
    "index": "F1794",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Both of which are easy to implement.",
    "output": "どちらも実装は簡単ですが、巨大な接続問題をサポートできません。"
  },
  {
    "index": "F1795",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, how are we going to do better?",
    "output": "では、どのように改善したら良いでしょうか?"
  },
  {
    "index": "F1796",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's what we'll look at next.",
    "output": "それを次に見ていきます。"
  },
  {
    "index": "F1797",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "A very effective improvement, it's called weighting.",
    "output": "非常に効果的な改善案は、重み付けと呼ばれるものです。"
  },
  {
    "index": "F1798",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And it might have occurred to you while we are looking at these algorithms.",
    "output": "このコースのようなアルゴリズムの講義を見ると出会っていたかもしれませんね。"
  },
  {
    "index": "F1799",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The idea is to when implementing the quick union algorithm take steps to avoid having tall trees.",
    "output": "考え方としては、高速なUnionアルゴリズムを実装する際に段階を踏んで、高い木を作らないようにすることです。"
  },
  {
    "index": "F1800",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If you've got a large tree and a small tree to combine together what you want to try to do is avoid putting the large tree lower, that's going to lead to long tall trees.",
    "output": "大きな木と小さな木とを接続させるとき、試したいことは大きな木を下に付けないようにすることです。"
  },
  {
    "index": "F1801",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And there's a relatively easy way to do that.",
    "output": "これを実装するのには比較的簡単なやり方があります。"
  },
  {
    "index": "F1802",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "What we'll do is we'll keep track of the number of objects in each tree and then, we'll maintain balance by always making sure that we link the root of the smaller tree to the root of the larger tree.",
    "output": "付いているオブジェクトの数をそれぞれの木で追跡しておき、バランスを維持するようにします。小さい方の木のルートを大きい方の木のルートに必ず接続するようにすることで実現します。"
  },
  {
    "index": "F1803",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, we, we avoid this first situation here where we put the larger tree lower.",
    "output": "これで、私たちは最初の状況、大きい方の木が下に来る、という状況を回避できます。"
  },
  {
    "index": "F1804",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In the weighted algorithm, we always put the smaller tree lower.",
    "output": "重み付けアルゴリズムでは、常に小さい木が下に来ます。"
  },
  {
    "index": "F1805",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "How we, let's see how we implement that.",
    "output": "では、どのように実装するのかを見てみましょう。"
  },
  {
    "index": "F1806",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Let's see a demo first.",
    "output": "まずデモを見ましょう。"
  },
  {
    "index": "F1807",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Okay, so again start out in our normal starting position, where everybody's in their own tree.",
    "output": "最初は通常の開始状態と同じところから始めます。それぞれが自分自身の木にいます。"
  },
  {
    "index": "F1808",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And for when there's only two items to link it, it works, works the same way as before.",
    "output": "2つのアイテムしか接続しない場合は、従来と同じように動きます。"
  },
  {
    "index": "F1809",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But now, when we have eight to merge with four and three, we put the eight as the child, no matter which order their arguments came, because it's the smaller tree.",
    "output": "しかし、ここで要素8を4と3に接続する際には、8を子にします。"
  },
  {
    "index": "F1810",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, six and five doesn't matter, whichever one goes down doesn't matter.",
    "output": "引数順に関係なく、8の方が小さい木だからです。"
  },
  {
    "index": "F1811",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Nine and four, so now, nine is the small one four is the big one.",
    "output": "9と4ですが、9の方が小さい木で、4の方が大きい木ですから、9が下に置く木になります。"
  },
  {
    "index": "F1812",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Two and one, five and zero.",
    "output": "2と1、5と0。"
  },
  {
    "index": "F1813",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So now, five and zero five is in the bigger tree so zero goes below.",
    "output": "ここで、5の方が大きい木ですから、0が下に来ます。"
  },
  {
    "index": "F1814",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Seven and two, two is in the bigger tree so seven goes below.",
    "output": "7と2ですが、2の方が大きい木ですので7が下に来ます。"
  },
  {
    "index": "F1815",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Six and one they're in equal size trees.",
    "output": "6と1ですが、これらは同じ大きさの木ですね。"
  },
  {
    "index": "F1816",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And seven and three, three is in the smaller tree so it goes below.",
    "output": "そして7と3ですが、3の方が小さい木ですので、下につきます。"
  },
  {
    "index": "F1817",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, the weighted algorithm always makes sure that the smaller tree goes below.",
    "output": "このように、重み付けアルゴリズムでは小さい方の木が必ず下に配置されます。"
  },
  {
    "index": "F1818",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And again, we wind up with a single tree representing all the objects.",
    "output": "ここで、再びすべてのオブジェクトを表現する1本の木に巻き取りましたが、今度は、ある保証があります。"
  },
  {
    "index": "F1819",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But this time, we h ave some guarantee that no item is too far from the root and we'll talk about that explicitly in a second.",
    "output": "つい先ほどお話ししたとおり、ルートから遠く離れた要素は存在しない、ということです。"
  },
  {
    "index": "F1820",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, here's an example that shows the effect of doing the weighted quick union where we always put the smaller tree down below for the same set of union commands.",
    "output": "これが、重み付け高速Unionを行った効果を示した例です。ここでは、同じUnionコマンドを行った際に、小さい方の木が常に下に置かれるようになっています。"
  },
  {
    "index": "F1821",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This is with a hundred sites and 88 union operations.",
    "output": "これは100のサイトに88回Union操作を行ったものです。"
  },
  {
    "index": "F1822",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You can see in the top the big tree has some trees, some nodes, a fair distance from the root.",
    "output": "上の例では大きな木があり、中に少しの木とノードがあり、ルートからとても離れていますね。"
  },
  {
    "index": "F1823",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In the bottom, for the weighted algorithm all the nodes are within distance four from the root.",
    "output": "下の例では、重み付けアルゴリズムの場合で、ノードはすべてルートから4の距離までしか離れていません。"
  },
  {
    "index": "F1824",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The average distance to the root is much, much lower.",
    "output": "ルートからの平均距離はずっとずっと小さいのです。"
  },
  {
    "index": "F1825",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Let's look at the Java implementation and then we'll look in more detail at, at that quantitative information.",
    "output": "Javaの実装を見て、詳しいところを、定量的な情報を見てみましょう。"
  },
  {
    "index": "F1826",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, we used the same data structure except, now we need an extra array, that for each item, gives the number of objects in the tree routed at that item.",
    "output": "私たちは同じデータ構造を使いますが、今回は追加の配列が必要です。これは、各要素について、その要素に到達するまでのツリー内のオブジェクト数を与えます。"
  },
  {
    "index": "F1827",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Find implementation is identical to for quick union, you're just checking whether the roots are equal.",
    "output": "findの実装は高速unionと同じです。ルートが同一かどうかをチェックするだけです。"
  },
  {
    "index": "F1828",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "For the union implementation, we're going to modify the code to check the sizes.",
    "output": "union操作については、サイズをチェックするコードを変更します。"
  },
  {
    "index": "F1829",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And link the root of the smaller tree to the root of the larger tree in each case.",
    "output": "それぞれの場合で、小さい方の木のルートを大きい方の木のルートに接続します。"
  },
  {
    "index": "F1830",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then after changing the id link, we also change the size array.",
    "output": "idのリンクを変更した後、size配列も変更します。"
  },
  {
    "index": "F1831",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If we make id, i a child of j, then we have to increment the size of j's tree by the size of i's tree.",
    "output": "idをiからjの子に変更したら、jの木のサイズをiの木のサイズだけ増やします。"
  },
  {
    "index": "F1832",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Or if we do the other way around, then we have to increment the size of i's tree by the size of j's tree.",
    "output": "逆の場合では、iの木のサイズをjの木のサイズ分だけ増やす必要があります。"
  },
  {
    "index": "F1833",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that's the full code in white for implementing quick union.",
    "output": "白地になっているところが高速union全体のコードです。"
  },
  {
    "index": "F1834",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, not very much code but much, much better performance.",
    "output": "それほどコードは大きくないですが、ずっと良いパフォーマンスが得られます。"
  },
  {
    "index": "F1835",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In fact we can analyze the running time mathematically and show that defined operation, it takes time proportional to how far down the trees are in the node in the tree, the nodes are in the tree, but we can show that it's guaranteed that the depth of any node in the tree is at most the logarithm to the base two of N.",
    "output": "実際、数学的に実行時間を分析できます。定義した操作を行う時間は、ノードがどれだけ木の深い位置にあるかに比例しますがどのノードも木の深さが高々底が2のlogNに収まることが保証されていることが分かります。"
  },
  {
    "index": "F1836",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We use the notation Lg always for logarithm to the base two.",
    "output": "ここでlgは底が2のlogを常に表します。"
  },
  {
    "index": "F1837",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And, and, so for, if N is a thousand, that's going to be ten, if N is a million that's twenty, if N is a billion that's 30.",
    "output": "ですので、Nが1000なら10ですし、百万なら20、10億なら30です。"
  },
  {
    "index": "F1838",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's a very small number compared to N.",
    "output": "Nに比べれば非常に小さな数です。"
  },
  {
    "index": "F1839",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, let's look at the proof of that.",
    "output": "ではこの証明を見てみましょう。"
  },
  {
    "index": "F1840",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We do some mathematical proofs in, in this course when they're critical such as this one.",
    "output": "このコースでは、時々数学的証明をします。今回のように重要な場面では。"
  },
  {
    "index": "F1841",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And why is it true that the depth of any node x is, at most, log base two of N?",
    "output": "なぜ、どのノードxについても高さが高々底が2のlogNになるのでしょうか。"
  },
  {
    "index": "F1842",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Well, the key to understanding that is to, take a look at exactly when does the depth of any node increase?",
    "output": "理解する鍵は、任意のノードの深さが増加するのはどんなときなのかどんなときに木を深くたどることになるのかを正確に見ていくことです。"
  },
  {
    "index": "F1843",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The x's depth will increase by one, when its tree, T1 in this diagram, is merged into some other tree, T2 in this diagram.",
    "output": "この図に示すT1という木が他の木に結合するとき、Xの深さは1増加します。この図ではT2ですね。"
  },
  {
    "index": "F1844",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Well, at that point we said we only do that if the size of T2 was bigger than the or equal to size of T1.",
    "output": "このとき、T2の大きさがT1より大きいか等しいときときだけ結合が行われると言えます。"
  },
  {
    "index": "F1845",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, when the depth of x increases, the size of its tree at least doubles.",
    "output": "ですので、Xの深さが増加するときには木のサイズは少なくとも2倍になります。"
  },
  {
    "index": "F1846",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that's the key because that means that the size of the tree containing x can double at most log N times because if you start with one and double log N times, you get N and there's only N nodes in the tree.",
    "output": "Xを含む木のサイズは、最大でもlogN回で倍になります。なぜなら1から始めてlogN回だけ2倍していけばNに到達し、木にはN個のノードしかないことになるからです。"
  },
  {
    "index": "F1847",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that's a sketch of a proof that the depth of any node x is at most log base two of N.",
    "output": "これが任意のノードXの深さは高々底が2のlogNだという大まかな証明の流れです。"
  },
  {
    "index": "F1848",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And that has profound impact on the performance of this algorithm.",
    "output": "この事実が、このアルゴリズムの性能に深い影響を与えています。"
  },
  {
    "index": "F1849",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now instead of the initialization always takes time proportional to N. But now, both the union and the connected or find operation takes time proportional to log base two of N.",
    "output": "ここで、初期化は常にNに比例する時間がかかりますが、union、結合、find操作は底が2のlogNに比例します。"
  },
  {
    "index": "F1850",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And that is an algorithm that scales.",
    "output": "これがスケールできるアルゴリズムです。"
  },
  {
    "index": "F1851",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If N grows from a million to a billion, that cost goes from twenty to 30, which is quite not acceptable.",
    "output": "Nが100万から10億に増えたとしても、計算コストは20から30に増えるだけです。これならとても受け入れられるものです。"
  },
  {
    "index": "F1852",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, this was very easy to implement and, and we could stop but usually, what happens in the design of algorithms is now that we understand what it is that gains performance, we take a look and see, well, could we improve it even further.",
    "output": "さて、このアルゴリズムは実装がとても簡単で実行もすぐ終わりますが、通常はアルゴリズムのデザインを変えると、性能を上げることができるということが理解できます。"
  },
  {
    "index": "F1853",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And in this case, it's very easy to improve it much, much more.",
    "output": "この場合、もっとずっと簡単に改良できます。"
  },
  {
    "index": "F1854",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And that's the idea of path compression.",
    "output": "そのアイディアはパス圧縮です。"
  },
  {
    "index": "F1855",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And this idea is that, well, when we're trying to find the root of the tree containing a, a given node.",
    "output": "このアイディアとは、与えられたノードを含んだ木のルートを探そうとするとき、そのノードからルートまでのすべてのノードを触っています。"
  },
  {
    "index": "F1856",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We're touching all the nodes on the path from that node to the root.",
    "output": "その際に、通った各ノードがルートを指すようにしてしまうのが良いでしょう。"
  },
  {
    "index": "F1857",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "There's no reason not to.",
    "output": "そうしない理由もないですから。"
  },
  {
    "index": "F1858",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So when we're looking, we're trying to find the root of, of P.",
    "output": "ですので、ノードPのルートを探そうと検索しているとき、探し終わった後でそのまま戻って、パス上のノードはすべてルートを指すようにします。"
  },
  {
    "index": "F1859",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's going to be a constant extra cost. We went up the path once to find the root.",
    "output": "一定量の追加コストはかかるでしょうが、いったんルートを見つけたらパスを持ち上げて、木をより平坦にしていきます。"
  },
  {
    "index": "F1860",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And the reason would be, no reason not to do that.",
    "output": "そうしないでおく理由がないでしょう。"
  },
  {
    "index": "F1861",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We had one line of code to flatten the tree, amazingly.",
    "output": "驚くことに、木を平坦化するためのコードは1行です。"
  },
  {
    "index": "F1862",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Actually to make a one liner code, we use a, a simple variant where we make every other node in the path point to its grandparent on the way up the tree.",
    "output": "実際、1行のコードで1つの変数だけで、パス内の他のノードすべてを2世代前のノードを指すようにできます。"
  },
  {
    "index": "F1863",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, that's not quite as good as totally flattening actually in practice that it actually is just about as good.",
    "output": "実際には、全体を平坦化するよりは良くないですが、十分良いものです。"
  },
  {
    "index": "F1864",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, with one line of code, we can keep the trees almost completely flat.",
    "output": "このように、1行足すだけで木を概ね完全に平坦化できます。"
  },
  {
    "index": "F1865",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, this algorithm people discovered rather early on after figuring out the weighting and it turns out to be fascinating to analyze quite beyond our scope. But we mentioned this example to illustrate how even a simple algorithmah, can have interesting and complex analysis.",
    "output": "このアルゴリズムを、人々は重み付けアルゴリズムを発見してから比較的早く見つけ出しかなり本コースの範囲を外れるほど解析がイライラするものだと判明していますが、この例に触れることで、簡単なアルゴリズムであっても面白く、複雑な解析が必要なものになることを示しました。"
  },
  {
    "index": "F1866",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And what was proved by Hopcroft Ulman and Tarjan was that if you have N objects, any sequence of M union and find operations will touch the array at most a c (N + M lg star N) times.",
    "output": "Hopcroft,Ulman,Tarjanによると、N個オブジェクトがある場合、M個のunion-find操作をすると配列を高々c(N+Mlg*N)回しか触らないことが証明されています。"
  },
  {
    "index": "F1867",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And now, lg N is kind of a funny function.",
    "output": "lg*Nは変わった関数で、logN個の中から1を取得するのにかかる回数を指します。"
  },
  {
    "index": "F1868",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's the number of times you have to take the log of N to get one.",
    "output": "実世界では、この値は5より小さいと考えておくのが最善です。"
  },
  {
    "index": "F1869",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And the way to think, it's called the iterated log function.",
    "output": "ですので、重み付け高速Unionで、パス圧縮を施した方式の実行時間は、実世界では線形になるでしょう。"
  },
  {
    "index": "F1870",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And in the real world, it's best to think of that as a number less than five because lg two^ 65536 is five.",
    "output": "そして、もっと興味深いアッカーマン関数と呼ばれる関数まで改良できるでしょう。この関数はlg*よりもずっと遅くしか値が増えていきません。"
  },
  {
    "index": "F1871",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that means that the running time of weighted quick union with path compression is going be linear in the real world and actually could be improved to even a more interesting function called the Ackermann function, which is even more slowly growing than lg.",
    "output": "このアルゴリズムは線形に近づいてきているので、N×時間に比例するようになるように見えます。"
  },
  {
    "index": "F1872",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And another point about this is it so close to being linear that is t ime proportional to N instead of time proportional to N times the slowly growing function in N.",
    "output": "成長の遅い関数×Nではなくて、です。"
  },
  {
    "index": "F1873",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And people, looked for a long time for that, and actually it works out to be the case that we can prove that there is no such algorithm.",
    "output": "人々は、長い時間それを探していて、そのようなアルゴリズムは実際には存在しないことが証明できました。"
  },
  {
    "index": "F1874",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And it's important for us to know that theory and that will help us decide how to choose which algorithms we're going to use in practice, and where to concentrate our effort in trying to find better algorithms.",
    "output": "ですので、私たちが使っているアルゴリズムの背後にはたくさんの理論があり、その理論を知ることは重要であり、実際どのアルゴリズムを選べば良いか、どこにより良いアルゴリズムを用いようと努力を傾けるかを決める手助けになります。"
  },
  {
    "index": "F1875",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's amazing fact that was eventually proved by Friedman and Sachs, that there is no linear time algorithm for the union find problem.",
    "output": "FriedmanとSachsによって、このunion-find問題を解くアルゴリズムに線形時間で終わるものがないと証明されたのは驚きです。"
  },
  {
    "index": "F1876",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But weighted quick union with path compression in practice is, is close enough that it's going to enable the solution of huge problems.",
    "output": "しかし、パス圧縮付きの重み付けアルゴリズムは実用上は巨大は問題を解くことができるようになるには十分です。"
  },
  {
    "index": "F1877",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, that's our summary for algorithms for solving the dynamic connectivity problem.",
    "output": "では、動的接続問題を解くアルゴリズムについてのまとめです。"
  },
  {
    "index": "F1878",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "With using weighted quick union and with path compression, we can solve problems that could not otherwise be addressed.",
    "output": "重み付けアルゴリズムとパス圧縮を用いると、他のアルゴリズムでは対応ができなかった問題を解くことができます。"
  },
  {
    "index": "F1879",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "For example, if you have a billion operations and a billion objects I said before it might take thirty years.",
    "output": "たとえば、10億個オブジェクトがあって10億回操作があった場合、前に述べたように、30年かかるでしょう。"
  },
  {
    "index": "F1880",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We can do it in six seconds.",
    "output": "それを6秒で行うことができます。"
  },
  {
    "index": "F1881",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Now, and what's most important to recognize about this is that its the algorithm design that enables the solution to the problem.",
    "output": "このアルゴリズムについて認識する上で最も重要なことは、アルゴリズムのデザイン如何で問題を解くことができる、ということです。"
  },
  {
    "index": "F1882",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "A faster computer wouldn't help much.",
    "output": "高速なコンピュータを持ってきてもあまり役に立ちません。"
  },
  {
    "index": "F1883",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You could spend millions on a super computer, and maybe you could get it done in six years instead of 30, or in two months but with a fast logarithm, you can do it in seconds, in seconds on your own PC.",
    "output": "あるいは2ヶ月とかかもしれませんね。しかし、高速なアルゴリズムを用いれば皆さんのPCでも数秒で解くことができるのです。"
  },
  {
    "index": "F1884",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Welcome to the Johns Hopkins Data Science Track.",
    "output": "ジョンズ・ホプキンス・データ・サイエンス・トラックへようこそ。"
  },
  {
    "index": "F1885",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "I'm incredibly excited to tell you a little bit about the track and about where you're going to be going over the next nine months.",
    "output": "そして続く9ヶ月の間にあなたがどこまで辿り着く事になるか、についてお話するのは。"
  },
  {
    "index": "F1886",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "My name is Jeff Leek, and I'm a professor in the Johns Hopkins Bloomberg School of Public Health.",
    "output": "私はジェフ・リークといいます、ジョンズ・ホプキンス大学ブルームバーグ公衆衛生大学院の教授です。"
  },
  {
    "index": "F1887",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "I thought I'd lead off this introductory video with a quote by one of my favorite US Presidents, Teddy Roosevelt.",
    "output": "この入門ビデオを私の好きな合衆国大統領の一人,テディ・ルーズベルトの名言から始めたいと思います。"
  },
  {
    "index": "F1888",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "He said it's not the critic who counts.",
    "output": "彼は言いました。『重要なのは,あれこれと批判する人ではない。"
  },
  {
    "index": "F1889",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's not the person who points out how the person who's actually doing things is doing them wrong or messing up.",
    "output": "実際に仕事を行っている人が,どんな風に間違っているとか,へまをしているとか,そういったことを指摘する人ではないのだ。"
  },
  {
    "index": "F1890",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's the person who's actually trying to get things done, even when there are obstacles in the way.",
    "output": "そうではなく,障害を乗り越え,実際に仕事をやり遂げようとした人たちなのだ。"
  },
  {
    "index": "F1891",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And a lot of data science right now is being able to push through a lot of the difficulties that you have when you're dealing with either large or messy data.",
    "output": "』そして現在の多くのデータサイエンスでは,大きくて汚いデータを扱う際に遭遇する多くの困難を乗り越えてやり遂げることができるようになってきています。"
  },
  {
    "index": "F1892",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It includes collecting the data clean them up and then building new announced techniques that exploring new information about that data.",
    "output": "それには,データの収集,クリーニング,それからそのデータから新しい情報を引き出すための新しい分析技術の構築が含まれます。"
  },
  {
    "index": "F1893",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so, all of those steps are a little bit complicated and sometimes it opens you to criticism when you're trying to do something new and interesting.",
    "output": "そして,これらの全てのステップは少々複雑であり,何か新しく,興味深いことをしようとした際,批判にさらされることもあります。"
  },
  {
    "index": "F1894",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so I wanted to lead with a quote that said it's important to strive the valiantly do these sorts of things, even if you're going to take some criticism.",
    "output": "ですので,たとえ批判されることになっても、そういったことを勇敢にやり遂げようとすることが重要だ、と教えてくれる警句から始めたかったのです。"
  },
  {
    "index": "F1895",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the key challenge in data science is actually really nicely summed up in this quote by Dan Myer.",
    "output": "データサイエンスにおける鍵となる挑戦についてはダン・マイヤーのこの警句に本当によくまとめられています。"
  },
  {
    "index": "F1896",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "He says, ask yourselves, what problem you, have you ever solved, ever, that was worth solving, where you knew all of the given information in advance?",
    "output": "『振り返ってみてください,これまでの人生で,解く価値があるような問題を解くときに,前もって全ての情報が与えられていた,なんてことがあったでしょうか?"
  },
  {
    "index": "F1897",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Where you didn't have a surplus of information and have to filter some of it out, or you didn't have insufficient information and have to go find some?",
    "output": "情報が過剰なために,フィルターをかける必要もなく,あるいは情報が足りないために,探しに行かなくてもよかったような?"
  },
  {
    "index": "F1898",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so, I think that this is a kind of a critical quote because, in data science, this is usually what is going on.",
    "output": "』そして私は,これはけだし名言だと思います。データサイエンスでは,これこそが通常起こっていることだからです。"
  },
  {
    "index": "F1899",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You're either in a situation where you really don't have enough data to answer the question that you're interested in, and you have to go out and try to search for it, find it on the web, or find it in other places.",
    "output": "自分が興味を持っている疑問に答えるのに十分なデータを持っておらず,それらを調査しなければならないかもしれません,ウェブや他の場所で調べるということです。"
  },
  {
    "index": "F1900",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Or you're in a situation where you are overwhelmed with a surplus of data and you have to filter out all of the irrelevant information to try to narrow in on your question.",
    "output": "あるいは,過剰なデータによって困惑させられ,適当でない情報をフィルターにかけて除くことで,自分の疑問に合わせたものに限定しなければなりません。"
  },
  {
    "index": "F1901",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And you'll notice that I said question in both of those cases.",
    "output": "皆さんは今,いずれの場合にも私が「疑問」と口にしたことに気付かれたでしょう。"
  },
  {
    "index": "F1902",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And I think this goes to the heart of our philosophy about data science.",
    "output": "私の考えでは,これは,データサイエンスにおける我々の哲学の中心に位置するものです。"
  },
  {
    "index": "F1903",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We're interested in answering questions with data.",
    "output": "私たちは,データによって,疑問に答えることに興味があるのです。"
  },
  {
    "index": "F1904",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We think the question should come first and then the data should follow after.",
    "output": "疑問がはじめにあって,データは後からついてくるのです。このことは,それをさらに挑戦的にします。"
  },
  {
    "index": "F1905",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And that actually makes it more challenging, because sometimes, you can answer a question with some data but you might not be able to answer your question with some data.",
    "output": "なぜなら,皆さんはあるデータによって,ある疑問に答えることができるかもしれませんが,そうでない場合もあるからです。"
  },
  {
    "index": "F1906",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So this track is about refocusing on answering the question that you're interested in solving with the data that you have.",
    "output": "皆さんが手持ちのデータで解きたいと思うような疑問に、です。"
  },
  {
    "index": "F1907",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So I thought I'd tell you a little bit about the instructors that you'll be hearing from throughout the course of this, course track.",
    "output": "ここで,このコース・トラックを通して担当する講師について少し,ご紹介します。"
  },
  {
    "index": "F1908",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So we are all faculty in the Johns Hopkins Blumberg School of Public Health in the Biostatistics Department.",
    "output": "我々は皆,ジョンズ・ホプキンス大学の生物統計学科のブルームバーグ公衆衛生大学院の教員です。"
  },
  {
    "index": "F1909",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And you could say that we all do data intensive statistics in biology and medicine.",
    "output": "我々は生物学や医学における大量のデータを使う統計学に従事している,と言えるでしょう。"
  },
  {
    "index": "F1910",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Brian Caffo works on the statistics of brain, analyzing brain imaging data.",
    "output": "ブライアン・カフォは脳の統計学に従事,つまり脳の画像データを解析しています。"
  },
  {
    "index": "F1911",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And I work on the statistics of analyzing genomics data.",
    "output": "そして私はゲノムデータの解析の統計学に従事しています。"
  },
  {
    "index": "F1912",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And Roger Peng works on the statistics of analyzing fine particulate matter.",
    "output": "ロジャー・ペンは微粒子状物質の解析の統計学に従事しています。"
  },
  {
    "index": "F1913",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "All of us work on problems where the data aren't always clean and nice and easy to handle.",
    "output": "我々は皆,データがきれいで良く,扱いやすい,とは限らない問題を扱っています。"
  },
  {
    "index": "F1914",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "All of us work on problems where the questions that we want to answer are complicated and you have to break them down into parts.",
    "output": "我々は皆,答えたいと思っている疑問が複雑で,いくつかの部分に分割して扱う必要のあるようなものを扱っています。"
  },
  {
    "index": "F1915",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And all of us, sort of, work on questions where we're very passionate about trying to get the right answer so that we can help people in human health.",
    "output": "そして我々は皆,人類の健康に資するような疑問に適切な答えを得ようと,熱意をもって取り組んでいるのです。"
  },
  {
    "index": "F1916",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But the techniques that you're going to be learning about are not exclusive to biology and medicine.",
    "output": "しかしながら,この講座で皆さんが学ぶ技術は生物学や医学に限定されるものではありません。"
  },
  {
    "index": "F1917",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That's just one area where there's been a recent upsurge in the amount of data that's available.",
    "output": "これは,利用可能なデータ量が最近になって突如増加した一分野に過ぎないのです。"
  },
  {
    "index": "F1918",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So why data science?",
    "output": "ではなぜデータサイエンスなのでしょうか?"
  },
  {
    "index": "F1919",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Why should you take this program?",
    "output": "なぜ皆さんはこのプログラムを履修するのでしょうか?"
  },
  {
    "index": "F1920",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This is a cover of The Economist now.",
    "output": "これはエコノミスト誌の表紙です。"
  },
  {
    "index": "F1921",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's a little bit old I guess ancient history from a couple of years ago.",
    "output": "今となっては少し古く,2,3年も前の話題です。"
  },
  {
    "index": "F1922",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But it talks about the data deluge and it's really true. Over the last several years data has become much, much cheaper to collect.",
    "output": "しかしながら,これはデータの大洪水のお話で,実際,本当のことですが、ここ何年かにわたって,データは実に,実に安く集められるようになりました。"
  },
  {
    "index": "F1923",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It's much easier to store.",
    "output": "蓄積も簡単になっています。"
  },
  {
    "index": "F1924",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And there's so many free computing tools out there right now, that you can actually do something with this entire data deluge that's sort of assaulting all different areas of science and business.",
    "output": "そして現在,非常に多くの無料の計算ツールが世に出ており,皆さんは実際に全ての科学やビジネスの分野を襲いつつあるこのデータの大洪水を使って何事かをなすことができるのです。"
  },
  {
    "index": "F1925",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the other thing is that you've probably heard the term big data.",
    "output": "話題は変わりますが,ビッグデータという用語を聞いたことがあるでしょう。"
  },
  {
    "index": "F1926",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so we'll hear a little bit more about what we think about big data throughout the course of this particular course, the Data Scientist's Toolbox.",
    "output": "この講座,データサイエンティストの道具箱,を通じて,我々がビッグデータについて考えていることを少し詳しくお話しします。"
  },
  {
    "index": "F1927",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But big data is, sort of a new frontier in the sense that, we have data in areas that we didn't used to have that data.",
    "output": "しかしビッグデータは,実に最先端と言えるものです。これまで持ちえなかった分野のデータを持っている,という意味で。"
  },
  {
    "index": "F1928",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We didn't have access to information about GPS coordinates from cars from everybody in the entire world.",
    "output": "全世界の人々の自動車からのGPS座標の情報へのアクセスなんてできませんでした。"
  },
  {
    "index": "F1929",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It wasn't possible to sequence everybody's genome.",
    "output": "一人ひとりのゲノム情報をシーケンスすることもできませんでした。"
  },
  {
    "index": "F1930",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And now that's all possible.",
    "output": "そして現在,これらはすべて可能となりました。"
  },
  {
    "index": "F1931",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So we have access to this data and it allows us to answer questions we never could before.",
    "output": "こういったデータにアクセスできるようになり,従来不可能であった疑問に答えることが,可能となりました。"
  },
  {
    "index": "F1932",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, it's an incredibly exciting time, and you're somebody who can get in there and use that data to answer those questions.",
    "output": "というわけで,今,本当に刺激的な瞬間であり,皆さんはそれに取組み,そういった疑問に答えるためにデータを使用できる,一員なのです。"
  },
  {
    "index": "F1933",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So why statistical data science?",
    "output": "ではなぜ,統計的データサイエンスなのでしょうか?"
  },
  {
    "index": "F1934",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You'll notice that we're, all of your instructors are biostatistics professors and so this will, this data science track will obviously have a little bit of a statistical bend.",
    "output": "皆さんお気づきのように,この講座の講師はすべて生物統計の教授ですので,このデータサイエンス・トラックは明らかに幾分,統計学的な傾向を持っています。"
  },
  {
    "index": "F1935",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "I think that that's appropriate given that statistics is the science of learning from data.",
    "output": "統計学とはデータから学ぶ科学であると。"
  },
  {
    "index": "F1936",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, data is very, very, it's very rare that you'll get a data set where all of the answers are really clear, and there's no uncertainty.",
    "output": "何の不確実性もなく,全ての答えが明らかであるようなデータセットを得ることは,本当に本当に,極めて稀なことです。"
  },
  {
    "index": "F1937",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In any case where there is uncertainty, that's where statistics comes and plays a role.",
    "output": "不確実性があるような場合はいつでも,統計学が必要で,何らかの役割を果たします。"
  },
  {
    "index": "F1938",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, this is a again, a little bit older New York Times article now, but it talks about how the key word for a lot of graduates to open the door for a lot of jobs, is to learn about statistics.",
    "output": "これはまた,少し古いニューヨーク・タイムスの記事ですが,多くの大学卒業生にとって多くの仕事への扉を開くキーワードが,統計を学ぶことである,と述べています。"
  },
  {
    "index": "F1939",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So why are you lucky?",
    "output": "ではなぜ皆さん幸運なのでしょうか?"
  },
  {
    "index": "F1940",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You're lucky because this moment, right now, in time is sort of like the moment that Jeff Bezos discovered the internet.",
    "output": "それは,今この瞬間が,ジェフ・べゾスがインターネットを発見した瞬間の様なものだからです。"
  },
  {
    "index": "F1941",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "He got into building a internet company at the time when there was this explosive growth in internet usage and it just opened the door for the opportunity to build something amazing and huge and wonderful.",
    "output": "彼はインターネット利用が爆発的に成長しつつあるときにインターネットの会社を作り,驚異的で,巨大で,素晴らしい何かを作り上げる機会の扉を開いたのです。"
  },
  {
    "index": "F1942",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And sort of, that's the right, that's what the time is right now for data.",
    "output": "そして言うなれば,データにとって,今がその瞬間なのです。"
  },
  {
    "index": "F1943",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It sort of there's an explosive growth of data in every possible area you can imagine.",
    "output": "皆さんが想像しうる全ての領域でデータが爆発的に成長しつつあるのです。"
  },
  {
    "index": "F1944",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so it's the opportunity right now to sort of jump on a rocket and, and find out something interesting, and, and sort of carry it off into a, a really major endeavor.",
    "output": "まさに今,ロケットに乗り込み,何か面白いものを見出す絶好の機会なのです。そして,それを大々的に実行に移すべき時なのです。"
  },
  {
    "index": "F1945",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "You're also lucky because tools and competitions and websites have all been developed around the idea of helping to learn about data, but also getting involved in projects that have super high profile results.",
    "output": "ツール,コンテスト,ウェブサイトが全て開発されてきており,それによりデータを学ぶことを助けるだけでなく,大変注目を集める結果を生むプロジェクトへの参加も可能となっています。"
  },
  {
    "index": "F1946",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, one example is the Heritage Health Prize, which I'm showing you a picture of here.",
    "output": "1つの例がここに示すHeritageHealthPrizeです。"
  },
  {
    "index": "F1947",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "The Heritage Health Prize was a $3 million contest for people who could analyze data and come up with a better predictor of who would be admitted to a hospital in another year.",
    "output": "HeritageHealthPrizeは賞金300万ドルのコンテストで,データを解析することにより,次の年に病院に入院することになる人をより良く予測する手法を開発した人々に与えられたものです。"
  },
  {
    "index": "F1948",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So you can see that's a huge amount of money that's being invested in these ideas of algorithm development and data science of prediction.",
    "output": "非常な大金がこれらのアルゴリズム開発や予測のデータサイエンスに投資されつつあることがお分かりでしょう。"
  },
  {
    "index": "F1949",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So it gives you an exciting opportunity to get involved in projects that, sort of, weren't happening five or ten years ago.",
    "output": "つまり,5年や10年前には無かったようなプロジェクトへ参加する刺激的な機会が提供されているのです。"
  },
  {
    "index": "F1950",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This course track will focus almost exclusively on the use of the R programming language.",
    "output": "このコース・トラックでは,もっぱら,プログラミング言語Rの使用に焦点を当てます。"
  },
  {
    "index": "F1951",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so I thought it was appropriate to talk a little bit about why we like R so much.",
    "output": "いい機会ですので,なぜ我々がRをそんなに好きなのか,お話ししましょう。"
  },
  {
    "index": "F1952",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So we like R obviously, because we all use it.",
    "output": "我々がRのこと好きなのは,まず,我々全員が使っているからです。"
  },
  {
    "index": "F1953",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But it's also sort of increasingly the most commonly used language for data science.",
    "output": "それに加え,データサイエンスのために使われる最も一般的に使われる言語でもあるためです。"
  },
  {
    "index": "F1954",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "There are other languages that are also very useful.",
    "output": "非常に有用な,他の言語もあります。"
  },
  {
    "index": "F1955",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And we won't be talking about them a lot in this course but they're obviously good complements to the R programming language.",
    "output": "このコースではそれらについて多くはお話ししませんが,例えばPythonなどは,プログラミング言語Rを良く補完してくれます。"
  },
  {
    "index": "F1956",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Like, Python, in this class we'll be focusing on R because it has a broad range of packages that allow you to go from the rawest of raw files, all the way to interactive reports and documents and web apps that you can share with your collaborators.",
    "output": "このクラスでRに注目するのは,正に生データファイルそのものから,共同制作者と共有できるようなインタラクティブな報告書や文書やウェブアプリに至るまでを可能とする幅広いパッケージを有しているからです。"
  },
  {
    "index": "F1957",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, some more reasons why we might use r is because it's free, it has a comprehensive set of packages, like I mentioned, for all the processes that are involved in data science.",
    "output": "Rを使う他の理由として,無料だということがあります。また,私がお話ししたようなデータサイエンスの全ての過程に対する包括的なパッケージ群を有しています。"
  },
  {
    "index": "F1958",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It has one of the best development environments of any programming language, in our studio.",
    "output": "また,全てのプログラミング言語の開発環境の中で最良のものの一つである,RStudioを有しています。"
  },
  {
    "index": "F1959",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "It also has an amazing ecosystem of developers.",
    "output": "また,開発者の素晴らしい生態系も有しています。"
  },
  {
    "index": "F1960",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And what I mean by that is there are a lot of people that are developing our packages.",
    "output": "どういう意味かと言うと,Rパッケージを開発する多くの人々がいるということです。"
  },
  {
    "index": "F1961",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And they're also available to get in touch with on mailing lists or by email or on stack overflow.",
    "output": "そして彼らに,メーリングリストや,個別の電子メール,あるいはStackOverflowにおいて,連絡をとることができます。"
  },
  {
    "index": "F1962",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so it's really possible to learn about the cutting edge of packages that are being developed.",
    "output": "ですので,文字通り開発されつつある最新のパッケージについて,学ぶことができるのです。"
  },
  {
    "index": "F1963",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "There also very easy to install and play nicely together, which is a, a feature that doesn't always happen in a lot of the languages that are used for data science.",
    "output": "これらはインストールも容易で,複数のパッケージが実にうまく働きますが,これはデータサイエンスで使われる多くの言語にはない利点です。"
  },
  {
    "index": "F1964",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the next thing I thought I would mention is, who is a data scientist?",
    "output": "次にお話ししたいのは,誰がデータサイエンティストなのか?"
  },
  {
    "index": "F1965",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And I thought I'd mention that some people that I think are data scientists, that might not, either label themselves that way or have other people label them that way.",
    "output": "これからデータサイエンスについてたくさんお話しするのですが,本人が自分はそうだと言っておらず,また他の人もそう呼んでいなくても,私がデータサイエンティストだと思う人たちについて,ご紹介したいと思います。"
  },
  {
    "index": "F1966",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So the first is Daryl Morey, who'd the general manager of the Houston Rockets basketball team in the US.",
    "output": "まず,ダリル・モーリーです。彼は米国のバスケットボールチームのヒューストン・ロケッツのジェネラル・マネージャーです。"
  },
  {
    "index": "F1967",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So he uses data to analyze basketball players and transactions and making trades.",
    "output": "彼はデータを使ってバスケットボール選手を分析し,契約やトレードを行います。"
  },
  {
    "index": "F1968",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so I would consider him to be a data scientist Because he's a person who uses data to answer questions about basketball.",
    "output": "ですので,私は彼を一人のデータサイエンティストだと考えます。彼はバスケットボールについての疑問に,データを使って答えようとしている人だからです。"
  },
  {
    "index": "F1969",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Another data scientist that you may, or may not, have heard of, is Hilary Mason.",
    "output": "もう一人のデータサイエンティストは,皆さんがご存知かどうか分かりませんが,ヒラリー・メイソンです。"
  },
  {
    "index": "F1970",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, she used to be the Chief, Data Scientist at Bentley, and now she's at Accel Partners.",
    "output": "彼女はBitly社のチーフ・データサイエンティストだったのですが,現在はAccelPartner社にいます。"
  },
  {
    "index": "F1971",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so, she uses data to answer all sorts of questions about mining the web, and understanding that way that humans interact with each other through social media.",
    "output": "彼女はデータを使って,ウェブを探索したり,人々がソーシャルメディアを通してどのように接触しているかを理解するためのあらゆる種類の疑問に答えます。"
  },
  {
    "index": "F1972",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, again she might not label herself a data scientist, but I think the way that she uses data, is a evocative of the sort of ideas, that we would like to convey in this data sciences track.",
    "output": "この場合も,彼女自身はデータサイエンティストと名乗らないかもしれませんが,私は,彼女がデータを使う方法は,このデータサイエンス・トラックで伝えたいと考えている考え方を思い起こさせるものだと思います。"
  },
  {
    "index": "F1973",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "If you're taking this course, you probably know who Daphne Koller is.",
    "output": "このコースを履修している人なら,ダフニー・コラーが誰かご存知でしょう。"
  },
  {
    "index": "F1974",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "She's the CEO of Coursera.",
    "output": "彼女はCoursera社のCEOです。"
  },
  {
    "index": "F1975",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But she's also another person who's using all the data they're collecting through Coursera to better, to improve the way that we do educational delivery and educational assessment at this huge scale that Coursera is providing.",
    "output": "彼女もまた,Courseraから集めたデータを使い,ここCourseraが行っているような大規模な教育の供給や教育的な評価の方法を改善しようと取り組んでいる人です。"
  },
  {
    "index": "F1976",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And finally, Nate Silver is one of the most famous data scientists, or statisticians in the world today.",
    "output": "そして最後に,ネイト・シルバーですが,彼は今日の世界で,もっとも有名なデータサイエンティスト,あるいは統計学者です。"
  },
  {
    "index": "F1977",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So he used a large amount of totally free public data to make predictions about who would win elections in the United States, and was remarkably accurate.",
    "output": "彼は大量の全く無料の公的なデータを使い,米国の選挙で誰が勝つかという予測をし,それが極めて正確なものだったのです彼にここで最後のデータサイエンティストとして登場してもらったのは,彼は公的な無料のデータを使って,多くの人々が読み,また興奮するような驚異的な製品を生み出せたからです。"
  },
  {
    "index": "F1978",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So our goal is to teach you about a bunch different skills that will be useful for you as a data scientist.",
    "output": "我々のゴールは,データサイエンティストとして有用な多くの異なる技術を皆さんに教えることです。"
  },
  {
    "index": "F1979",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, this is a Venn Diagram and some statisticians and data scientists don't like Venn Diagrams but I'm going to get, show you one anyway.",
    "output": "データサイエンティストや統計学者の中にはベン図が嫌いな人もいますが,ともかく,これで説明します。"
  },
  {
    "index": "F1980",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so, this Venn Diagram has Data Science at the, sort of, the center of this Venn diagram that intersects several different skills.",
    "output": "このベン図では,データサイエンスが中心にあり,異なるいくつかの技術を横断しています。"
  },
  {
    "index": "F1981",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So, if you look right here there's data science and it involves three different components.",
    "output": "データサイエンスですね,これは3種の異なる要素を含んでいます。"
  },
  {
    "index": "F1982",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "There's hacking skills, there's math and statistics knowledge, and there's substantive expertise.",
    "output": "これは「ハッキング技術」,これは「数学と統計学の知識」,そしてこれは「十分な専門性」ですね。"
  },
  {
    "index": "F1983",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so our data science track will focus a little bit on each of these, but it will primarily focus on math and statistics knowledge and hacking skills.",
    "output": "我々のデータサイエンス・トラックではこれらの何れにも焦点を当てますが,基本的には数学と統計学の知識とハッキング技術に焦点を絞ります。"
  },
  {
    "index": "F1984",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so math and statistics knowledge sort of speaks for itself.",
    "output": "「数学と統計学の知識」はそのままを表していますね。"
  },
  {
    "index": "F1985",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "We're going to teach you a little bit about math and a little bit about statistics.",
    "output": "数学について少し,また統計学について少し教えていきます。"
  },
  {
    "index": "F1986",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "One thing is we're going to teach you a little bit about computer programming or at least computer programming with R, which will allow you to access data and play around with it and analyze it, plot it.",
    "output": "1つは,コンピュータのプログラミングについて,少なくともRを使ったプログラミングについて。これにより,皆さんはデータにアクセスでき,色々操作したり,分析したり,プロットしたりできるようになります。"
  },
  {
    "index": "F1987",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "But hacking skills also has another component to it which is the ability to go out and answer questions for yourself.",
    "output": "しかしながら,ハッキング技術には外に出て皆さん自身のために疑問に答える能力という別の要素も含まれます。"
  },
  {
    "index": "F1988",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "One key component of a data scientist job right now is that most of the answers aren't already outlined in the textbook.",
    "output": "現在のデータサイエンティストの仕事の鍵となる要素の1つは,殆どの答えはまだ教科書に書かれていない,ということです。"
  },
  {
    "index": "F1989",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "This is all new stuff that's happening.",
    "output": "全て今現在起こりつつあることなのです。"
  },
  {
    "index": "F1990",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So what are the major skills of being a data scientist is being to go to Google, and go to Stack Overflow, and go to one of the other sites and look up what you need to learn and figure out what answers you know and what answers you don't know, and then figuring out how you can use the information you have to answer the question that you'd like to answer.",
    "output": "データサイエンティストであるための主要な技術は,GoogleやStackOverflow,それに他のサイトへ行って、何を学ぶ必要があるのかを調べ、どのような答えを知っているのか、そしてどのような答えを知らないのかを見出し、それから、自分が答えたいと思う疑問に答えるため、どのように手持ちの情報を使えばよいのか、を見出すことです。"
  },
  {
    "index": "F1991",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "That might be the reason you're taking this course track.",
    "output": "皆さんがこのコース・トラックを履修するのを決めた理由かもしれません。"
  },
  {
    "index": "F1992",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And so you can see this is a plot of listings are for data science jobs over time and of course it's exploding.",
    "output": "このグラフはデータサイエンスの仕事の一覧と時間の関係をプロットしたもので、もちろん爆発的に増えています。"
  },
  {
    "index": "F1993",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And we'll talk a little bit about why you shouldn't extrapolate, necessarily, from your data forever, but it does suggest that data science is a hot area that's growing and I think obviously we're very excited about it and hope you're excited about it too.",
    "output": "これを必ずしも永久に外挿すべきではないことをお話していきますが、しかしこれはデータサイエンスが成長しつつあるホットな領域であることを示唆しており、我々はそのことに興奮していますし、皆さんにもそうであって欲しい、と思います。"
  },
  {
    "index": "F1994",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "So this course, Data Scientist's Toolbox, will continue with lectures on the following three things.",
    "output": "このコース、データサイエンティストの道具箱では、以下の3種のことについての講義が続きます。"
  },
  {
    "index": "F1995",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "First, we're going to introduce you to the course track.",
    "output": "はじめに、このコース・トラックについて紹介をします。"
  },
  {
    "index": "F1996",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Then we're going to tell you a little bit about getting the tools that you need to get set up and get installed, hopefully get you over that hump.",
    "output": "それから、いくつかのツールのセット・アップとインストールについて少しお話します。"
  },
  {
    "index": "F1997",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "And then we're going to give you the basic background on data science sort of writ large, so that you'll be ready to jump into any of the individual classes and really take off.",
    "output": "それから、我々はデータサイエンスの背景となる基本的な知識について、いくつか取り上げて詳しく説明していきます。"
  },
  {
    "index": "F1998",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "Looking forward to seeing you in the rest of the class.",
    "output": "では、残りの講義でお会いすることを楽しみにしています。"
  },
  {
    "index": "F1999",
    "instruction": "次の英語を日本語に翻訳してください。",
    "input": "In week two of course, we're going to be covering a bunch of software that you're going to install that will constitute the data scientist's toolbox, as we described it for this course's track.",
    "output": "コースの2週目では,このコースの名前通りデータサイエンティストの道具箱を構成する多くのソフトウェアをインストールします。"
  }
]